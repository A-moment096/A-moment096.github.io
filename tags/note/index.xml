<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Note on A Moment's Rest</title><link>https://a-moment096.github.io/tags/note/</link><description>Recent content in Note on A Moment's Rest</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 05 Sep 2025 06:45:48 +0000</lastBuildDate><atom:link href="https://a-moment096.github.io/tags/note/index.xml" rel="self" type="application/rss+xml"/><item><title>（也许是）一个 Git 教程？其三</title><link>https://a-moment096.github.io/posts/2025/08/git_3/</link><pubDate>Tue, 26 Aug 2025 18:28:16 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/08/git_3/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post （也许是）一个 Git 教程？其三" /&gt;&lt;p&gt;&lt;em&gt;最后一节，聊聊如何在 GitHub 上进行多人协作吧~&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图信息请参考第一节内容，谢谢~&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=455026" theme="#2980b9" loop="never"&gt;&lt;/meting-js&gt;
&lt;h2 id="所以git-的远程到底是什么东西"&gt;所以，Git 的远程到底是什么东西？
&lt;/h2&gt;&lt;p&gt;我们之前提过，Git 通过 &lt;em&gt;远程 (Remote)&lt;/em&gt; 来实现和他人合作。我们甚至已经介绍了一些和远程进行交互的命令了。然而，Git 究竟是怎么实现这一功能的？这个功能有什么特点呢？我们和他人进行协作开发时，有什么要注意的点呢？我们一点点来介绍。我们先系统地介绍一下 &lt;em&gt;远程&lt;/em&gt; 是什么东西吧。&lt;/p&gt;
&lt;h3 id="远程不过是另一台装了-git-的机器"&gt;远程：不过是另一台装了 Git 的机器
&lt;/h3&gt;&lt;p&gt;实际上远程并不神秘。得益于 Git 分布式的特性，每一台安装了 Git 且拥有项目源码的机器都可以说是某个远程。或者说远程是相对的：有两台机器 A 和 B，都拥有同一个项目的源码并安装了 Git，那么对于 A 来讲 B就是远程，而对 B 来讲 A 也是远程。而不同机器之间的通信则可以通过 SSH 完成，如果是比较老的项目，或者不希望通过 SSH 来连接的情况，我们甚至可以使用邮件进行通信，传递代码，就像 Linux 内核，GCC 等项目那样。总之，通过这种 &lt;em&gt;每个设备都存储一份代码&lt;/em&gt; 的形式， Git 就实现了分布式的代码存储，每个设备既可以是正在工作的仓库，又可以是为他人提供源码的仓库。&lt;/p&gt;
&lt;p&gt;然而，大量的实践证明，有时候有一个中心服务器真的会很省事。大家把代码的更新放在一台公开的服务器上，然后可以从这一个服务器上拉取代码，可以很好地保证开发进度以及代码的一致性。不过这样又失去了 Git 天生的分布式特性。所以，到底哪个更好呢？真分布式还是采用某个中心的代码服务器？&lt;/p&gt;
&lt;h3 id="对比真分布式-vs-中心仓库"&gt;对比：&lt;em&gt;真&lt;/em&gt;分布式 vs 中心仓库
&lt;/h3&gt;&lt;p&gt;Git 一开始就是支持分布式存储的，这样最大的好处在于，每一个人拥有的仓库都是这个代码的一份备份。假如一个项目参与的人越多，这个项目的备份就会越多。而且每个人都是自己拥有的这份代码的主人，自己对代码拥有完全的掌控权，可以自行决定自己的代码要不要提交给别人，或者要不要接受来自他人的变更等。这种去中心化的，人人平等的思想非常符合自由开源的精神。另外这种方式不是很依赖某个中心设备，不会因为这一个设备断掉而直接完全不可用。如 Linux 内核，GCC 编译工具链等都没有一个一般意义上的中心代码服务器用来让所有合作者都往里面推送代码或者从里面拉取更新。&lt;/p&gt;
&lt;p&gt;然而中心化的服务器自然是有它的好处的。比如说有三个人在同一个项目工作，三人没有一个中心代码仓库而是互相传递更新的代码，如果三位都对代码进行了不同的且有一定冲突的代码，那么在同步时肯定会面临很多的麻烦。而如果他们的代码存放在一个中心服务器上，那这个服务器就会忠实地记录每个人对它的修改，进而避免所有人的代码一起涌上来的尴尬，同时保持大家的进度都在同一阶段，避免每个人有自己的想法进而没法合并（即便其实可以用分支也是可以的）。另外如果在某个项目里，开发团队是有明确分工的，那么这时候应该有一个人负责对代码进行审阅修改，而此时中心服务器的优势就体现出来了，让审阅者（们）单独拥有对中心服务器代码的修改权，然后审阅者（们）就可以直接在该服务器上进行审阅合并等操作，且所有的合作者都可以直接从该位置拉取最新的代码。也许有人说，把代码直接交给审阅者不就行了，为什么非得有个中心服务器的参与？然而如果真是这样的话，审阅者他自己的电脑也在某种程度上成为了那个中心服务器了。就我个人而言，我是想不到什么普通项目有必须使用去中心化工作流程的必要的。一般来讲都还是有一个（当然也可以多个）代码托管处会好很多。&lt;/p&gt;
&lt;p&gt;那么，谁是这个星球上最受欢迎的 &lt;em&gt;中心代码仓库&lt;/em&gt; 呢？&lt;/p&gt;
&lt;h2 id="代码托管平台们"&gt;代码托管平台们
&lt;/h2&gt;&lt;h3 id="github-the-blessed-one"&gt;GitHub: The blessed one
&lt;/h3&gt;&lt;p&gt;向您隆重介绍，这个星球最受欢迎代码托管平台，汇集无数人智慧结晶，全世界最大同性（？）交友网站（&lt;a class="link" href="https://www.flysnow.org/2019/01/09/github-milestones" target="_blank" rel="noopener"
&gt;迫真&lt;/a&gt;，95%以上的用户都是男性），GitHub。第一期其实已经有介绍过，GitHub 和 Git 之间的关系是什么样的，以及大家可以怎么使用 GitHub。这里我们再多聊两句。&lt;/p&gt;
&lt;p&gt;上面我们说 GitHub 是代码仓库，其实是不太严谨的，应该说它是一个代码托管平台，任何人都可以在上面创建自己的仓库，然后把代码放在上面。当然，GitHub 的功能肯定不仅限于此，它上面集成了很多很好用的功能，比如 Issues, Pull Requests, GitHub Actions 等，也提供了非常美观现代化的图形界面，能让大家直观地看到代码仓库的变更历史。它甚至提供了 GitHub Pages 来让开发者可以把静态的网页托管在上面，这让很多项目得以拥有自己的网页，或是用来做文档，或是用来宣传，功能非常多样。顺带一提，本博客就是托管在 GitHub Pages 服务上的。GitHub，伟大无需多言。&lt;/p&gt;
&lt;p&gt;目前 GitHub 上已经有了 &lt;a class="link" href="https://gitcharts.com/" target="_blank" rel="noopener"
&gt;2亿6千万以上（268 million+）的公开仓库了&lt;/a&gt;，仓库来源于全世界各地，且每天都有大量的信件仓库，大量的拉取请求，以及大量的代码提交。大家在 GitHub 上的活动已经远不止简单的提交自己的代码这么简单，开发者们会在一个项目内合作开发，设定开发目标，合并他人的拉取请求，为感兴趣的项目做贡献或者提出问题，帮助他人解答问题等等。其仓库类型也是多种多样，有各种语言写成的千奇百怪的项目，也有一些很不错的资源整合项目，甚至你还会看到很多令人难绷的小作文以及互联网记忆。总之，除了托管自己的代码之外，你还可以看看别人的代码，玩玩别人的项目，和别的开发者讨论（&lt;del&gt;吵架&lt;/del&gt;），给别的项目做贡献（&lt;del&gt;改错别字&lt;/del&gt;）。用途多种多样，就看怎么用了。&lt;/p&gt;
&lt;p&gt;GitHub 起源于 2007 年，至今已经 18 年历史了。18年来，GitHub 变得越来越完善，功能越来越丰富。2018 年的时候微软收购了它，在那之后就成了微软的一个子公司，而 2019 年的时候 GitHub 宣布它支持个人创建任意多个私有仓库，将 GitHub 的受欢迎程度推上了一个新台阶。而就在前不久（2025年8月11日），其 CEO 宣布卸任，GitHub 被合并在微软的 Core AI 部门。我个人认为这应该算是坏消息，毕竟 GitHub 作为全世界最大的代码托管平台，几乎已经是 &lt;em&gt;开源精神&lt;/em&gt; 的代言人了。本来还是一个比较独立的子公司的 GitHub 现在被微软直接合并进一个部门内，怎么想都感觉其独立性要进一步下降了。是在令人感到可惜。但是就目前而言，GitHub 也依旧是同类产品中知名度最高的一个，甚至可以说是某种标准了。所以，还是先用着吧。如果 GitHub 哪一天真倒了的话，肯定还会出现新的继任者的。&lt;/p&gt;
&lt;h3 id="gitlab-强大的自动化以及自托管"&gt;GitLab: 强大的自动化以及自托管
&lt;/h3&gt;&lt;p&gt;除了 GitHub 以外，当然还有别的托管平台。其中另一个比较受欢迎的项目就是 GitLab，它除了托管到 GitLab 的服务器上以外，还支持在自己的服务器上自行搭建代码托管平台，其中也支持和 GitHub 类似的很多功能，比如查看源码，Issues, Merge Request（对应 GitHub 中的 Pull Request），CI/CD（持续集成/持续部署）等等。其中的 CI/CD 是 GitLab 最出众的特点，以速度快效率高而著称。而且由于它提供自托管（通过 GitLab Community Edition）的特性，对于那些需要较强独立性的，不希望受到 GitHub 控制的（理由嘛……我也不知道），或者就是某些公司希望保持私密性的项目，GitLab 是一个很不错的选择。有很多项目都是使用 GitLab 进行托管的，比如 KDE，Paraview 等。相较于 GitHub 而言，GitLab 的隐私性还是更强一些。然而坏消息是，GitLab 在 24 年的时候宣布不再直接为中国地区提供服务，转而由本地服务提供商 &lt;em&gt;极狐&lt;/em&gt; 提供。我也很难讲究竟应该用哪个……&lt;/p&gt;
&lt;p&gt;GitLab 的功能是非常全面的，如果你并不想要这么完善的功能，只是想在自己的服务器上搭一个轻量化的 Git 托管平台，你也可以选择 Gitea。它最大的特点就是轻量化了，拥有最基础的 Git 托管服务器所应该有的功能，不过随之而来的就是一些更复杂的功能可能没有，自动化相关的内容也许需要自己手动实现等等。&lt;/p&gt;
&lt;p&gt;讲了这么多，Git 到底应该怎么实现和远程服务器的交互呢？&lt;/p&gt;
&lt;h2 id="git-与远程的交互方式"&gt;Git 与远程的交互方式
&lt;/h2&gt;&lt;p&gt;下面我们就来介绍一下 Git 和远程进行交互时会用到的一些命令吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令正如它的名字，是用来管理和远程相关内容的一个子命令。而且，就像 &lt;code&gt;git branch&lt;/code&gt; 那样，如果你不带任何的参数，它会告诉你都有哪些远程是可用的。一般来讲，仓库会有一个名为 &lt;code&gt;origin&lt;/code&gt; 的远程库，它一般就是你在 GitHub 上托管的位置了。如果你想确认远程的具体信息的话，你可以用 &lt;code&gt;-v&lt;/code&gt; 或者 &lt;code&gt;--verbose&lt;/code&gt; 来让 Git 把该仓库的所有远程地址都告诉你。你也可以用 &lt;code&gt;show&lt;/code&gt; 子命令来让 Git 告诉你关于某个远程的详细信息，包括它会从哪里拉取代码，往哪里推送代码，当前分支和最新提交等等。&lt;/p&gt;
&lt;p&gt;而假如你的仓库还没有可用的远程，你可以使用 &lt;code&gt;add&lt;/code&gt; 子命令来让 Git 添加一个远程仓库作为你这个仓库的远程位置。比如说你在个人 GitHub 账号下有一个空仓库，地址是 &lt;code&gt;https://github.com/abc/test_repo&lt;/code&gt;，其中 &lt;code&gt;abc&lt;/code&gt; 是用户名而 &lt;code&gt;test_repo&lt;/code&gt; 则是仓库名，此时你就可以使用 &lt;code&gt;git remote add origin https://github.com/abc/test_repo.git&lt;/code&gt; 来把这个仓库作为远程仓库添加到当前仓库名下，并给它以 &lt;code&gt;origin&lt;/code&gt; 的名字。你当然也可以修改这个远程仓库的地址咯，使用 &lt;code&gt;set-url&lt;/code&gt; 即可，用法和 &lt;code&gt;add&lt;/code&gt; 差不多，只不过远程名必须是已经有了的远程名字。&lt;/p&gt;
&lt;p&gt;假如你感觉某个远程仓库名让你很不爽，你可以使用 &lt;code&gt;rename &amp;lt;old-name&amp;gt; &amp;lt;new-name&amp;gt;&lt;/code&gt; 来修改它；如果这个远程已经不需要了，或者你因为什么其他的原因要删除它，也很简单，使用 &lt;code&gt;remove &amp;lt;remote-name&amp;gt;&lt;/code&gt; 子命令就可以啦。还是比较简单易懂的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;除了给现有的仓库添加远程，我们当然还可以从远程仓库复制一份到本地来呀。通过使用 &lt;code&gt;git clone &amp;lt;repo-url&amp;gt;&lt;/code&gt; 命令就可以把一个远程仓库下载到本地。下载下来的仓库会默认放在当前文件夹下的和仓库名同名的文件夹里，且仓库名默认会是和远程仓库的名字一样的，且由于是从远程克隆下来的，它会自动设置好远程的位置（起名也是默认的 &lt;code&gt;origin&lt;/code&gt;）。当然如果你想把该仓库下载到其他位置的话，也可以在仓库的 URL 后面添加上你要下载到的文件夹。&lt;/p&gt;
&lt;p&gt;一般来讲，使用这个命令就已经足够了。然而有时候，也许你会遇到仓库里使用了 Git Submodules（Git 子模块）的情况。我们这里不打算介绍 Git 子模块，然而如果你在克隆一个带有子模块的项目时没有顺带让仓库克隆其内部的子模块，后面在使用过程中又得重新搞一些有的没的。为了避免这样的麻烦，在克隆时可以直接带上 &lt;code&gt;--recursive&lt;/code&gt; 的参数，告诉 Git “帮我把这个仓库里所有的 Git 子模块也一并下载下来”。这样就省去了后面重新配置 Git 子模块的麻烦。&lt;/p&gt;
&lt;p&gt;另外也许有时候你克隆一个仓库的目的并不是在仓库里做开发，而是直接使用它（像一些 ZSH 插件是托管在 GitHub 上的），此时你也许不关心它的提交历史，或者这个仓库太大了而你又不需要用上过去的所有提交历史的时候，你会希望只获取到最新的几个提交就够了。Git 非常贴心地提供了 &lt;code&gt;--depth &amp;lt;number&amp;gt;&lt;/code&gt; 的参数，你可以指定你只想克隆到最近的多少个提交即可。这样能非常好地节约克隆的时间，对磁盘和网络都比较友好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当我们本地做出一些修改，有了一些和远程不一样的提交之后，我们就可以把本地的提交推送到远程仓库了。当我们直接使用这个命令的时候，Git 会默认推送当前分支到远程仓库的对应分支上。默认的操作就是最高频的操作了，这一点很不错。而当我们需要推送到某个特定分支（比如远程分支和当前分支名称不一样的时候），我们可以先写上远程分支的名字，再写上当前分支的名字：&lt;code&gt;git push &amp;lt;remote-branch&amp;gt; &amp;lt;local-branch&amp;gt;&lt;/code&gt;。我们也可以通过加上参数 &lt;code&gt;-u&lt;/code&gt; 或者 &lt;code&gt;--set-upstream&lt;/code&gt; 来修改推送的默认分支。&lt;/p&gt;
&lt;p&gt;也许我们的仓库拥有不止一个远程，这时候我们可能需要指定我们要推送的是哪个分支。这时候 &lt;code&gt;push&lt;/code&gt; 的写法会有一定的变化：&lt;code&gt;git push &amp;lt;remote-name&amp;gt; &amp;lt;local-branch&amp;gt;:&amp;lt;remote-branch&amp;gt;&lt;/code&gt;，即我们要先指定推送到哪个远程上，然后用冒号分割本地分支和远程分支。&lt;/p&gt;
&lt;p&gt;这个写法完全地指定了所有推送的信息，而且这个写法还有一个隐藏功能：如果我们不写本地分支，直接写 &lt;code&gt;git push &amp;lt;remote-name&amp;gt; :&amp;lt;remote-branch&amp;gt;&lt;/code&gt;，意思就是告诉 Git “我要把空分支推送到远程覆盖那个远程分支”，结果就是让 Git 删除远程分支。当然，删除远程分支也可以使用 &lt;code&gt;git push &amp;lt;remote-name&amp;gt; -d &amp;lt;remote-branch&amp;gt;&lt;/code&gt; （或者用 &lt;code&gt;--delete&lt;/code&gt;）来实现，这样的语义更加明确，不过我猜也是给上面的方法一个新的包装而已。也许我们远程的分支太多了，我们不想要远程的那些没有本地对应的分支，此时我们就可以使用 &lt;code&gt;git push --prune &amp;lt;remote-name&amp;gt;&lt;/code&gt; 来删掉（修剪）那些多出来的分支了。&lt;/p&gt;
&lt;p&gt;除了我们可以推送分支外，&lt;code&gt;push&lt;/code&gt; 还兼并了推送标签（Tag）的功能。我们可以直接使用 &lt;code&gt;git push --tags&lt;/code&gt; 来推送所有的标签，也可以 &lt;code&gt;git push &amp;lt;remote-name&amp;gt; tag &amp;lt;tag-name&amp;gt;&lt;/code&gt; 来推送某一个标签。至于标签是什么你可以认为它是一个独立于分支树之外的持久性的快照，会保存某一时刻的信息，且不会强依附于某个分支，一般是在发行时会给某个版本打上一个标签，没错，就是那个 xx.xx.xx，一般标签都会这么打。我们这里就不过多介绍了。&lt;/p&gt;
&lt;p&gt;最后在这里要留一个提醒。有很多教程推荐在 &lt;code&gt;push&lt;/code&gt; 出问题的时候使用 &lt;code&gt;-f&lt;/code&gt; 或者 &lt;code&gt;--force&lt;/code&gt; 参数。这个参数的功能是让 Git 不做任何的检查，用本地的状态去强行覆盖远程仓库的状态。如果你真的是在和别人一起协作的话，不要这么做。会被人移交蔡司。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令是用来让我们从远程获取更新使用的。它默认会获取默认远程的所有分支的最新更新，如果我们要指定是从哪个远程获取，只需要把那个远程的名称放在后面即可。如果我们想从所有的远程都拉取更新，则可以使用 &lt;code&gt;--all&lt;/code&gt; 来告诉 Git。类似于 &lt;code&gt;git push&lt;/code&gt;，我们还可以在 &lt;code&gt;git fetch&lt;/code&gt; 的后面加上 &lt;code&gt;-t&lt;/code&gt; 或者 &lt;code&gt;--tags&lt;/code&gt; 来让它从远程获取所有的标签信息，或者用 &lt;code&gt;git fetch --prune&lt;/code&gt; 或 &lt;code&gt;git fetch -p&lt;/code&gt; 来让 Git 删除掉本地多出来的，远程没有的分支。&lt;/p&gt;
&lt;p&gt;需要注意的是，Git 在设计上让 &lt;code&gt;fetch&lt;/code&gt; 子命令不直接把远程的内容和本地进行合并。也就是说，&lt;code&gt;git fetch&lt;/code&gt; 只会更新 &lt;em&gt;本地的远程数据库&lt;/em&gt;，而不会把远程的数据直接放在本地的工作目录里。如果想要这么做的话，我们可以把远程的分支 通过 &lt;code&gt;git merge&lt;/code&gt; 来 &lt;em&gt;合并&lt;/em&gt; 到本地上。要指定远程分支，我们需要用 &lt;code&gt;&amp;lt;remote-name&amp;gt;/&amp;lt;remote-branch&amp;gt;&lt;/code&gt; 来告诉 Git 我们要的是在 &lt;code&gt;&amp;lt;remote-name&amp;gt;&lt;/code&gt; 上的 &lt;code&gt;&amp;lt;remote-branch&amp;gt;&lt;/code&gt; 分支。&lt;/p&gt;
&lt;p&gt;如果你感觉这实在是太麻烦了（真的很麻烦），我们可以使用下面这个融合了 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; 的命令：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当我们很明确地是要把远程的变更直接应用到本地仓库时，我们可以直接 &lt;code&gt;git pull&lt;/code&gt; 来拉取远程更新。由于它涉及 “合并” 的步骤，所以它的默认行为是把默认远程的变更获取到本地后把当前分支对应的远程变更应用到本分支上。也就是说，默认行为是从远程更新当前分支状态。&lt;/p&gt;
&lt;p&gt;自然，我们可以指定它的更新对象。我们使用 &lt;code&gt;git pull &amp;lt;remote-name&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 就可以指定要拉取的远程是哪个，并且指定要更新的分支是谁。需要注意的是，新仓库里执行 &lt;code&gt;git pull&lt;/code&gt; 时它可能并不知道要使用什么方式把远程的变更应用到本地分支，因为除了可以使用 &lt;code&gt;merge&lt;/code&gt; 外，还可以用变基操作 &lt;code&gt;rebase&lt;/code&gt; 来做这件事。因此可能 Git 会询问你，是要使用哪种方法。一般我们直接用 &lt;code&gt;fast-forward&lt;/code&gt; 就可以了，最简单方便的方式，且不会让 Git 提交历史出现一大坨自己都不认识的分支。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git 的远程命令我们就介绍这么多。实际上在单人开发时，几乎不会用到这么复杂的命令。平时就是简单的 &lt;code&gt;git pull&lt;/code&gt; 更新一下，然后做好变更之后就 &lt;code&gt;git push&lt;/code&gt; 上去，就可以了。新仓库可能得用 &lt;code&gt;remote&lt;/code&gt; 来添加一个远程仓库，平时都不怎么用管的。&lt;/p&gt;
&lt;h2 id="和别人协作时要注意些什么"&gt;和别人协作时要注意些什么
&lt;/h2&gt;&lt;p&gt;然而，和他人共同协作时，并不是只要知道这些命令就 OK 了，光是知道这些命令并不能帮你成为开源领域大神，不慎的操作很有可能换来别人的嘲讽…… 下面就简单提个几点吧~&lt;/p&gt;
&lt;p&gt;另外，我其实也没有参与很多开源项目，如果你觉得我下面的建议不够权威，那确实是不好意思，实力不够（）不过我个人认为还算实用/中肯吧。总之希望能帮到你。&lt;/p&gt;
&lt;h3 id="阅读项目说明"&gt;阅读项目说明
&lt;/h3&gt;&lt;p&gt;参与到项目前首先应该尝试阅读这个项目的说明。如果你对某个项目感兴趣的话，相信 README 应该是已经看过了。然而如果要参与开发，光是读 README 很有可能不够。大型项目一般有所谓的 Code of Conduct，也就是所谓的行为准则。如果有这么个东西或者类似的要求的话，请阅读这些内容后再开始尝试给这个项目做贡献，不然项目的代码审核很有可能会直接拒绝你的 PR （Pull Request）。&lt;/p&gt;
&lt;h3 id="先查查-issues"&gt;先查查 Issues
&lt;/h3&gt;&lt;p&gt;协作开发一般是以某个 Issues 开始的，毕竟有了这样的问题，就有了针对这个问题进行开发的目标了嘛。查看 Issues 的主要目的是看看当前项目有哪些问题等待改善，另外也是看看有没有人已经尝试解决某个问题了。如果你感兴趣的问题已经有人在跟进了，这时候最好和跟进的人商量一下看看有没有什么可以帮忙的。不要稀里糊涂地直接提交一个 PR 上去。&lt;/p&gt;
&lt;h3 id="也许你需要单开一个-issue"&gt;也许你需要单开一个 Issue
&lt;/h3&gt;&lt;p&gt;有些项目会要求说，如果你想提交 PR，请给这个 PR 一个对应的 Issue，或者开启一个 Issue。这是一个不错的实践方式，让每个 PR 都有明确的目的性。之前我提交的 PR 就有被要求过开一个 Issue，并在 PR 里写明对应是要解决哪个 Issue。坏消息是我的 PR 好像没有通过自动检查…… 明明是一个很简单的 PR 的说……&lt;/p&gt;
&lt;h3 id="等下pr-到底是啥"&gt;等下，PR 到底是啥？
&lt;/h3&gt;&lt;p&gt;也许你早就想问这个问题了。我也是，经常听到别人说什么 “欢迎 PR”，“提个 PR”，“合并 PR” 之类的话，但是一直不清楚这到底是什么意思。我故意保留了这个风味，直到现在才解释，这样你才知道开发这块儿有多少谜语人 &lt;del&gt;（bushi，补药打死窝呜呜呜）&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;PR 的全称是 Pull Request，也就是所谓的拉取请求。什么？拉取请求？我在请求什么东西？拉取？我一开始也想不通我要请求什么拉取，后来借助 AI 的伟力以及一些别的资料，我终于明白了：Pull Request 就是请别人审阅你提交的代码然后把它合并进项目里。所谓的 “提 PR” 就是发起合并请求罢了。&lt;/p&gt;
&lt;p&gt;那么，既然 PR 是合并请求，为什么不是 &lt;em&gt;Merge Request&lt;/em&gt; 呢？没错，GitLab 就是这么干的。GitLab 里你不提 &lt;em&gt;PR&lt;/em&gt; 而是提 &lt;em&gt;MR&lt;/em&gt;。两个名词指代的是同一个操作。那么 PR 的 P 究竟是为什么呢？根据一些信源的解释，PR 的 Pull 的意思是说，你想让别人把你的修改 Pull 到他们那里。就好比说，我给项目搞了个很牛的特性，但是现在只在我自己的电脑里。我希望别人也能用上我写的这个特性，所以我要写个说明文字来介绍我这个修改都干了些啥，为什么牛逼，以及为什么推荐他们都把你的这份变更 pull 到他们那里。相比起来，&lt;em&gt;Merge Request&lt;/em&gt; 就很直白了：我做了有一份更改，现在请你把这份更改合并到你们的分支里。&lt;/p&gt;
&lt;p&gt;从语气上来讲，PR 显然更客气一些。我在知道这个解释之后第一反应是，PR 想表达的是，如果你觉得我的变更很棒，你就可以把我的这份放到你那里。如果你觉得我的修改不好，你不 pull 就是了。而 MR 的话，相比之下就略显强硬了：你能不能把我的更改合并到你那里。也有可能是我神经过敏吧，反正在知道 PR 的词源之后，反而更喜欢这个名字了，感觉 MR 反而有点奇怪，哈哈。&lt;/p&gt;
&lt;p&gt;不过你也应该明白了，在提交 PR 时应该给你想提交的变更做出一些说明，比如你改的东西的简要总结，为什么要改，改了之后会怎么样之类的。如果只是光秃秃地要求把代码合并进去，代码审核者估计也懒得细看你的代码究竟都干了些啥，进而选择不管你的提交。&lt;/p&gt;
&lt;h3 id="为什么不直接把变更推送进仓库"&gt;为什么不直接把变更推送进仓库？
&lt;/h3&gt;&lt;p&gt;一般而言，仓库都是有所有权的，即便它是公开仓库，它也不是允许所有人都直接向仓库里提交代码的，一般只有直接维护者有权利变更仓库内的内容。如果一个外来者希望修改仓库内容，基本都是通过 PR 的方式来把代码变更交给审核者，让审核者决定要不要合并进仓库里。当然，如果你就是仓库拥有者或者拥有仓库的编辑权限，那你也许是被允许直接提交代码的。然而，如果你是在和好几个人一起合作的话，最好还是有个 PR 的过程，毕竟 PR 提供了一个交流讨论的地方，直接提交代码的话也很难说这个提交就一定是最合适的。&lt;/p&gt;
&lt;h3 id="注重交流合作语气这一块儿"&gt;注重交流合作，语气这一块儿
&lt;/h3&gt;&lt;p&gt;可以发现，在 GitHub 上合作开发肯定是避免不了和别人交流沟通的。作为国际化的平台，一般而言还是推荐用英语交流，除非是一眼国人项目/国人特供项目/没有外国人用的项目，比如某些国内特产（科学上网），近乎是用不上英文的。如果您的英文不是很好，emmm，我想说现在的翻译软件都很好用，也不一定非得只能把英文翻译成中文，也可以把中文翻译成英文嘛。&lt;/p&gt;
&lt;p&gt;另外就是注意礼貌这块儿（）没人会喜欢和一个没素质的人合作的，一般而言。不过呢，有时候也不是说没礼貌吧，可能就是单纯的就事论事而已。记得之前看过的 &lt;em&gt;黑客的自白&lt;/em&gt; 里说过，很多人其实单纯地就是懒得用那些套话，喜欢只针对问题做出提问，并解决问题。这一点我的建议是自行把握吧，我本人持 “礼多人不怪” 的态度，不过如果有人不喜欢这套，那我也无所谓，只要别骂人就行。&lt;/p&gt;
&lt;h3 id="别在-issue-里面灌水"&gt;别在 Issue 里面灌水
&lt;/h3&gt;&lt;p&gt;很明显的一点。GitHub Issue 提供的本来是一个关于问题的讨论平台，不宜在里面灌水聊天，搞一些跑题。然而这点好像在某些仓库里没有很重要？毕竟当大家发现跑题了的时候，一般也不是刚刚才开始跑题吧。&lt;/p&gt;
&lt;p&gt;目前就只想到这几点了。如果你有别的觉得可以补充的，欢迎告诉我。我会补在里面的！真的！&lt;/p&gt;
&lt;h2 id="后记"&gt;后记
&lt;/h2&gt;&lt;p&gt;说实在的，写这篇的时候有点江郎才尽了。因为我本来也是正在学习 Git 的来着，写这些东西有一部分理由是为了复习巩固/趁机学习 Git 命令的。因此，如果里面有什么内容上的纰漏，还望海涵。&lt;/p&gt;
&lt;p&gt;也许有人会问，现在 Git 的 GUI 客户端已经这么多了，为什么还要学习 Git 的命令行操作？你说得很对：Git 现在有很多 GUI，甚至它本身已经带了一个 GUI 来着。但是，我还是觉得命令行最贴近 Git 在设计之初的使用方式。另外得益于 Git 命令行交互功能非常完善，有时候我们可以写一个简单的脚本来自动化 Git 的一些工作。而这些，GUI 是没法替我们办到的。然而不可否认的是，GUI 真的很不错。至少，Git 的分支状态在命令行下还是不够直观的，这一点必须承认。而有了 GUI 的 Git 它们的分支图一般都画的很漂亮。实不相瞒，有时候我也会直接用 VS Code 的 Git 集成来进行提交。因为很方便嘛，哈哈哈。&lt;/p&gt;
&lt;p&gt;还有人问，现在好用的 VCS（版本控制系统）也早已经不止 Git 一个了，为什么不介绍更新的工具，而是这个老套到甚至有点老掉牙的，对用户并不是非常友好的 Git 呢？我的回答是，它第一没有那么不堪，第二实际上它也许已经成为了某种事实标准，第三它真的很好用。再加上几乎所有的 VCS 都会提供从 Git 仓库转换到其他格式的仓库的功能，这更说明了 Git 在版本控制系统这个领域的重要地位。如果您会使用 Git 的话，相信其他的 VCS 系统也不会难到您。当然，我也很愿意尝试一下别的工具，比如最近风头正盛的，使用 Rust 编写的 Jujutsu。不过这也是后话了。（Git 真的很好用了）&lt;/p&gt;
&lt;p&gt;这篇都快写完的时候我才意识到，我还没有介绍 Git 怎么查看提交历史。感觉放在这一篇里还是有点尴尬，毕竟这一篇主要还是在讲怎么和其他人协作，而 Git 的历史查看功能放在这里就不太合适了。思来想去，我放在了上一篇里，因为它和分支还是有很大的关系的。如果你看过了上一篇，结果又没有收到上一篇的更新的话，我建议你可以回去看看（）&lt;/p&gt;
&lt;p&gt;另外，这个系列真的离不开一些工具，比如 &lt;code&gt;tldr&lt;/code&gt;（包名是 &lt;code&gt;tealdeer&lt;/code&gt;，不过其他版本的也很不错），以及 ChatGPT，DeepSeek 等 AI 工具的协助。当然 Git 自带的文档也很不错，在 Linux 上可以直接 &lt;code&gt;man git&lt;/code&gt; 查看总的介绍，使用 &lt;code&gt;man git-add&lt;/code&gt; 这样的格式来查看 Git 各个子命令（这里是 &lt;code&gt;add&lt;/code&gt;）的使用方式。而在 Windows 上，由于没有 &lt;code&gt;man&lt;/code&gt;，你可以使用 &lt;code&gt;git help git-add&lt;/code&gt; 或者更简单的 &lt;code&gt;git add --help&lt;/code&gt; 来查看在安装 Git 时就已经附赠的 Git 的文档。而且 Git 也有自己的 “官方教材”: &lt;a class="link" href="https://git-scm.com/book/id/v2" target="_blank" rel="noopener"
&gt;&lt;em&gt;ProGit&lt;/em&gt;&lt;/a&gt;，它有多种语言的版本，作为教程而言自然是比 Git 的文档写的好懂的多。不过 Git 的文档写的也很不错就是了。&lt;/p&gt;
&lt;p&gt;最后，非常感谢您能看到这里。如果你看完了这三篇的话，我更是感激不尽。如果这些文字能帮到你那就太好了，如果没有起太大帮助的话，希望能逗你一笑。哎呀至少笑一下吧，显得这个系列的文章也不是一无是处嘛。&lt;del&gt;（之前写的那个 &lt;a class="link" href="https://a-moment096.github.io/content/posts/Math_Note/Snake_Lemma/index.md" &gt;关于蛇引理的文章&lt;/a&gt; 里也说如果能博读者一笑就好了，结果发现，根本没几个人看呀可恶…… 更别说逗大家笑了，唉，实在是太失败了。）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;那么，一如既往地，祝您身心愉快，工作顺利，少出 Bug ~！&lt;/p&gt;</description></item><item><title>（也许是）一个 Git 教程？其二</title><link>https://a-moment096.github.io/posts/2025/08/git_2/</link><pubDate>Thu, 14 Aug 2025 16:49:16 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/08/git_2/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post （也许是）一个 Git 教程？其二" /&gt;&lt;p&gt;&lt;em&gt;上一节已经介绍了平时会怎么用 Git 进行单分支仓库的管理，这一节就来讲讲 Git 要怎么进行多分支协作吧！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图信息请参考上一节内容，谢谢~&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=785695" theme="#2980b9" loop="never"&gt;&lt;/meting-js&gt;
&lt;h2 id="分支是那个分支吗"&gt;分支，是那个分支吗？
&lt;/h2&gt;&lt;p&gt;我们上一节已经了解过 Git 在单分支下的日常工作流了。值得注意的是，我们说的是 “单分支”，那么自然，Git 是支持，同时鼓励使用多分支的。那么分支是什么呢？&lt;/p&gt;
&lt;p&gt;也许有过 Galgame 经验，或者玩过有分支剧情游戏的你已经想到所谓的 “分支” 是什么东西了。没错，很像这么回事儿，不过功能更丰富一些，因为你不止是体验若干个分支的剧情，Git 甚至可以允许你在没有冲突的前提下合并两个分支！如果有一款游戏支持用 Git 来操控分支的话，也许就可以手动后宫了……&lt;/p&gt;
&lt;p&gt;咳咳，不开玩笑了。我们来看看分支具体是什么样的。先来个分支图：&lt;/p&gt;
&lt;h3 id="一个也许简单的-git-分支示意图"&gt;一个也许简单的 Git 分支示意图
&lt;/h3&gt;&lt;figure class="mermaid-container"&gt;
&lt;div class="mermaid"&gt;gitGraph
commit id: "initial commit"
commit
branch feature1
checkout feature1
commit id: "new feat1, first commit"
commit
checkout main
merge feature1 id: "merge feature1"
branch feature2
checkout feature2
commit id: "new feat2"
checkout main
commit
merge feature2 id: "finish, merge feat2"
&lt;/div&gt;
&lt;figcaption&gt;Git 分支示意图&lt;/figcaption&gt;
&lt;/figure&gt;&lt;p&gt;（嘶，mermaid 竟然直接有 gitGraph 的功能，NB）&lt;/p&gt;
&lt;p&gt;那么可以看到，我们这里有三条分支：一条 &lt;code&gt;main&lt;/code&gt;， 一条 &lt;code&gt;feature1&lt;/code&gt; 以及一条 &lt;code&gt;feature2&lt;/code&gt;。有时我们开启了一个分支，有时我们又将两个分支进行了合并。上面的图是怎么生成的呢（双关意）？下面是用到的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;gitGraph
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt; commit id: &amp;#34;initial commit&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; commit
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; branch feature1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; checkout feature1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; commit id: &amp;#34;new feat1, first commit&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; commit
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; checkout main
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; merge feature1 id: &amp;#34;merge feature1&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; branch feature2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; checkout feature2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; commit id: &amp;#34;new feat2&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; checkout main
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; commit
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; merge feature2 id: &amp;#34;finish, merge feat2&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mermaid 的 gitGraph 很有趣的地方在于，上面的代码几乎就是为了实现这样的提交树/分支形状所需要的 Git 命令。我们可以不管 &lt;code&gt;id&lt;/code&gt; 后面的部分，因为这些在实际 &lt;code&gt;commit&lt;/code&gt; 的时候应该是用 &lt;code&gt;-m&lt;/code&gt; 来指定的提交信息才对。&lt;/p&gt;
&lt;p&gt;那么，这些命令都干嘛了？要怎么用命令来操控分支？&lt;/p&gt;
&lt;h2 id="和分支相关的命令们"&gt;和分支相关的命令们
&lt;/h2&gt;&lt;p&gt;下面来讲讲上面出现的（和没出现的一些）命令吧~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git checkout&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说实在的，这个命令真的是个很大的坑。&lt;code&gt;git checkout&lt;/code&gt; 从 Git 诞生之初就已经存在，它是集创建、管理、变更分支或提交等功能为一体的一个命令。造成这个情况的主要原因在于 &lt;code&gt;git checkout&lt;/code&gt; 实际上不是在我们现有的对 Git 存储模型的理解上进行操作，而是在 Git 更贴近实现层面的操作，即移动 “指针”。&lt;/p&gt;
&lt;p&gt;然而，我们这里先不打算介绍这么深入/详细。我们还是从实用角度来聊聊这个命令。观察上面的 Mermaid 图，我们可以看到，好像 &lt;code&gt;git checkout&lt;/code&gt; 的功能没有直接体现在图上。然而仔细观察的话可以猜到，&lt;code&gt;git checkout&lt;/code&gt; 在这里的作用是更换分支。比如，&lt;code&gt;git checkout main&lt;/code&gt; 就是告诉 Git “现在我要切换分支到 main 分支上”。这是 &lt;code&gt;git checkout&lt;/code&gt; 的主要用途之一。另外我们还可以用 &lt;code&gt;git checkout -&lt;/code&gt; 来像 &lt;code&gt;cd -&lt;/code&gt; 一样切换到上一个分支。&lt;/p&gt;
&lt;p&gt;我们还可以对这个命令多讲一些。如果给它带上 &lt;code&gt;-b&lt;/code&gt; 的参数则可以用来创建一个新分支。比如 &lt;code&gt;git checkout -b new-branch&lt;/code&gt; 就可以创建一个新的名为 &lt;code&gt;new-branch&lt;/code&gt; 的分支，同时你还会直接切换到该分支上。而如果你在后面带的参数是某个文件或者单纯的 &lt;code&gt;.&lt;/code&gt;，则是要让 Git 该文件/所有文件里没有暂存的更改。&lt;/p&gt;
&lt;p&gt;上面说的都是比较老派的做法。相信你也一定从上面的 Mermaid 图中猜到了新式的创建新分支的方法，那就是：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令是用来管控和单个分支相关的操作的。我们简要介绍一下。&lt;/p&gt;
&lt;p&gt;如果后面不带任何的参数，则是会打印出可用分支。如果要创建一个新的分支，就可以用 &lt;code&gt;git branch &amp;lt;another-branch&amp;gt;&lt;/code&gt;, 就是让 Git 尝试创建一个名为 &lt;code&gt;&amp;lt;another-branch&amp;gt;&lt;/code&gt; 的分支。当这个分支已经存在的时候，Git 就会报错，告诉你已经有了叫这个名字的分支了。&lt;/p&gt;
&lt;p&gt;要注意的是，&lt;code&gt;git branch &amp;lt;branch-name&amp;gt;&lt;/code&gt; 只会创建分支，并不会把当前分支更改到这个新分支上。要想在创建分支后切换分支，除了传统方式 &lt;code&gt;git checkout&lt;/code&gt; 外，还可以使用更现代（？）的命令：&lt;code&gt;git switch -c &amp;lt;branch-name&amp;gt;&lt;/code&gt;。我们后面会介绍到。&lt;/p&gt;
&lt;p&gt;除了创建分支以外，我们肯定还希望能实现查看/删除/重命名分支。我们干脆都列在下面吧。如果不想看可以跳过这一段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要查看分支，可以直接 &lt;code&gt;git branch&lt;/code&gt;。如果要看所有的分支（包括远程的），可以使用 &lt;code&gt;git branch -a&lt;/code&gt; 来查看。你还可以使用 &lt;code&gt;-v&lt;/code&gt; 来输出上次提交的信息。&lt;/li&gt;
&lt;li&gt;要创建分支，就像上面说的，在后面补上你要的分支名称，即 &lt;code&gt;git branch &amp;lt;branch-name&amp;gt;&lt;/code&gt;。如果这个分支已经存在则会报错，另外这个命令只会创建，并不会切换过去。&lt;/li&gt;
&lt;li&gt;如若要从某个提交上创建分支，还可以在 &lt;code&gt;&amp;lt;branch-name&amp;gt;&lt;/code&gt; 后面添加上 &lt;code&gt;&amp;lt;commit-hash&amp;gt;&lt;/code&gt;。至于 &lt;code&gt;&amp;lt;commit-hash&amp;gt;&lt;/code&gt; 是什么，我们在后面关于 Git 的一些概念里进行介绍。&lt;/li&gt;
&lt;li&gt;想要删除分支，可以用 &lt;code&gt;git branch -d &amp;lt;branch-name&amp;gt;&lt;/code&gt; 来删掉它。要是你要删除当前分支，请先切换到别的分支哦。&lt;/li&gt;
&lt;li&gt;要是打算重命名分支，可以考虑像操作文件一样 &lt;em&gt;移动&lt;/em&gt; 它：&lt;code&gt;git branch -m &amp;lt;branch-name&amp;gt; &amp;lt;new-name&amp;gt;&lt;/code&gt;。依旧，这个命令也只能更改别的分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, that&amp;rsquo;s it! Git 针对单分支的操作都可以用 &lt;code&gt;branch&lt;/code&gt; 子命令来做到。那么，我们要怎么切换分支呢？除了 &lt;code&gt;checkout&lt;/code&gt; 以外，“比较现代”（存疑）的方法是使用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git switch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令是相对较新的用来切换分支的命令。可以通过 &lt;code&gt;git switch &amp;lt;branch-name&amp;gt;&lt;/code&gt; 来简单地实现切换。有趣的是，我们还可以用 &lt;code&gt;git switch -c &amp;lt;branch-name&amp;gt;&lt;/code&gt; 来创建新分支的同时切换过去。也就是说，&lt;code&gt;git switch -c&lt;/code&gt; 命令和 &lt;code&gt;git checkout -b&lt;/code&gt; 几乎是等价的。另外我们可以使用 &lt;code&gt;git switch -&lt;/code&gt; 来直接跳回上一个分支。&lt;/p&gt;
&lt;p&gt;另外还可以考虑使用 &lt;code&gt;git switch -m &amp;lt;branch-name&amp;gt;&lt;/code&gt; 来在切换分支的同时把当前分支合并到要切换的分支上。这一点还是相当不错的，因为我们经常会遇到这样的情形：在 &lt;code&gt;dev&lt;/code&gt; 分支上完成某个特性之后，经过测试希望能合并到 &lt;code&gt;main&lt;/code&gt; 分支上。如果没有这条命令的话，我们可能需要先 &lt;code&gt;git checkout main&lt;/code&gt; 之后再 &lt;code&gt;git merge dev&lt;/code&gt;，而有了这条命令我们就可以简单地 &lt;code&gt;git switch -m main&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;总之，如果你需要切换分支，你就可以使用 &lt;code&gt;switch&lt;/code&gt; 这个命令。语义很明确，不是吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令，如它的名字一样，是用来合并分支的，或者，不那么明显地，&lt;em&gt;合并到当前分支&lt;/em&gt;。它的使用方式相对而言比较简单，就是单纯的 &lt;code&gt;git merge &amp;lt;branch-name&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个命令的主要问题是，合并过程中会出现恶魔般的 &lt;em&gt;冲突&lt;/em&gt;。解决冲突实在是一件令人头痛的事情（在我看来）。为了避免（逃避）合并冲突后的麻烦，你可以考虑 &lt;code&gt;--abort&lt;/code&gt; 参数来告诉 Git 如果合并失败就什么都别动。然而，要是你真想合并，到底还是要解决冲突的。&lt;/p&gt;
&lt;p&gt;其实解决冲突就是一个 “选择应用谁的代码” 的过程。Git 会在发生冲突的地方用箭头标出来本分支和被合并分支的内容，你要做的就是把你不要的那个部分删掉然后保存。另外，合并会创建一个新的提交。如果你不喜欢默认提交信息，可以考虑使用 &lt;code&gt;-e&lt;/code&gt; 参数来告诉 Git 你打算自己编辑合并产生的提交的提交信息。&lt;/p&gt;
&lt;p&gt;最后就是 Git 合并时有不同的策略。我们这里不多介绍，大部分情况可以使用 &lt;code&gt;ff&lt;/code&gt; 模式，即 &lt;em&gt;Fast Forward&lt;/em&gt; 模式。这个模式会让你的提交树看起来是一条直线，即如果历史提交相同的话就让两个分支有同样的提交了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令正如它名字所说的，会输出 Git 的分支记录。假如不跟任何的参数的话，它会简单地打印当前分支的提交记录们，信息包括提交的 SHA1 哈希结果，提交的作者/邮箱，提交日期，以及提交的信息。此时，Git 会进入自己的分页器方便你上下滚动浏览，支持 Vim 式的操作，比如 &lt;code&gt;jk&lt;/code&gt; 翻页，&lt;code&gt;/？&lt;/code&gt; 查询等等。自然，退出这个状态则需要按下 &lt;code&gt;q&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个命令当然没有这么枯燥。事实上，你可以自定义的部分特别多。例如，你可以使用 &lt;code&gt;--graph&lt;/code&gt; 来在每个提交的最左边显示分支图（虽然不是很好辨认），你还可以使用 &lt;code&gt;--all&lt;/code&gt; 来显示所有分支的历史记录。如果想让历史记录不要搞个好多行，而是只想看看每个提交的大概信息的话，你可以使用 &lt;code&gt;--oneline&lt;/code&gt; 来让每个提交都变成短短的一行。上面说的这三个参数你可以组合在一起，来快速浏览提交历史是什么样的。而如果你希望显示全面的信息，比如哪些文件发生了什么更改，你可以使用 &lt;code&gt;--stat&lt;/code&gt; ，这样 Git 就会有个统计信息，告诉你哪些文件发生了什么变化。&lt;/p&gt;
&lt;p&gt;你看到了提交的时间了吧？&lt;code&gt;git log --before &amp;lt;date&amp;gt; --after &amp;lt;date&amp;gt;&lt;/code&gt; 还可以让你选定只查看某个时间段内的提交！时间的格式则是 &lt;code&gt;yyyy-mm-dd&lt;/code&gt;，实在是非常方便的功能。&lt;/p&gt;
&lt;p&gt;然而这个命令最神奇的地方在于，你实际上可以自定义输出格式。使用 &lt;code&gt;--pretty&lt;/code&gt; 格式，你就可以用一些字段来控制 Git 日志的输出格式。这里有一个&lt;a class="link" href="https://devhints.io/git-log-format" target="_blank" rel="noopener"
&gt;参考表&lt;/a&gt;，感兴趣的话可以看看，试用一下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分支相关的基本命令我们就先介绍到这里吧。有了上面的介绍，相信你已经可以运用 Git 的分支功能了吧~&lt;/p&gt;
&lt;h2 id="git-的概念们"&gt;Git 的概念们
&lt;/h2&gt;&lt;p&gt;然而，止步于介绍使用 Git 的方式，总是觉得不够透彻。知其然还要知其所以然，我们既然是在介绍 Git，那就尝试把 Git 更深一些（其实也没那么深）的概念多介绍一些吧。&lt;/p&gt;
&lt;h3 id="仓库-repository"&gt;仓库 (Repository)
&lt;/h3&gt;&lt;p&gt;我们几乎所有的 Git 项目都是从建立或者克隆 Git 仓库开始的。仓库是一个比较大的概念，我们和 Git 相关的所有内容都是要从仓库出发的，所有的信息都会存储在仓库中。&lt;/p&gt;
&lt;p&gt;那么 “所有信息” 都有什么呢？这个问题会比较深，我们从表观的理解来讲，首先肯定得有我们工作内容息息相关的内容，毕竟 Git 就是用来管理它们的。另外就是和 Git 相关的内容了，大部分都存储在 &lt;code&gt;.git&lt;/code&gt; 文件夹中，还有一些零散的 &lt;code&gt;.gitignore&lt;/code&gt; 文件。其中 &lt;code&gt;.git&lt;/code&gt; 存储了这个仓库的所有和 Git 直接相关的内容，例如文件快照，提交记录，不同的分支记录等等，都会以特殊的结构记录下来。这也意味着，如果你删了 &lt;code&gt;.git&lt;/code&gt; 文件夹，那么这个仓库就没了，Git 的记录就全都消失啦。删除之前要好好想清楚咯~&lt;/p&gt;
&lt;p&gt;然后 &lt;code&gt;.gitignore&lt;/code&gt; 也是能控制 Git 行为的文件。它能够让 Git 不记录某些文件。比如说你有一些测试文件，它们其实不应该被记录在仓库里，只希望在本地有一份方便测试而已，那么就可以把他们的名字或者所在文件夹写进 &lt;code&gt;.gitignore&lt;/code&gt; 里。&lt;/p&gt;
&lt;p&gt;总之，Git 仓库就是这么个总的玩意儿了。有时我们会简称仓库英文为 &lt;em&gt;repo&lt;/em&gt;，我还挺喜欢这个名字。&lt;/p&gt;
&lt;h3 id="工作目录-working-directory--working-tree"&gt;工作目录 (Working directory / Working tree)
&lt;/h3&gt;&lt;p&gt;这实际上就是我们正在编辑的项目目录。比如说我们从网上克隆了一个仓库之后，我们会进入这个仓库的目录里。这个仓库的根目录就是所谓的工作目录了。至于为什么叫 “工作树”，我个人看法是因为 Git 分支的存在让整个仓库像树一样伸展开，或者是说目录下的文件层级结构像树一样吧。不过怎么想都觉得有点怪，毕竟如果是说仓库分支的话，我们应该是在树叶上而不是在树上吧……&lt;/p&gt;
&lt;p&gt;然而，不深究的话，我们干活儿的地方就是工作目录。就是这样。&lt;/p&gt;
&lt;h3 id="暂存区-staging-area"&gt;暂存区 （Staging Area）
&lt;/h3&gt;&lt;p&gt;其实我们应该已经介绍过暂存区了。就像它的名字一样，暂存区是用来暂时存下 “觉得改的差不多了” 的内容的地方。我们用 &lt;code&gt;git add&lt;/code&gt; 命令来把修改好的内容放在暂存区内等待提交。如果感觉暂存区的内容有不妥的地方，我们可以随时打回来重新修改。我们也可以把一些内容从暂存区撤下来。总之，暂存区给了我们再次考虑的机会。而假如我们认为 “暂存区的东西我很满意，可以提交了”，我们就可以用 &lt;code&gt;git commit&lt;/code&gt; 来提交 &lt;em&gt;暂存区&lt;/em&gt; 的内容到分支上（或者仓库，取决于你怎么看这个行为）。&lt;/p&gt;
&lt;p&gt;总之，暂存区就是一个介于 “保存文件” 和 “保存整个工作目录状态” 之间的一个地方。这也决定了 Git 的工作流是 &lt;code&gt;修改文件 -&amp;gt; 保存文件 -&amp;gt; 交给暂存区 -&amp;gt; 提交至分支/仓库&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="分支-branch"&gt;分支 (Branch)
&lt;/h3&gt;&lt;p&gt;相信你已经对分支有所了解了。我们在创建仓库的同时，会创建一个主分支，曾经主分支名称为 &lt;code&gt;master&lt;/code&gt;，后来因为一些政治原因，现在更多叫 &lt;code&gt;main&lt;/code&gt; 了。除了主分支外，我们还可以有很多别的分支。这些分支允许我们在仓库里存储不同的信息，不同分支间不会产生干扰，而在我们希望的时候我们又可以对分支们做出诸如合并、删除等的改动。&lt;/p&gt;
&lt;p&gt;分支就像平行世界一样，我们可以让两个分支拥有同样的过去，在某个地方发生变化，最后独立演化下去。而分支胜过平行世界的地方在于，我们可以在没有直接分歧的情况下把两个分支合并在一起，而不会出现 “我才是蜘蛛侠” 的问题。&lt;/p&gt;
&lt;p&gt;分支可以说是 Git 的灵魂和精髓了。推荐多运用分支进行项目管理，相当好用。遇事不决开个分支先测试一下，这不失为一个好办法。&lt;/p&gt;
&lt;h3 id="提交-commit"&gt;提交 (Commit)
&lt;/h3&gt;&lt;p&gt;我们有了一个分支之后我们就需要向这个分支不断做出提交了。每一次的提交都会让这个分支的记录变多一些，分支实际上也是记录的每一次的提交。大白话讲，提交就是存档，只不过这些存档要依附在某个世界线（分支）上而已。&lt;/p&gt;
&lt;p&gt;提交可以说是组成分支的部分。当我们查看分支具体有什么的时候，映入我们眼帘的就是每一次的提交记录。所谓的合并分支，也不过是比较两个分支之间的提交情况，如果没有冲突的提交就可以顺利合并了。&lt;/p&gt;
&lt;p&gt;要注意的是，在 Git 里我们不提交文件本身，我们提交的是文件的变更。也正是由于 &lt;strong&gt;变更&lt;/strong&gt; 这一关键特征，让 Git 可以高效地进行版本控制，不过坏处也有，那就是面对二进制文件就显得有点笨笨的了：二进制文件可以认为是一变全变的，不像文本那样可以有明显的局部改动。这也说明我们应该尽量让 Git 记录纯文本的文件而非二进制文件。&lt;/p&gt;
&lt;p&gt;另外，需要再提醒的是，提交只会提交暂存区内的内容。如果有改动发生但没有放在暂存区里的话，提交是不会搭理这些改动的。这一点还请注意。&lt;/p&gt;
&lt;h3 id="远程remote"&gt;远程（Remote）
&lt;/h3&gt;&lt;p&gt;虽然我们还没有介绍太多和远程仓库/托管平台的内容，但远程仓库确实是在 Git 设计之初就已经有了的关键概念了。&lt;/p&gt;
&lt;p&gt;我们介绍过，Git 一开始的设计目的是所谓 &lt;em&gt;分布式&lt;/em&gt; 版本管理系统。这个 &lt;em&gt;分布式&lt;/em&gt; 就在于每个人都可以拥有一份源代码，然后大家可以互相传递自己的修改，也可以自由选择是否进行合并别人的修改。这样去中心化的特点是相当超前的设计。而为了实现这样的设想，我们必须让 Git 拥有连接到别人仓库的能力。远程也正是这么个东西。&lt;/p&gt;
&lt;p&gt;Git 可以把网络上的仓库作为自己的远程库来使用。我们通常不直接和远程库中的文件交互，而是把提交作为基础单元和远程库进行交互。当我们有了新的提交或者新的分支时，我们就可以把本地的这些改动 &lt;em&gt;推送 (push)&lt;/em&gt; 到远程仓库；当远程仓库有了新的变动时，我们可以把新的变动 &lt;em&gt;拉取 (pull)&lt;/em&gt; 到本地来。我们会在下一节对 Git 的远程功能进行更详细的介绍。&lt;/p&gt;
&lt;p&gt;总之，Git 的远程仓库让一份代码可以被保存在多个位置，并且让我们和这些位置的仓库进行交互，这样就能让我们和别人进行协作了。然而，由于现实协作的众多需求，最终 Git 还是发展出了很多代码托管平台，来方便大家存储 Git 的远程库，并让大家在远程库上进行协作，避免直接塞给别人电脑上。&lt;/p&gt;
&lt;h2 id="后记"&gt;后记
&lt;/h2&gt;&lt;p&gt;我必须立刻承认我这篇文章离不开 &lt;code&gt;tldr&lt;/code&gt;，准确来说是 &lt;code&gt;tealdeer&lt;/code&gt; 的帮助。很难想象没有 &lt;code&gt;tldr&lt;/code&gt; 我要怎么介绍可用命令。唉，我还是对 Git 不够熟悉。如果里面有任何的错漏，又或是对这个系列有什么建议，请直接告诉我，谢谢，我会及时修改的（球球了，告诉我哪里写的不好吧，呜呜呜）。&lt;/p&gt;
&lt;p&gt;另外我还想推荐一个很不错的网站，&lt;a class="link" href="https://learngitbranching.js.org/" target="_blank" rel="noopener"
&gt;Learn Git Branching&lt;/a&gt;，一个让你在实际操作中练习 Git 分支管理的网页，从进行提交，创建分支，合并分支，到变基 (Rebase)，远程库协作等复杂操作，全都有涉猎。我花了一下午通关，收获很大，因此墙裂建议。&lt;/p&gt;
&lt;p&gt;下一节就是我们的最后一节内容，我打算聊聊 Git 的远程协作功能，以及协作时的注意事项等等。另外，由于深感 Git 命令之繁杂，我有计划做一个小工具来通过问答的方式给出合适的 Git 命令。我暂时将这个工具命名为 &lt;code&gt;Giao&lt;/code&gt;，希望不会难产吧，哈哈。有兴趣的话也可以关注我/给我提建议，谢谢啦。&lt;/p&gt;</description></item><item><title>（也许是）一个 Git 教程？其一</title><link>https://a-moment096.github.io/posts/2025/07/git_1/</link><pubDate>Mon, 28 Jul 2025 22:49:16 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/07/git_1/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post （也许是）一个 Git 教程？其一" /&gt;&lt;p&gt;&lt;em&gt;Git 真的很好用，但是 Git 的命令真的好复杂。简单整理一下，就当写个教程好了~&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图出自 &lt;a class="link" href="https://www.pixiv.net/en/users/75383094" target="_blank" rel="noopener"
&gt;夏空&lt;/a&gt; 太太所画的 &lt;a class="link" href="https://www.pixiv.net/en/artworks/116876998" target="_blank" rel="noopener"
&gt;多多良 小伞&lt;/a&gt;，可爱捏~ 那就来一曲小伞的个人曲吧&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=22636608" theme="#2980b9" loop="never"&gt;&lt;/meting-js&gt;
&lt;h2 id="git熟悉又陌生的名字-"&gt;Git，熟悉又陌生的名字 ……
&lt;/h2&gt;&lt;p&gt;也许是所处环境的原因，我身边有很多人不知道 Git 是什么。他们都听过 &lt;em&gt;GitHub&lt;/em&gt;，但很多却只知道上面有好多程序和程序员。虽然也没错，但是并不准确；而当我说我在用 &lt;em&gt;Git&lt;/em&gt; 的时候，会有人把 &lt;em&gt;Git&lt;/em&gt; 和 &lt;em&gt;GitHub&lt;/em&gt; 混为一谈；很多人觉得 Git 很复杂，顺带觉得 GitHub 也很复杂…… 为此，我想分享一下我对 Git 和 GitHub 的理解，聊聊 Git 和 GitHub 都是什么。&lt;/p&gt;
&lt;p&gt;所以，如果你不了解 Git 是什么，那我很荣幸能在这里向你简单介绍它。&lt;/p&gt;
&lt;h3 id="所以到底什么是-git版本控制啊"&gt;所以到底什么是 Git？版本控制？啊？
&lt;/h3&gt;&lt;p&gt;所谓的 Git，它就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;一款为程序开发的存档系统。&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是的，事实就是这样。游戏存档。卡关的时候/做支线的时候/后悔的时候可以进度回溯的游戏存档。如果你在翻阅 &lt;em&gt;ProGit&lt;/em&gt; 或者某些教程时不太明白什么是 &lt;em&gt;版本控制系统&lt;/em&gt;，没关系，就是游戏存档（程序用）的比较花哨的名字。&lt;/p&gt;
&lt;p&gt;不过，为了能高效地，更好地服务程序员，Git 自然有了一大票复杂的功能，且每个子功能还会做特别多的细分，另外对每个存档都可以有非常复杂 &lt;del&gt;（麻烦）&lt;/del&gt; 的，细致 &lt;del&gt;（啰嗦）&lt;/del&gt; 的控制。然而，这依旧不能让它摆脱它就是个存档系统的事实。&lt;/p&gt;
&lt;p&gt;一旦你接受了这个设定，那么 Git 就其实没有多少秘密了。&lt;/p&gt;
&lt;h3 id="ok但是听你说好像很麻烦"&gt;OK，但是听你说好像很麻烦……
&lt;/h3&gt;&lt;p&gt;不得不承认的是，正如上面所说的那样，Git 的命令实际上可以非常地复杂。如果你愿意翻阅它的 man-page，你会发现内容出奇地长；而当你尝试用 &lt;code&gt;git --help&lt;/code&gt; 来获取一些简单有效的信息的时候，很抱歉，&lt;code&gt;git --help&lt;/code&gt; 只会告诉你你能怎么做，并伴随着看不太懂的 usage，却不太会告诉你怎么做能做什么。&lt;/p&gt;
&lt;p&gt;然而，转折来了。首先，如果你受环境所限，只能从命令行操作 Git，待会儿介绍的四五个命令几乎就能覆盖 80% 的使用场景了。而如果你的环境支持你使用图形化的界面，那么如果不是命令行的忠实用户，完全可以挑个 GUI 程序，比如和 GitHub 集成度高的 &lt;em&gt;GitHub Desktop&lt;/em&gt;，界面美观现代，功能也已经足够丰富，没必要和自己过不去。&lt;/p&gt;
&lt;p&gt;所以，结论是：Git 很复杂，但是我们可以用的很简单呀。它很强大，很好，但这不影响我只需要那几个最基础的功能。最重要的是，当你需要更复杂的功能的时候，互联网永远是你的好朋友。你完全可以现场上网搜索，大概率会有来自 StackOverflow 的朋友向你答疑解惑（贴答案）（好几年前且点赞特别高的）。&lt;/p&gt;
&lt;p&gt;So, don&amp;rsquo;t be afraid! Just try it!&lt;/p&gt;
&lt;h3 id="行但是-git-和-github-到底是什么关系"&gt;行，但是 Git 和 GitHub 到底是什么关系？
&lt;/h3&gt;&lt;p&gt;这算是很常见的问题了。解释起来也很简单：GitHub 能提供云存档功能。就像 Steam 有游戏云存档一样，Git 也可以有个云存档。只不过，Steam 有个专门的服务器来帮你自动地存好你的游戏内容，而 Git 则可以允许你选择你喜欢的地方存你的代码存档。&lt;/p&gt;
&lt;p&gt;而 GitHub，正是那个大部分程序员都喜欢的选择。不仅如此，GitHub 上传的存档还兼具展示功能，大家可以在 GitHub 上给自己喜欢的代码存档投票，也可以把别人的存档下载到自己电脑上，甚至可以尝试和别人一起组排。所以，说是交友网站，也未尝不可（也许）&lt;/p&gt;
&lt;p&gt;那么我可以选择别的地方存放存档吗？当然可以！除了 GitHub，还有很多很多的 Git 服务提供商。你还可以 &lt;em&gt;自建 Git 服务&lt;/em&gt;！甚至，GitHub 显得有些 “&lt;em&gt;违背&lt;/em&gt;” Git 的初衷：分布式的存档存储。什么意思呢？Git 一开始是打算，让所有的代码开发者（玩家）都留一份存档，然后大家就可以一起攻略组排了。大家都保留一份源码，这不就相当于大家都做存储功能了吗？只不过随着合作要求的提高和开源社区的扩大，GitHub 这样一个公开自己代码的地方就这么自发地出现了。&lt;/p&gt;
&lt;p&gt;总而言之，Git 是存档工具，GitHub 是大家上传/分享/讨论/合作云存档的地方。&lt;/p&gt;
&lt;h3 id="好耶我逐渐理解一切"&gt;好耶，我逐渐理解一切！
&lt;/h3&gt;&lt;p&gt;是这样的，Git 就是做这么个事儿。也许你会看到一些介绍一开始会提 Git 使用的技术多么先进，多么高效，多么体现开源精神，然后不明所以。然而 Git 就是做这么个代码存档的东西，为了使用它以期了解它的话，大框架就是这样的。&lt;/p&gt;
&lt;p&gt;然而这里还是要提个醒：上面也许的确抓住了 Git 的核心目的，但是依旧是很粗糙的，非常概括性的。上面的文字只能帮助 &lt;em&gt;了解 Git 是什么&lt;/em&gt;，并不能告诉你 &lt;em&gt;Git 怎么做的&lt;/em&gt;。另外，使用 Git 的命令完成最基础的工作是很简单，但是在切实明白一条命令到底在做什么前，&lt;strong&gt;请最好不要盲目运行这条命令&lt;/strong&gt;。实际上，要想运用好 Git 管理你的代码/项目，还是需要了解一些关于 Git 究竟在背后怎么做的知识的。&lt;/p&gt;
&lt;p&gt;所以，如果你还对 Git 感兴趣，或者想把 Git 用起来的话，我们就来讲一些技术细节吧~&lt;/p&gt;
&lt;h2 id="要怎么用-git-存档"&gt;要怎么用 Git 存档？
&lt;/h2&gt;&lt;p&gt;想解答这个问题，我们不可避免地要接触一些没啥意思的概念。与其直接介绍它们，我们先来看看，日常开发会怎么使用 Git 吧。&lt;/p&gt;
&lt;h3 id="tig-的一天"&gt;Tig 的一天
&lt;/h3&gt;&lt;p&gt;Tig 是热爱 Minecraft 的忠实玩家。他很享受创造神的感觉，毕竟他就是被游戏名吸引而来的。今天他计划开展一个新的工作：制作一个百万刷铁机！&lt;/p&gt;
&lt;p&gt;Oh no! Tig 的 Minecraft 除了点奇怪的问题！他被告知，Minecraft 的图形界面已经坏了，取而代之的，他可以用代码来操控角色并任意创造游戏中的物品，且他只能用 &lt;code&gt;git&lt;/code&gt; 来做存档（究竟是谁干的，真坏呀）。Tig 感到心里五味杂陈：这还是 Minecraft 吗？然而他心中有一个信念：我一定要做好这个刷铁机，即便我能直接虚空点出来铁块！等游戏恢复的时候，就可以在这台刷铁机的基础上继续快乐玩耍啦！&lt;/p&gt;
&lt;p&gt;于是，Tig 用 &lt;code&gt;git init&lt;/code&gt; 创建了一个空世界的存档。然后就开始在存档里用代码一行行写他在这个世界里要做些什么……&lt;/p&gt;
&lt;p&gt;过了一会儿，Tig 妈妈喊他要他吃午饭了。虽然不愿意，Tig 还是要先放下手上的工作。他打算先暂时保存一下，于是使用 &lt;code&gt;git add .&lt;/code&gt; 来保存好自己手上的所有写好的代码。毕竟，他也不知道是不是有的地方有点问题，带会儿还要调一下，他现在也是被拉过去吃饭的。&lt;/p&gt;
&lt;p&gt;吃完饭后还睡了个午觉，Tig 回来又写了一会儿。他对自己的成果很满意，因为他已经想办法把村里的刁民挪到了高空中了。这实在是不太容易，他不希望待会儿犯蠢丢掉这几个村民。于是他决定要存档。他先用 &lt;code&gt;git add .&lt;/code&gt; 来保存所有文件的所有改动，然后用 &lt;code&gt;git status&lt;/code&gt; 查看了改动的文件们。感觉没什么问题，他使用 &lt;code&gt;git commit&lt;/code&gt; 来正式保存了这个存档。存档系统问他要他给自己的改动写个简述，他写了 &lt;code&gt;村民挪好了，准备搭框架&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;过了一个下午和一个晚上，Tig 终于在睡觉前把刷铁机搞好了！实在是一个无比伟大的创举，Tig 忍不住把它分享出去，也方便自己在其他电脑上继续工作。他创建了 GitHub 账号和一个仓库，并且用 &lt;code&gt;git push&lt;/code&gt; 把这个存档放在了它的仓库里。然而睡前他还是想先在另一台电脑上先把存档下下来，于是使用 &lt;code&gt;git clone &amp;lt;git-link&amp;gt;&lt;/code&gt; 来把仓库克隆到本地。&lt;/p&gt;
&lt;p&gt;晚上躺在床上，他一想到以后就可以把存档用 &lt;code&gt;git push&lt;/code&gt; 方便地推送到 GitHub 上，并且用 &lt;code&gt;git pull&lt;/code&gt; 在另一台电脑上来获取最新的改动了，他就不自觉地笑出声，心里盘算着怎么在明天做一些改善，给刷铁机套个好看的壳子之类的……&lt;/p&gt;
&lt;p&gt;可喜可贺，可喜可贺！~&lt;/p&gt;
&lt;h3 id="所以他都干了些啥"&gt;所以，他都干了些啥？
&lt;/h3&gt;&lt;p&gt;Tig 的故事貌似有点无聊，毕竟，给 Git 硬套个背景，貌似有点牵强；更重要的是，谁家好人这么玩 Minecraft 呀！然而他用到的命令，几乎就是我平时常用的所有命令了。我们来总结一下吧。我们就不再多提游戏的事，毕竟好像都戳穿了是在写代码……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以用 &lt;code&gt;git init&lt;/code&gt; 来在本地创建/初始化一个 Git 仓库。这代表着，你打算用 Git 来管理这个文件夹了。很简单的命令，其实频率也很低，因为你很少反复初始化一个仓库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个频率还挺高的命令。你在仓库内的修改，Git 都不会立马记录下来。他怕他立马记下来之后，随后用户又马上反悔。另外，这样立马就记录下来，反而和单纯的文件保存功能有所重叠了。&lt;/p&gt;
&lt;p&gt;所以，当你觉得目前的进展还不错，你就可以用这个命令来 &lt;em&gt;暂存&lt;/em&gt; 当前的所有修改。这里的 “暂存” 有两个意思：一是 Git 确实是把你的修改保存到了 &lt;em&gt;暂存区&lt;/em&gt; 里，另一个则是你要是现在发现有个修改不太对，可以很方便的从暂存区里撤下来。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt; 里的这个 &lt;code&gt;.&lt;/code&gt; 就是当前目录的意思，也就是说这个目录下的所有文件我都要暂存起来。Git 会很聪明地只保存修改，这也是设计之初就确定的。如果你只想保存一部分，那就写他们的名字吧，或者写对应的目录，都可以，能定位到就好。&lt;/p&gt;
&lt;p&gt;不过，总之，这个命令就是让你暂存当前所有修改的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个我很爱用的命令。可以向你报告当前暂存区的情况以及工作目录的情况。比如什么文件被修改了，哪些文件是新加的，谁被删除了，而这些改动里谁被暂存下来，又有哪些你没暂存下来。&lt;/p&gt;
&lt;p&gt;如果你的 Git 是默认配置，他还会提醒你可以怎么撤回某些修改。跟着做就好了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你对你的进度感到满意时，你就可以用 &lt;code&gt;git commit&lt;/code&gt; 来提交你暂存区的东西了。所谓的提交，就是形成一个存档，你后续可以回来的一个存档。这个存档里你的仓库的模样会被冻结下来，当你回到这个提交时，一切都会回到当初的模样。非常的美好。&lt;/p&gt;
&lt;p&gt;要注意的有两点，一是 &lt;code&gt;git commit&lt;/code&gt; 只提交 &lt;strong&gt;暂存区&lt;/strong&gt; 的内容。没被暂存的，还会在原地等待你先用 &lt;code&gt;git add&lt;/code&gt; 暂存起来，或者等你撤回那些修改。二是，&lt;code&gt;git commit&lt;/code&gt; 会要求你给这个提交留个注释。请不要省事瞎写个什么东西，因为未来的你可能会对瞎写注释的现在的你感到伤心。默认情况下，&lt;code&gt;git commit&lt;/code&gt; 会打开你的文本编辑器然后让你开写，而如果你觉得很麻烦不想开编辑器，可以用 &lt;code&gt;git commit -m &amp;quot;messages&amp;quot;&lt;/code&gt; 来把这行 &lt;code&gt;messages&lt;/code&gt; 作为提交注释。&lt;/p&gt;
&lt;p&gt;可以再补充两点：如果你提交过后发现因为小失误忘记暂存某些内容或者有些小改动的话，你可以在把改动加入暂存区后补充到这次提交里，用法则是 &lt;code&gt;git commit --amend&lt;/code&gt;。另外，提交要慎重，因为提交过的内容就不是那么好修改了。你当然能改，但是相比 &lt;code&gt;git add&lt;/code&gt; 到暂存区的内容而言，实在是要麻烦一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把你当前的内容推送到远程仓库里。如果你的仓库是用 &lt;code&gt;git clone&lt;/code&gt; 获得的且你拥有这个仓库的修改权限，那么 &lt;code&gt;git push&lt;/code&gt; 就可以简单直接地把 &lt;em&gt;这条分支&lt;/em&gt; 的修改推送到远程。&lt;/p&gt;
&lt;p&gt;我们这里还是先不讲什么分支，也先不谈远程协作之类的东西。不过就常用命令介绍来说，&lt;code&gt;git push&lt;/code&gt; 算是比较常用且同样很简单的一个命令了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把 git 仓库从远程下载到本地。后面跟上仓库的链接就好。如果你是从 GitHub 来克隆到本地的话，点绿色按钮的 Clone 就会看到你可以怎么做。你可以直接复制里面的命令然后执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把远程仓库的内容拉取到本地。和 &lt;code&gt;push&lt;/code&gt; 的方向是近乎相反的。如果远程有个修改，你希望同步到本地，那就 &lt;code&gt;git pull&lt;/code&gt; 一下吧。&lt;/p&gt;
&lt;p&gt;这个命令要注意的点是，不要在本地有修改没存的情况下执行 &lt;code&gt;git pull&lt;/code&gt;。如果本地和远程起了冲突，会很麻烦。避免麻烦的最好方式是，先 &lt;code&gt;git pull&lt;/code&gt; 之后再做自己的修改。&lt;/p&gt;
&lt;h3 id="画个流程图"&gt;画个流程图
&lt;/h3&gt;&lt;figure class="mermaid-container"&gt;
&lt;div class="mermaid"&gt;flowchart LR
A[开始] --&gt; B[git init\n创建新仓库]
A --&gt; C[git clone\n克隆已有仓库]
B --&gt; D[在仓库中做出变更]
C --&gt; D
D -- 暂时存下 --&gt; E[git add .\n暂存已有变更]
E -- 满意已暂存内容 --&gt; F[git commit\n提交所有暂存的变更]
F --&gt; G[git push\n上传至远程仓库]
G --&gt; H[其他设备: git pull\n从远程获取最新变更]
H --&gt; D
F --&gt; D
&lt;/div&gt;
&lt;figcaption&gt;Git 日常工作流&lt;/figcaption&gt;
&lt;/figure&gt;&lt;h2 id="好累先聊到这里吧"&gt;好累，先聊到这里吧
&lt;/h2&gt;&lt;p&gt;我们已经介绍了 Git 是什么以及日常会用到的功能。我可以说，除了剩下关于 Git 另一个非常强大的功能：分支的两三个命令，以及一两个我觉得好用的命令以外，剩下的命令都是我很不常用的命令了。剩下的命令几乎只有在我搞砸了什么东西的时候临时从网上搜来救火用的，而保持良好的使用习惯的话真的是很少用到这些麻烦/复杂/难以理解的功能的。&lt;/p&gt;
&lt;p&gt;所以，如果你看到了这里，恭喜你已经掌握了 Git 单分支的工作流程了。就是改文件，暂存，提交，推送。而下一章我们会看看 Git 被吹的神乎其神的分支到底是个啥，再解释 Git 中的一些概念。&lt;/p&gt;
&lt;p&gt;这里要特别声明的是，这篇文章的比喻借鉴了 &lt;a class="link" href="https://space.bilibili.com/337242418" target="_blank" rel="noopener"
&gt;HDAlex_John&lt;/a&gt; 的 Git 教程系列：&lt;a class="link" href="https://www.bilibili.com/video/BV1Hkr7YYEh8" target="_blank" rel="noopener"
&gt;给傻子的 Git 教程&lt;/a&gt;，讲的相当好。好在我不是傻子，看着也不累，哈哈哈哈。（还是自己写起来比较累）&lt;/p&gt;
&lt;p&gt;那么最后，感谢你看到这里，祝你心情愉悦，生活顺遂！~&lt;/p&gt;</description></item><item><title>使用 rsync 进行同步</title><link>https://a-moment096.github.io/posts/2025/07/use_rsync/</link><pubDate>Mon, 28 Jul 2025 12:43:39 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/07/use_rsync/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/07/use_rsync/%E8%B4%9D%E5%8A%A0%E5%B0%94%E6%B9%96%E7%95%94.jpg" alt="Featured image of post 使用 rsync 进行同步" /&gt;&lt;p&gt;&lt;em&gt;有点受不太了 &lt;code&gt;scp&lt;/code&gt; 和 &lt;code&gt;sftp&lt;/code&gt; 了，也许是食用姿势不对吧，总之我选择 &lt;code&gt;rsync&lt;/code&gt;！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;del&gt;图源找不到诶……从朋友那里薅过来的图，很漂亮就放在这里了&lt;/del&gt; 小爷我找到啦！是出自 &lt;a class="link" href="https://www.pixiv.net/en/users/8605991" target="_blank" rel="noopener"
&gt;fasnakegod&lt;/a&gt; 大大的 &lt;a class="link" href="https://www.pixiv.net/en/artworks/125739568" target="_blank" rel="noopener"
&gt;贝加尔湖畔&lt;/a&gt;。既然如此就分享一首钢琴曲吧。一首 &lt;strong&gt;騎士王の誇り&lt;/strong&gt; (骑士王的荣耀) 送给大家。（好像毫无关联诶 kora!）&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=448119" theme="#2980b9" loop="never"&gt;&lt;/meting-js&gt;
&lt;h2 id="为什么要选择-rsync-呢"&gt;为什么要选择 &lt;code&gt;rsync&lt;/code&gt; 呢？
&lt;/h2&gt;&lt;p&gt;有时候我们有多个远程电脑，或者是服务器，上面的文件内容我们希望下载到本地。我们通常有这么几个选择：使用一些功能成熟的，专用于 SSH 连接的终端模拟器，比如 MobaXTerm 这样的软件；或者我们可以使用 &lt;code&gt;scp&lt;/code&gt;，&lt;code&gt;sftp&lt;/code&gt; 这样的工具，但是界面有点简陋，特别是 &lt;code&gt;sftp&lt;/code&gt;，需要反复确认文件名是否输入错误。而且有时我们只需要下载不同的部分，不希望重复下载已经有了的部分。这时候，&lt;code&gt;rsync&lt;/code&gt; 作为 &lt;em&gt;remote sync&lt;/em&gt; 的工具，就到了发挥其作用的地方了。&lt;/p&gt;
&lt;h2 id="使用方法"&gt;使用方法
&lt;/h2&gt;&lt;h3 id="命令结构"&gt;命令结构
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;rsync&lt;/code&gt; 命令使用方法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;rsync --option1 --option2 /pass/files/from/this/ /path/files/to/here
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以大概就是遵循：&lt;code&gt;命令，选项，从哪里来，到哪里去&lt;/code&gt; 这样的规则。另外，既然 &lt;code&gt;rsync&lt;/code&gt; 是 &lt;em&gt;remote sync&lt;/em&gt; 的简称，自然这个命令也是可以被用于远程服务器之间的文件传输的。方法也很简单，就是给对应的文件路径添加上使用 &lt;code&gt;ssh&lt;/code&gt; 的用户名、服务器地址等信息。具体用法我们下面介绍。&lt;/p&gt;
&lt;h3 id="注意路径分隔符-"&gt;注意路径分隔符 &lt;code&gt;/&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;首先，这里需要强调的是，请注意 &lt;code&gt;从哪里来&lt;/code&gt;，也就是发送端的这一部分，这里明显是一个文件夹，因为路径的最后有一个 &lt;code&gt;/&lt;/code&gt; 符号。也许有人会问：我知道它是文件夹，我能不要那个 &lt;code&gt;/&lt;/code&gt; 吗？比如使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;rsync --opt1 --opt2 /pass/files/from/this /path/files/to/here
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的命令，来把文件夹传过去，可以吗？&lt;/p&gt;
&lt;p&gt;答案很有趣：是的，你可以传过去，但是也许不会以你预期的方式传过去。由于 &lt;code&gt;rsync&lt;/code&gt; 会默认传过去的位置是个文件夹，如果你不带上这个斜杠的话，&lt;code&gt;rsync&lt;/code&gt; 会认为你打算把 &lt;code&gt;/pass/files/from/this&lt;/code&gt; 这个文件夹 &lt;strong&gt;放在目标位置的里面&lt;/strong&gt;。如果你的确打算这么做，那没什么问题。比如你在本地有一个文件夹 &lt;code&gt;$HOME/mydocuments&lt;/code&gt;，你在远程的服务器的接收端上也有这么个文件夹，位置一模一样，那么就可以尝试&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;rsync -r $HOME/mydocuments me@remote:/home/me
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会直接把 &lt;code&gt;$HOME/mydocuments&lt;/code&gt; 传到远程的 &lt;code&gt;/home/me&lt;/code&gt; 文件夹下，形成 &lt;code&gt;/home/me/mydocuments&lt;/code&gt; 这样的结构。&lt;/p&gt;
&lt;p&gt;那么假如你是想说，我要把 &lt;code&gt;$HOME/mydocuments&lt;/code&gt; &lt;strong&gt;里面的内容&lt;/strong&gt; 传到 &lt;code&gt;/home/me/another/position&lt;/code&gt; 的话，那你就需要带上这个斜杠了，因为 &lt;code&gt;rsync&lt;/code&gt; 就会聪明地帮你把文件夹里面的所有内容传到目标位置的那个文件夹里。也许也算是符合 “一切皆文件” 的思想了吧，如果你不带分隔符，就会以文件形式把这个 &lt;em&gt;文件&lt;/em&gt; 传到文件夹里；而如果带上路径分隔符，则说明你要传的是文件夹的内容。&lt;/p&gt;
&lt;h3 id="远程链接"&gt;远程链接
&lt;/h3&gt;&lt;p&gt;作为一款远程同步软件，自然需要有办法告诉 &lt;code&gt;rsync&lt;/code&gt; 要把文件从哪里发到哪里。好消息是，&lt;code&gt;rsync&lt;/code&gt; 支持我们通过 SSH 传输文件，而方法也特别简单。只需要在文件路径前面添加上你的用户名和主机名就可以了。如果你设置了 SSH 的主机名，甚至可以更方便。&lt;/p&gt;
&lt;p&gt;这里举个很简单的例子，从本机传到本机，但是通过 SSH 进行。我们可以通过 &lt;code&gt;ssh &amp;lt;user&amp;gt;@localhost&lt;/code&gt; 来登录到本机的本地账户上，我的用户名是 &lt;code&gt;amoment&lt;/code&gt;，所以就会用 &lt;code&gt;ssh amoment@localhost&lt;/code&gt; 来登录到本机。那么我们就可以这样告诉 &lt;code&gt;rsync&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;rsync -r /home/amoment/myfiles/ amoment@localhost:/home/amoment/somefolder
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;来把我家目录下的 &lt;code&gt;myfiles&lt;/code&gt; 文件夹里的内容复制/同步到同在家目录下的 &lt;code&gt;somefolder&lt;/code&gt; 文件夹下。有了这个例子，你应该也明白怎么跨设备使用 &lt;code&gt;rsync&lt;/code&gt; 通过 SSH 进行连接与文件传输了吧。&lt;/p&gt;
&lt;p&gt;除了使用 SSH 协议以外，&lt;code&gt;rsync&lt;/code&gt; 还支持一些其他的协议，比如所谓的 RSH，或者 &lt;code&gt;rsync&lt;/code&gt; 自带的 &lt;code&gt;rsync://&lt;/code&gt; 协议。但是由于 SSH 的支持还是更加广泛，我们这里还是只介绍该方案。如果感兴趣的话，可以查阅 &lt;code&gt;rsync&lt;/code&gt; 的手册或者文档等资料。&lt;/p&gt;
&lt;h3 id="一些重要的参数"&gt;一些重要的参数
&lt;/h3&gt;&lt;p&gt;下面列举一些重要的，可能会经常使用到的参数。我们按一个大致的类别做区分，方便查找。&lt;/p&gt;
&lt;h4 id="文件操作"&gt;文件操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-r --recursive&lt;/code&gt;: 递归模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的意思是 &lt;em&gt;recursive&lt;/em&gt;，也就是递归地把所有内容都传过去。如果不加这个东西，会发生什么呢？好消息是你照样能完成传输，但是坏消息是，你 &lt;strong&gt;只传过去了文件夹&lt;/strong&gt;。也就是说，如果你不是只想在目标位置创建一个可能是新的文件夹的话，而是想把文件都传过去，请记得带上 &lt;code&gt;-r&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a -- archive&lt;/code&gt;: 存档模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以选择不使用 &lt;code&gt;-r&lt;/code&gt; 而是使用 &lt;code&gt;-a&lt;/code&gt;，使用 &lt;code&gt;-a&lt;/code&gt; 会以存档方式传输文件，也就是说，文件夹内的所有东西都会 &lt;em&gt;保持原样&lt;/em&gt; 地传过去：不论是文件，文件夹，还是链接，设备描述符等，全都会原样传过去。&lt;code&gt;-a&lt;/code&gt; 实际上是一系列参数的总和。根据帮助文档所述，是 &lt;code&gt;-rlptgoD&lt;/code&gt;。还挺多的……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--delete&lt;/code&gt;: 允许删除不同步的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 &lt;code&gt;rsync&lt;/code&gt; 如其名所示，是 &lt;em&gt;同步软件&lt;/em&gt;，因此我们也许希望不是 “上传” 文件，而是 &lt;em&gt;把本地文件结构同步到远程&lt;/em&gt;。此时，我们需要用到 &lt;code&gt;--delete&lt;/code&gt; 这个参数，它给了 &lt;code&gt;rsync&lt;/code&gt; 删除目标文件夹内多余文件的权利，从而保证你确实是在 &lt;em&gt;同步&lt;/em&gt; 内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--exclude&lt;/code&gt; &lt;code&gt;--include&lt;/code&gt;: 按模式进行排除/包含&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个参数我们放在一起讲。如其名称所述，是用来告诉 &lt;code&gt;rsync&lt;/code&gt; 排除哪些文件或者包含哪些文件用的。如果你有些文件不想传/特意要传，请设置这两个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--ignore-existing&lt;/code&gt;: 跳过传输同名文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加上这个参数会让 &lt;code&gt;rsync&lt;/code&gt; 检查接收端已有文件的名字，如果本地和接收端都有这么个文件（名称相同），则会跳过这个文件不进行传输。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u --update&lt;/code&gt;: 只传输更新的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个参数意味着你是打算 &lt;em&gt;更新&lt;/em&gt; 文件们。那么，如果接收端的文件比发送端更新（还要新）呢？答案就是不会碰这些文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-z --compress&lt;/code&gt;: 先压缩一下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个参数会告诉 &lt;code&gt;rsync&lt;/code&gt; 传输前先帮你把要传的东西压缩一下。&lt;code&gt;rsync&lt;/code&gt; 会自己选择一个压缩方法，所以一般不用担心。&lt;/p&gt;
&lt;h4 id="信息提供"&gt;信息提供
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n --dry-run&lt;/code&gt;: 试运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你要是担心传过去的内容不是你实际打算传的东西，你可以先让 &lt;code&gt;rsync&lt;/code&gt; 告诉你目前的命令会传些什么，且不真的开始工作，只需要加上 &lt;code&gt;-n&lt;/code&gt; 就可以。你可以把它理解为 &lt;em&gt;no&lt;/em&gt;，即便实际上它对应的长参数是 &lt;code&gt;--dry-run&lt;/code&gt;。拿不准会传些什么过去的时候，这个命令会很有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-v --verbose&lt;/code&gt;: 更啰嗦一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几乎所有（较复杂）的命令行程序都会内置这样一个命令，来把工作信息 “更啰嗦” 地显示出来。如果你需要额外的信息，请使用这个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt;: 进度条&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是让 &lt;code&gt;rsync&lt;/code&gt; 报告当前的传输进度。我很喜欢用。&lt;/p&gt;
&lt;h4 id="涉及-rsync-本身--远程协作"&gt;涉及 &lt;code&gt;rsync&lt;/code&gt; 本身 / 远程协作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-e --rsh&lt;/code&gt;: 指定传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能我们要传输的设备开放的 SSH 端口不在默认的 &lt;code&gt;22&lt;/code&gt; 而是一个自定义的端口。此时我们就需要 &lt;code&gt;-e&lt;/code&gt; 然后在后面带上一个字符串来表示使用的 shell 是哪个。比如我的远程接收端接口是 &lt;code&gt;1145&lt;/code&gt;，则我会使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;rsync -r -e &amp;#34;ssh -p 1145&amp;#34; /myfiles/ me@remote:/myfiles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;来让 &lt;code&gt;rsync&lt;/code&gt; 尝试使用 &lt;code&gt;1145&lt;/code&gt; 端口进行 SSH 通信与文件传输。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--rsync-path&lt;/code&gt;: &lt;code&gt;rsync&lt;/code&gt; 在哪？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有可能我们需要帮助本地的 &lt;code&gt;rsync&lt;/code&gt; 来寻找到另一个 &lt;code&gt;rsync&lt;/code&gt; 究竟在哪。此时我们就需要这个参数来发挥作用，在后面带上找到 &lt;code&gt;rsync&lt;/code&gt; 的方法：不论是 &lt;code&gt;rsync&lt;/code&gt; 的路径，还是别的方式，都可以。比如希望传输的设备有 &lt;code&gt;rsync&lt;/code&gt;，但是在 WSL 上。此时我们就可以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;rsync -r --rsync-path &amp;#39;wsl rsync&amp;#39; me@remote:/myfiles/ /myfiles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;来让远程使用 WSL 上的 &lt;code&gt;rsync&lt;/code&gt; 为我进行工作。&lt;/p&gt;
&lt;h2 id="后记"&gt;后记
&lt;/h2&gt;&lt;p&gt;我一开始使用 &lt;code&gt;rsync&lt;/code&gt; 的主要理由其实是为了在不同的设备之间同步我的歌曲库。由于我有一些歌曲通过移动硬盘已经移动了一部分，而还有一部分没有同步，在另一台电脑上我甚至新添加了一张专辑，所以感觉单纯地自己手动搜索要迁移的文件有点太累了。而此时，&lt;code&gt;rsync&lt;/code&gt; 用它 &lt;strong&gt;增量同步&lt;/strong&gt; 的特性吸引了我，我便使用这么个方式来把远程的歌曲同步到本地电脑上来。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rsync&lt;/code&gt; 还是挺好用的，它的语法可能没有那么智能，但是已经足以应付我遇到的问题了。印象中还有一些别的同步软件，比如朋友推荐的 &lt;code&gt;Syncthing&lt;/code&gt;，也许后面会尝试使用一下。&lt;/p&gt;
&lt;p&gt;另外不得不提的是我在准备该文章时查阅过的信息源。非常感谢！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，ChatGPT 和 Deepseek，完全不了解的时候和这些 AI 问一下还是挺好用的；&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories" target="_blank" rel="noopener"
&gt;rsync tutorial&lt;/a&gt;: 一个简单的 rsync walkthrough，帮了我很多；&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.geeksforgeeks.org/linux-unix/rsync-command-in-linux-with-examples/" target="_blank" rel="noopener"
&gt;rsync command in Linux with Examples&lt;/a&gt;: GeeksForGeeks 下的一个博客，内容很丰富。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，感谢您能看到这里，祝您身体健康，心情愉悦~&lt;/p&gt;</description></item><item><title>上一个命令是什么？</title><link>https://a-moment096.github.io/posts/2025/07/last_command/</link><pubDate>Sat, 26 Jul 2025 20:09:18 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/07/last_command/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/07/last_command/SEASIDE_SOLILOQUIES.png" alt="Featured image of post 上一个命令是什么？" /&gt;&lt;p&gt;&lt;em&gt;曾经总会好奇：怎么获取上一个命令呢？应该很简单才对吧？简单的搜索后，下面是我得到的结果，就记录一下吧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图出自 Orangestar 的专辑 &lt;strong&gt;SEASIDE SOLILOQUIES&lt;/strong&gt;, 好看又好听。所以这里贴曲就贴这个专辑的主打歌好了：一首 &lt;strong&gt;Alice in 冷凍庫&lt;/strong&gt;，希望你喜欢。&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=458231453" theme="#2980b9" loop="none"&gt;&lt;/meting-js&gt;
&lt;h2 id="什么时候要用这个"&gt;什么时候要用这个？
&lt;/h2&gt;&lt;p&gt;有时候我们写了一长串命令，比如有很麻烦的路径之类的，这时候我们可能会希望用某个符号来自动地填上命令里的某些参数。一个最常见的例子，当我要安装某些软件包的时候，偶尔会忘记加上 &lt;code&gt;sudo&lt;/code&gt; 来以管理员权限运行。这时候把上面的命令复制一遍再补上 &lt;code&gt;sudo&lt;/code&gt; 实在是太慢了，而按下上箭头后在把光标挪到第一行，最后补上 &lt;code&gt;sudo&lt;/code&gt; 总是感觉很累，手的移动距离感觉好远。除此之外，有时输入的一长串命令/参数并运行之后，我需要接着上面的参数继续运行别的命令，此时要是用命令行历史的话，就又得用光标定位之后，再删掉没有用的东西，最后再填上要替换的内容。这实在是太慢了。&lt;/p&gt;
&lt;p&gt;好在这时候，我们还可以使用 &lt;code&gt;zsh&lt;/code&gt; 交互模式下的一个内置宏：使用 &lt;code&gt;!&lt;/code&gt;，感叹号，以及其对应的一些变体，来获取上个命令中的参数/整个命令等。下面就来介绍怎么使用吧。&lt;/p&gt;
&lt;h2 id="我需要取整个命令"&gt;我需要取整个命令
&lt;/h2&gt;&lt;h3 id="上个命令是什么"&gt;上个命令是什么？
&lt;/h3&gt;&lt;p&gt;我们可以用 &lt;code&gt;!!&lt;/code&gt;，或者 &lt;code&gt;!-1&lt;/code&gt;， 来获取 “上一个执行了的命令”。比如如下操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; hello bash world!
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;hello bash world!
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !! &lt;span class="c1"&gt;# !! 替换了上面整个执行了的命令，也就是替换了 &amp;#34;echo hello bash world&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; hello bash world!
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-1 &lt;span class="c1"&gt;# 同上,也是替换上面执行的命令，所以替换了 &amp;#34;echo echo hello bash world&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; hello bash world!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="我要调用历史命令"&gt;我要调用历史命令
&lt;/h3&gt;&lt;p&gt;我们还可以用 &lt;code&gt;!&amp;lt;num&amp;gt;&lt;/code&gt; 来选择某个历史命令。我们可以先用 &lt;code&gt;head&lt;/code&gt; 来查看一下我们的命令历史里最早有一些什么：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;$ head ~/.zsh_history &lt;span class="c1"&gt;# 这里我的 zsh 命令历史存在这个文件里，可以用 head 查看前几个命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;: 12345:0&lt;span class="p"&gt;;&lt;/span&gt;clear
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;: 12346:0&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; hello
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;: 12347:0&lt;span class="p"&gt;;&lt;/span&gt;ls
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;## ... ... &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;随后我们可以使用 &lt;code&gt;!1&lt;/code&gt; 来选择历史命令中的第一个命令，这里的第一个命令就是 &lt;code&gt;clear&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;$ !1 &lt;span class="c1"&gt;# 执行第一个历史命令，也就是 clear，会直接清空屏幕；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;$ !2 &lt;span class="c1"&gt;# 执行第二个历史命令，会打印 hello；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;$ !3 &lt;span class="c1"&gt;# 执行第三个历史命令，会打印当前文件夹下的内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;file1 file2 file3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="小结"&gt;小结
&lt;/h3&gt;&lt;p&gt;我们可以看到，后面跟着的数字实际上表示了“第几个命令”，而举一反三，&lt;code&gt;!-1&lt;/code&gt; 则代表的是“最后一个命令”，即上一个命令，那么 &lt;code&gt;!-2&lt;/code&gt; 就是倒数第二个命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有了这两个命令，我们可以很方便地在忘记使用 &lt;code&gt;sudo&lt;/code&gt; 权限时，使用 &lt;code&gt;sudo !!&lt;/code&gt; 或者选择某个历史命令，来快速使用 &lt;code&gt;sudo&lt;/code&gt; 权限执行命令。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="我需要取几个参数"&gt;我需要取几个参数
&lt;/h2&gt;&lt;h3 id="我需要某个参数"&gt;我需要某个参数
&lt;/h3&gt;&lt;p&gt;我们可以使用 &lt;code&gt;:&amp;lt;num&amp;gt;&lt;/code&gt; 来选择第几个参数。它需要配合 &lt;code&gt;!&lt;/code&gt; 进行使用。参数从 1 开始，而 0 有特殊含义，代表命令。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; one two three
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;one two three
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-1:2 &lt;span class="c1"&gt;# 相当于 echo two&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;two
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !:0 &lt;span class="c1"&gt;# 上个命令使用了 echo，所以 0 代表 echo，这个命令相当于 echo echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当使用 &lt;code&gt;:&lt;/code&gt; 来进行参数选择时，如果是从上一个命令中选择则可以简写为 &lt;code&gt;!:&amp;lt;num1&amp;gt;-&amp;lt;num2&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="我需要这几个参数"&gt;我需要这几个参数
&lt;/h3&gt;&lt;p&gt;我们还能用 &lt;code&gt;:&amp;lt;num1&amp;gt;-&amp;lt;num2&amp;gt;&lt;/code&gt; 来范围式地选择命令的参数。比如，使用 &lt;code&gt;!!:1-2&lt;/code&gt; 就说明要取第一个和第二个参数。（注意这里是参数，不是空格分隔的字符串，也不包含第一个词（也就是命令））。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; one two three four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;one two three four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !!:1-2 &lt;span class="c1"&gt;# 相当于 echo one two &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;one two
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; one two three four &lt;span class="c1"&gt;# 这行用来重置最后一个命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt;one two three four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !!:-3 &lt;span class="c1"&gt;# 没有 &amp;lt;num1&amp;gt; 则会自动替换为0，相当于 echo echo one two three&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; one two three
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-2:1-2 &lt;span class="c1"&gt;# 配合 !&amp;lt;num&amp;gt; 使用，相当于 echo one two &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt;one two
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-3:1- &lt;span class="c1"&gt;# 没有 &amp;lt;num2&amp;gt; 则会匹配到除了最后一个参数外的参数，相当于 echo one two three&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt;one two three
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-4:$ &lt;span class="c1"&gt;# 使用 $ 来获取最后一个参数，相当于 echo four&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt;four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-5:3-$ &lt;span class="c1"&gt;# 同样 $ 也支持范围选择，相当于 echo three four&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt;three four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !-6:* &lt;span class="c1"&gt;# 使用 * 来表示所有的参数，相当于 echo !-6:1-$，也就是 echo one two three four&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt;one two three four
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; !:* &lt;span class="c1"&gt;# !: 是在使用冒号时 !!: 或者 !-1: 的简写，相当于 echo one two three four&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt;one two three four
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果没有 &lt;code&gt;&amp;lt;num1&amp;gt;&lt;/code&gt;，则默认从 &lt;code&gt;0&lt;/code&gt; 开始，也就是会包含所有内容；如果没有 &lt;code&gt;&amp;lt;num2&amp;gt;&lt;/code&gt;，则默认停在最后一个参数前。可以使用 &lt;code&gt;*&lt;/code&gt; 来选择所有的参数，使用 &lt;code&gt;$&lt;/code&gt; 选择最后一个参数。&lt;/p&gt;
&lt;h2 id="我要对字符串做处理"&gt;我要对字符串做处理
&lt;/h2&gt;&lt;p&gt;在冒号后使用一些字母来做相应的处理。假设有命令 &lt;code&gt;ls /path/to/a/file.txt&lt;/code&gt; 并且我们使用 &lt;code&gt;echo !:1&lt;/code&gt; 尝试调用这个 &lt;code&gt;ls&lt;/code&gt; 的命令，则下面的参数选择器可以做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:p&lt;/code&gt; (print) 只打印，不运行，或者说提供一个预览。ZSH 用户也许不需要担心这一点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt; (quote) 对选中字段加上引号，结果为 &lt;code&gt;'/path/to/a/file'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:r&lt;/code&gt;（root）取文件的完整文件名，结果为 &lt;code&gt;/path/to/a/file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:e&lt;/code&gt;（extension）取文件的后缀名，结果为 &lt;code&gt;txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:h&lt;/code&gt;（head）取文件路径的地址，结果为 &lt;code&gt;/path/to/a/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:t&lt;/code&gt;（tail）取文件的名称，结果为 &lt;code&gt;file.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:s/to/has&lt;/code&gt;（search）可以在参数中寻找&lt;em&gt;第一个&lt;/em&gt; &lt;code&gt;to&lt;/code&gt; 并替换为 &lt;code&gt;has&lt;/code&gt;，结果为 &lt;code&gt;/path/has/a/file.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:gs/to/has&lt;/code&gt;（global search）同上，但是全局查找替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tldr"&gt;TL;DR
&lt;/h2&gt;&lt;p&gt;下面是一个表格简单描述这些用法&lt;/p&gt;
&lt;h3 id="命令选择使用-"&gt;命令选择（使用 &lt;code&gt;!&lt;/code&gt;）
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一条命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo !!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!-n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;倒数第 n 条命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!-2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第 n 条历史命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!42&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!字符串&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最近以该字符串开头的命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!ls&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!?字符串?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最近包含该字符串的命令&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!?foo?&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^旧^新&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将上一条命令中第一个“旧”替换为“新”&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^cat^bat&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="参数选择-使用-"&gt;参数选择 （使用 &lt;code&gt;:&lt;/code&gt;）
&lt;/h3&gt;&lt;p&gt;下面的示例命令使用 &lt;code&gt;echo file.txt&lt;/code&gt; 来做演示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一条命令的命令名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:0&lt;/code&gt; → &lt;code&gt;echo&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:1&lt;/code&gt; → &lt;code&gt;file.txt&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最后一个参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:$&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有参数（等同于 &lt;code&gt;!!:1-$&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:1-3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第 1 到第 3 个参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:1-3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!!:2-$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从第 2 个到最后一个参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:2-$&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一条命令的最后一个参数 (可以省略冒号)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cat !$&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一条命令的所有参数（可以省略冒号）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rm !*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="参数修饰"&gt;参数修饰
&lt;/h3&gt;&lt;p&gt;下面的示例命令使用 &lt;code&gt;echo /path/to/file.txt&lt;/code&gt; 来做演示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只打印命令，不执行&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sudo !!:p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;给参数加引号，避免空格或特殊字符问题&lt;/td&gt;
&lt;td&gt;&lt;code&gt;echo !!:1:q&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取路径头部（类似 &lt;code&gt;dirname&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;echo !!:1:h&lt;/code&gt; → &lt;code&gt;/path/to&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取路径尾部（类似 &lt;code&gt;basename&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;echo !!:1:t&lt;/code&gt; → &lt;code&gt;file.txt&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;去掉文件扩展名（保留主名）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;echo !!:1:r&lt;/code&gt; → &lt;code&gt;file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取文件扩展名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;echo !!:1:e&lt;/code&gt; → &lt;code&gt;txt&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:s/旧/新/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;替换第一个出现的子串&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:1:s/foo/bar/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:gs/旧/新/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;替换所有出现的子串&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!!:1:gs/foo/bar/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;p&gt;这里其实应该没有写完，不过就这些已经列出来的方法而言，我个人感觉是已经挺够用的了。毕竟，平时最常用的也就是 &lt;code&gt;sudo !!&lt;/code&gt; 来给 &lt;code&gt;pamcan -Syu&lt;/code&gt; 补上管理员权限而已，或者是在 &lt;code&gt;ls -l /path/to/file&lt;/code&gt; 确定文件/文件夹存在后用 &lt;code&gt;vim&lt;/code&gt; 或者 &lt;code&gt;cd&lt;/code&gt; 打开它罢了。&lt;/p&gt;
&lt;p&gt;还有一点要注意的是，&lt;code&gt;bash&lt;/code&gt; 默认是不会像 &lt;code&gt;zsh&lt;/code&gt; 一样先提供一个预览，让你看看会发生什么的，而是直接就运行命令了。所以也许在 &lt;code&gt;bash&lt;/code&gt; 中使用这个功能时需要额外注意，特别是涉及一些比较危险的动作，比如 &lt;code&gt;rm&lt;/code&gt; 这类命令。此时你可以尝试先用 &lt;code&gt;:p&lt;/code&gt; 来打印出来要运行的命令，没啥问题就可以运行了。印象中应该还有一个办法，来让 &lt;code&gt;bash&lt;/code&gt; 也先提供一个预览而非直接运行。不过，因为我用的是 &lt;code&gt;zsh&lt;/code&gt;，就不纠结这个问题了。也许以后我还会更新这篇文章呢？哈哈。&lt;/p&gt;
&lt;p&gt;那么，感谢你看到这里，祝您身心愉悦，身体健康~&lt;/p&gt;</description></item><item><title>C++ Vector 的内存布局</title><link>https://a-moment096.github.io/posts/2025/05/vector_memory_layout/</link><pubDate>Tue, 27 May 2025 09:53:29 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/05/vector_memory_layout/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/05/vector_memory_layout/Bamboo_Reimu.jpg" alt="Featured image of post C++ Vector 的内存布局" /&gt;&lt;p&gt;&lt;em&gt;探索一下 C++ 的容器 &lt;code&gt;vector&lt;/code&gt; 的内存布局，也算是解答我自己的一些疑虑咯&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图是从网上搜的，尝试寻找出处，未果。很可惜。选曲尝试选择了一首听着比较清淡的曲子 &lt;strong&gt;泪苔&lt;/strong&gt;，感觉比较符合头图清新淡雅的神社氛围。希望你喜欢。&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=26537200" theme="#2980b9" loop="none"&gt;&lt;/meting-js&gt;
&lt;h2 id="先介绍一下-vector-的基本情况咯"&gt;先介绍一下 &lt;code&gt;vector&lt;/code&gt; 的基本情况咯
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 是由 C++ 标准库提供的一个容器模板类。这里不打算仔细介绍什么是容器，模板，什么是类，我们直接指出：&lt;code&gt;vector&lt;/code&gt; 的作用就是一个更好用的数组。“类”是说明它自己带了一些好用的函数，称为“方法”，“模板”就是说它需要接受一个类型作为参数才能成为一个完整的类型，就像数组必须说明是什么东西的数组一样。最后“容器”就是说它是一类经过了特殊优化的模板类，和别的容器一起共用着一些方法与成员，且有一类公共的算法可以用在它们上面。&lt;/p&gt;
&lt;p&gt;和传统的数组相比，&lt;code&gt;vector&lt;/code&gt;有这样的几个特点：首先它符合 &lt;em&gt;RAII&lt;/em&gt; (Resource Allocation Is Initialization) 的要求，即自动管理内存，离开作用域时自动销毁，而传统的数组则不是很满足 &lt;em&gt;RAII&lt;/em&gt; 的条件；其次就是 &lt;code&gt;vector&lt;/code&gt; 是动态大小的，在使用时不需要在编译期就了解这个东西的大小，程序会根据需求自动分配内存。虽然后者在 C 中也能实现，比如指针+ &lt;code&gt;malloc&lt;/code&gt; 或者指针+ &lt;code&gt;new&lt;/code&gt; 的组合，然而这样的组合需要直接面对自己创建的裸指针 (Raw Pointer)，一个不小心就很容易造成内存泄漏，所以使用时要特别注意。最后就是，相比起数组这样较基础的数据类型，使用 &lt;code&gt;vector&lt;/code&gt; 的内建函数（方法）可以避免自己造一些轮子，会比较方便。&lt;/p&gt;
&lt;p&gt;即便 &lt;code&gt;vector&lt;/code&gt; 看起来这么好，其实还是有人会担心 &lt;code&gt;vector&lt;/code&gt; 会引入额外的运行开销。特别是，有人可能会怀疑：我使用数组或者指针+&lt;code&gt;malloc&lt;/code&gt;或者指针+&lt;code&gt;new&lt;/code&gt; 得到的内存空间我是明确知道时连续的，那 &lt;code&gt;vector&lt;/code&gt; 呢？它经过这样的包装之后，还拥有连续内存空间吗？这篇文章就是打算探讨这个问题。&lt;/p&gt;
&lt;h2 id="vector-为什么可能会比较低效"&gt;&lt;code&gt;vector&lt;/code&gt; 为什么“可能”会比较低效？
&lt;/h2&gt;&lt;p&gt;我们这里不打算介绍什么复杂的内容，比如什么 allocator 或者内存调度机制。我们只对“指针+&lt;code&gt;malloc&lt;/code&gt;”、“指针+new”方法以及&lt;code&gt;vector&lt;/code&gt;方法是怎么获取可用内存空间的方法进行简单说明。&lt;/p&gt;
&lt;p&gt;不过在进入具体的内存分配过程介绍之前，我们希望能先介绍几个概念：&lt;/p&gt;
&lt;h3 id="堆与栈"&gt;堆与栈
&lt;/h3&gt;&lt;p&gt;我们写好的程序在运行时，需要同系统进行交互，借由多种系统调用完成任务。而在程序运行的过程中需要的内存空间则也是由系统进行分配的。一般我们将系统分配的内存空间划分为两块，一块叫&lt;em&gt;堆&lt;/em&gt;，而另一块儿叫&lt;em&gt;栈&lt;/em&gt;。请注意这里的堆栈并不能直接对应数据结构，请仅将其看作内存空间的称呼。&lt;/p&gt;
&lt;p&gt;程序运行时，系统会将调用的函数一个一个压入调用栈中，栈空间内实行先进后出（也是栈这一称呼的来源），连带着函数需要的变量也是一样压入栈内的。然而，栈实际上相对比较小，如果在栈内存放了过多的资源导致栈内空间不足，程序则会出现所谓的栈溢出 (Stack Overflow)。不过好消息是，系统并不会傻傻地将任何东西都放在宝贵的栈空间内，在存储大量内容时，可以把这些内容存储在堆中。&lt;/p&gt;
&lt;p&gt;堆和栈都是由系统负责内存分配的，区别在于，栈是严格执行先进后出的，且空间有限，只负责函数调用等，资源会被自动回收；而堆则不同，堆相比栈而言会比较大，里面的资源不需要什么先进后出，然而在程序不再用到里面存储的资源时，系统也不会自动回收它们，取用这些内存资源的方式也是需要通过指针进行读取或写入的。所以相比栈空间，堆空间的运用更需要一些技巧，如果使用比较传统的方式的话。有句话很好地形容了堆：垃圾堆。如果能很好地管理这里的内容，那样就会很好用，否则就会让系统东留一块儿垃圾西留一块儿垃圾，最后变成垃圾堆。所以C/C++编程的一大技巧就是使用好堆上的空间。&lt;/p&gt;
&lt;p&gt;那么，我们应该如何，按照上面所述的方法，进行堆上的内存管理呢？&lt;/p&gt;
&lt;h3 id="malloc-的内存分配方法"&gt;&lt;code&gt;malloc&lt;/code&gt; 的内存分配方法
&lt;/h3&gt;&lt;p&gt;传统的指针+&lt;code&gt;malloc&lt;/code&gt;方法大概是这样工作的：首先声明一个指针，它不指向什么具体的内存地址（空指针），然后再通过 &lt;code&gt;malloc&lt;/code&gt; 中传入的参数来决定从这个指针开始要给它多大的连续空间（一个内存段），最后让这个指针指向这个内存段的头部，从而完成内存分配。这样的方法最大的特点是它不需要编译时就确定好需要多大的内存，而是通过 &lt;code&gt;malloc&lt;/code&gt; “动态地” 分配一段内存，然后交给这个指针进行管理。在 C 语言写的程序中，基本都是这么进行运行期间的内存分配的。&lt;/p&gt;
&lt;p&gt;这样的内存分配方法，在 C 语言兴起的时候，是非常伟大的。然而这个方法存在着很多的问题：首先就是指针操作的复杂性。使用 &lt;code&gt;malloc&lt;/code&gt; 时必须留意管理内存资源的指针。在内存不再被使用时必须调用 &lt;code&gt;free&lt;/code&gt; 函数来释放资源，且在 &lt;code&gt;free&lt;/code&gt; 之后就不能再次调用这个资源来。很多程序运行崩溃，都是由指针造成的，或者是忘记删除已经不需要的资源，或者是引用了空指针或者悬垂指针。另外就是使用 &lt;code&gt;malloc&lt;/code&gt; 分配的内存实际上也没有那么动态：如果你声明了 100 字节的内存，那就一定而且只有 100 字节的连续内存可以用：如果你实际上用不到 100 字节，那多余的空间会被浪费，不过这样还好；而当你用了超过 100 个字节的数据，却尝试将它们放在 100 个字节的内存段中时，多出来的部分会直接被截断，也就是说多出来的部分就消失了。最后，很致命的一点是，&lt;code&gt;malloc&lt;/code&gt; 是一个很不智能的函数。它没有类型（返回 &lt;code&gt;void*&lt;/code&gt;）,不调用构造函数，且必须要手动计算好分配的字节数，然后传给它。这实在是一个坏消息。而即便你注意了资源的声明与使用，使用裸指针管理资源的过程也比较繁琐：你需要使用一些诸如 &lt;code&gt;memcpy&lt;/code&gt; 这样的函数来管理内存，这些函数操作非常精细，它会要求操作的字节数量。有机会在程序运行的时候分配内存，这很好，但也许会显得有点太麻烦了。&lt;/p&gt;
&lt;p&gt;所以，我更愿意称使用 &lt;code&gt;malloc&lt;/code&gt; 进行内存管理更适合 “高级用户”。一般而言，除非有很明确的需求，否则不会考虑使用老式的 &lt;code&gt;malloc&lt;/code&gt; 进行内存分配，特别是在我们讨论的 C++ 语境下。那么 &lt;code&gt;new&lt;/code&gt; 又如何呢？&lt;/p&gt;
&lt;h3 id="new-的内存分配方法"&gt;&lt;code&gt;new&lt;/code&gt; 的内存分配方法
&lt;/h3&gt;&lt;p&gt;相比于 &lt;code&gt;malloc&lt;/code&gt;，&lt;code&gt;new&lt;/code&gt; 更加智能，更加符合C++的思路。它会自动调用构造函数，不需要手动计算内存量（编译器会帮你计算好），且它是强类型的，它分配的内存空间会有一个明确的类型，而不是 &lt;code&gt;void*&lt;/code&gt; 这样模棱两可的东西。然而，这里的“智能”，也只有这种程度了。究其原因，还是因为使用裸指针的原因。由于使用指针，就必须在不再使用资源时手动 &lt;code&gt;delete&lt;/code&gt; 掉它（&lt;code&gt;malloc&lt;/code&gt; 使用 &lt;code&gt;free&lt;/code&gt; 释放，&lt;code&gt;new&lt;/code&gt; 使用 &lt;code&gt;delete&lt;/code&gt; 释放）。仅此一点就使 &lt;code&gt;new&lt;/code&gt; 也不是一个特别理想的方法。它解决了一些 &lt;code&gt;malloc&lt;/code&gt; 的痛点，但是没有解决使用裸指针带来的最根本的问题。&lt;/p&gt;
&lt;p&gt;也许有朋友会讲：你提到的是裸指针，而我记得 C++ 标准 在 C++11 时引入了智能指针。它是符合 &lt;em&gt;RAII&lt;/em&gt; 规则的裸指针的包装，也就是说在不使用时可以自动销毁来释放资源。为什么不使用智能指针解决这些问题呢？&lt;/p&gt;
&lt;p&gt;没错，智能指针的引入确实能有效改善这个问题，如果需要使用指针进行操作时，换用智能指针确实是一种很好的方法。但是我们只是希望拿一块内存存储数组那样的东西，使用智能指针也许有点太重量级了。也许有人中意智能指针以及使用指针方式来进行内存管理，不过这里就不多介绍智能指针了。那既然 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;new&lt;/code&gt; 都不是非常令人满意的答案，&lt;code&gt;vector&lt;/code&gt; 就能解决这些问题吗？&lt;/p&gt;
&lt;h3 id="vector-的内存分配方法"&gt;&lt;code&gt;vector&lt;/code&gt; 的内存分配方法
&lt;/h3&gt;&lt;p&gt;我们首先给出肯定的回复：Yes, &lt;code&gt;vector&lt;/code&gt; 是 &lt;strong&gt;“我需要一块我不知道内存大小的连续内存段”&lt;/strong&gt; 的非常好的解决方案。实际上也许 &lt;code&gt;vector&lt;/code&gt; 会比想象中的更好用。&lt;code&gt;vector&lt;/code&gt; 首先是符合 &lt;em&gt;RAII&lt;/em&gt; 的，这使得我们不需要特别关注声明的资源：这些资源在离开其作用域时就自动被销毁了。不用再担心内存泄漏，也不用担心空指针之类。另外 &lt;code&gt;vector&lt;/code&gt; 虽然实际上是将资源放在堆上的，对 &lt;code&gt;vector&lt;/code&gt; 的操作实际上就像是在栈上操作它一样，对它的操作要比指针操作之类要直观的多。最后，使用 &lt;code&gt;vector&lt;/code&gt; 不用担心空间不足：当 &lt;code&gt;vector&lt;/code&gt; 内的空间不足以容纳新的东西时，&lt;code&gt;vector&lt;/code&gt; 会自动增加其容量，来容纳这些新的东西。这个操作在编程侧是近乎无感的：你可以直接把 &lt;code&gt;vector&lt;/code&gt; 当做一个无限容量的容器，你要做的事情就是往里装就 OK 了。使用 &lt;code&gt;vector&lt;/code&gt; 是很符合直觉的，给代码作者的心智负担也比较小。毕竟，封装地这么好，你只管往里 push 就好了，不用操心什么多余的问题，&lt;code&gt;vector&lt;/code&gt; 会帮你处理好的。&lt;/p&gt;
&lt;p&gt;也许有人会担心：&lt;code&gt;vector&lt;/code&gt; 就一点问题都没有？很可惜， &lt;code&gt;vector&lt;/code&gt; 也是需要正确使用的，否则就是会很低效。这一点主要体现在 &lt;code&gt;vector&lt;/code&gt; 的自动扩容上。&lt;code&gt;vector&lt;/code&gt; 的扩容机制是这样的：如果容量不够，就在当前容量上乘2（或1.5，取决于具体实现）来容纳新东西。乍一听没什么问题，而实际上扩容是一个很复杂也很慢的过程。我们下面会更深入地聊聊这个问题。另外，&lt;code&gt;vector&lt;/code&gt; 的内存真的是连续的吗？可以通过什么方法来看到其内存布局吗？我们后面也会尝试使用程序来把内存地址打印到屏幕上，看看是个什么样子。最后，当你很明确自己需要的就是固定长度的内存区域时，&lt;code&gt;vector&lt;/code&gt; 自动增长内存空间的做法可能就不合适了。这时你也许会更想使用数组的现代包装 &lt;code&gt;std::array&lt;/code&gt;，而非 &lt;code&gt;vector&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;vector&lt;/code&gt; 实际上也提供了和 C 的裸指针相容的对象，通过调用 &lt;code&gt;vector::data()&lt;/code&gt; 方法即可获得 &lt;code&gt;vector&lt;/code&gt; 内存段对应的裸指针。这样一来，需要精细操作或者与老 API 做兼容时也很方便。&lt;/p&gt;
&lt;h3 id="连续的内存空间很重要吗"&gt;连续的内存空间很重要吗？
&lt;/h3&gt;&lt;p&gt;上面我们一直强调“连续的内存空间”，也许有人会好奇，连续的内存空间很重要吗？答案是肯定的：连续的内存空间可以有效提高内存寻址速度，从而提高访问和读写的速度。事实上，有连续内存空间，自然也就有非连续的内存空间。如果一个内存段是连续的，那么就意味着从内存段头部开始，需要取用第5个元素就只需要令头指针向右（或者某个方向，取决于你）偏移4个元素，就可以取到这个元素了。典型的拥有连续内存结构的数据结构有传统的数组，以及我们这里介绍的 &lt;code&gt;vector&lt;/code&gt;。而非连续内存结构的数据结构里，非常有代表性的一个就是链表。使用链表上的第5个元素需要先从头节点向后寻找第一个节点，找到之后再跳转到第二个，不断进行这样的跳转直到找到第五个元素。使用链表的好处是链表可以极大程度利用内存空间，因为不受&lt;em&gt;连续的大段内存空间&lt;/em&gt;的条件约束，代价便是寻址速度相比数组或 &lt;code&gt;vector&lt;/code&gt; 会慢很多。&lt;/p&gt;
&lt;p&gt;另一个角度讲，&lt;code&gt;vector&lt;/code&gt; 可能会低效的原因也在于此。由于 &lt;code&gt;vector&lt;/code&gt; 需要保证内存是连续的，当它遇到内存不足时，便需要做下面的事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在内存中寻找一块新的地址，这个地址有一段连续的足够大的内存来存放老数据以及即将到来的新数据；&lt;/li&gt;
&lt;li&gt;把老数据复制到新的地址下；&lt;/li&gt;
&lt;li&gt;把新数据添加到老数据的后面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程最耗时的部分是第三步。设想这样一个情况，操作系统在给程序分配内存时分配地非常零散，且希望最最高效地利用内存，以至于内存空间内部只有长度为 1, 2, 4, 8, 16, 32 这6段长度的内存，它们的地址相隔甚远，且你拥有的一个 &lt;code&gt;vector&lt;/code&gt; 目前只保存了长度为1的数据（也就被系统分配到长度为1的地址下）。现在你打算向里面补充新数据，比如，你要往里面添加31个新数据，但是这个过程中需要做一些特别的判断，以至于编译器不能帮你做优化，直接分配给你32位长度的内存。&lt;/p&gt;
&lt;p&gt;现在，在你向后补充第一个元素时，&lt;code&gt;vector&lt;/code&gt; 会尝试寻找长度大于2的一个内存空间，它找到了第三块内存（长度为4）；你又向后补充了一个元素，此时 &lt;code&gt;vector&lt;/code&gt; 发现内存不够，但是直接扩张大小也可以，此时就不需要寻址，直接声明后面的两位内存被使用即可；你又打算向后补充三位数据。这时 &lt;code&gt;vector&lt;/code&gt; 发现内存又不够了，它寻址到第四块内存（长度为8），然后把第三块内存中的数据一个个复制到第四块内存中，然后再把新的三位数据补充到后面。&lt;/p&gt;
&lt;p&gt;发现问题了吗？&lt;code&gt;vector&lt;/code&gt; 的机制让编译器不太愿意把本就很大的内存空间直接交给 &lt;code&gt;vector&lt;/code&gt;。当你要往 &lt;code&gt;vector&lt;/code&gt; 里填充大量数据时，让它这样自己一点点增长长度的做法会非常耗时。好消息是，我们可以通过 &lt;code&gt;vector::reserve&lt;/code&gt; 提前告诉 &lt;code&gt;vector&lt;/code&gt; 我们需要大概多少的内存，以便编译器一开始就找好一个够大的地方。而且这样的机制也算是强有力地说明了 &lt;code&gt;vector&lt;/code&gt; 具有连续内存结构。&lt;/p&gt;
&lt;h2 id="在看看内存结构"&gt;在？看看内存结构
&lt;/h2&gt;&lt;p&gt;下面我们就来尝试用代码打印出 &lt;code&gt;vector&lt;/code&gt; 里元素的内存地址吧。我们向一个 &lt;code&gt;vector&lt;/code&gt; 中填充5个元素，每次填入时检查 &lt;code&gt;vector&lt;/code&gt; 的状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// We use &amp;#34;push_back&amp;#34; push an element to the back of a vector
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Added: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, Size: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, Capacity: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, Address of first element: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Check contiguity
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Contiguous memory check:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Address of v[&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;] = &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;22&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到的结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;Added: 0, Size: 1, Capacity: 1, Address of first element: 0x56041b4592b0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;Added: 1, Size: 2, Capacity: 2, Address of first element: 0x56041b4596e0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;Added: 2, Size: 3, Capacity: 4, Address of first element: 0x56041b4592b0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;Added: 3, Size: 4, Capacity: 4, Address of first element: 0x56041b4592b0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt;Added: 4, Size: 5, Capacity: 8, Address of first element: 0x56041b459700
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt;Contiguous memory check:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt;Address of v[0] = 0x56041b459700
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt;Address of v[1] = 0x56041b459704
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;Address of v[2] = 0x56041b459708
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt;Address of v[3] = 0x56041b45970c
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt;Address of v[4] = 0x56041b459710
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，在添加元素时，&lt;code&gt;vector&lt;/code&gt; 的 &lt;code&gt;size&lt;/code&gt; 指示 &lt;code&gt;vector&lt;/code&gt; 有多少的元素，而 &lt;code&gt;capacity&lt;/code&gt; 指示了 &lt;code&gt;vector&lt;/code&gt; 还有多少的空间。当空间不足时，&lt;code&gt;vector&lt;/code&gt; 的空间会扩大一倍来容纳新的元素，同时头元素的位置也会发生变化。而在元素填入结束后，通过检查地址可以发现这些元素在地址上是连续的（一个 &lt;code&gt;int&lt;/code&gt; 的大小是4，注意到使用了16进制所以 &lt;code&gt;8&lt;/code&gt; 后面是 &lt;code&gt;c&lt;/code&gt; 也就是 12，&lt;code&gt;c&lt;/code&gt; 后面就进一位因为达到了16）。&lt;/p&gt;
&lt;p&gt;这是一个很简单的小例子，但是用来说明 &lt;code&gt;vector&lt;/code&gt; 的内存结构应该已经足够。&lt;/p&gt;
&lt;h2 id="做个-benchmark-看看"&gt;做个 Benchmark 看看
&lt;/h2&gt;&lt;p&gt;也许一个简单的 Benchmark 可以展示一下 &lt;code&gt;vector&lt;/code&gt; 和传统的数组相比效率如何。下面我们初始化一个 &lt;code&gt;vector&lt;/code&gt; 和一个数组，它们有同样的大小，并且执行累加操作，最后记录累加的用时。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Benchmark vector
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;clock_t&lt;/span&gt; &lt;span class="n"&gt;start_vec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sum_vec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;sum_vec&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;clock_t&lt;/span&gt; &lt;span class="n"&gt;end_vec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Benchmark array
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;clock_t&lt;/span&gt; &lt;span class="n"&gt;start_arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;22&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sum_arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;23&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;24&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;sum_arr&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;25&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;clock_t&lt;/span&gt; &lt;span class="n"&gt;end_arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;26&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;27&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Vector sum: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sum_vec&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;28&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, Time: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end_vec&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start_vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34; ticks&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;29&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;30&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Array sum: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sum_arr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;31&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, Time: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end_arr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start_arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34; ticks&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;32&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;33&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Don&amp;#39;t forget to delete[] the array!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;34&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;35&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;36&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先不开启优化并尝试运行几次，看看结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; g++ test.cpp -o &lt;span class="nb"&gt;test&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;21530&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;16693&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;21059&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;16560&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;7&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;8&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;20729&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;9&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;15812&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们再开启 &lt;code&gt;O3&lt;/code&gt; 优化然后看看结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; g++ test.cpp -o &lt;span class="nb"&gt;test&lt;/span&gt; -O3 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;2684&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;2122&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;4091&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;3686&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;7&lt;/span&gt;&lt;span class="cl"&gt;&amp;gt; ./test
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;8&lt;/span&gt;&lt;span class="cl"&gt;Vector sum: 10000000, Time: &lt;span class="m"&gt;3205&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;9&lt;/span&gt;&lt;span class="cl"&gt;Array sum: 10000000, Time: &lt;span class="m"&gt;2813&lt;/span&gt; ticks
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看来不开启优化的时候，两个方法的差距还是比较明显的，而当开启优化之后，两种方法的差距并不大。然而，使用 &lt;code&gt;vector&lt;/code&gt; 最大的优势在于心智负担小，不用担心奇怪的内存问题，而且如果使用 &lt;code&gt;vector::at&lt;/code&gt; 方法还能自动进行边界检查，在遇到越界问题时会抛出异常，避免程序以奇怪的，错误的方式运行。&lt;/p&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;p&gt;希望这篇小短文能帮助你了解 &lt;code&gt;vector&lt;/code&gt; 的特点，或者打消你对 &lt;code&gt;vector&lt;/code&gt; 性能的顾虑。&lt;code&gt;vector&lt;/code&gt; 是用来说明 C++ &lt;strong&gt;Zero-overhead principle&lt;/strong&gt;（零成本抽象原则）的一个很好的例子。&lt;code&gt;vector&lt;/code&gt; 提供了一个动态数组的抽象，它会以最低成本来实现这个东西的特性，避免引入过多额外的性能开销，让调用者可以放心使用，不必担忧性能问题。对零成本抽象感兴趣可以查看 &lt;a class="link" href="https://en.cppreference.com/w/cpp/language/Zero-overhead_principle" target="_blank" rel="noopener"
&gt;CppReference的介绍&lt;/a&gt;，里面介绍了这一原则的具体情况。&lt;/p&gt;
&lt;p&gt;当然，每次使用新的特性，总是会引入一点点的开销。或许你会考虑，辛苦一下自己，让程序能再跑快点。这本身没什么问题，但是要指出的是，警惕提前优化。如果 &lt;code&gt;vector&lt;/code&gt; 并不是制约程序运行效率的关键部分（也就是所谓的&lt;em&gt;性能瓶颈&lt;/em&gt;），那么就先不要管它。当程序遇到了这个瓶颈，且只能通过优化数据结构才能提高性能时，再考虑把 &lt;code&gt;vector&lt;/code&gt; 修改为别的容器或者数据类型，这样做也许会更实际一些。&lt;/p&gt;
&lt;p&gt;当然，如果这个小短文有什么问题，请直接指出来。本人也不是科班出身，写这篇笔记纯粹是记录一下学习过程。欢迎交流讨论。欢迎大佬拷打，动作轻一些就更好了。&lt;/p&gt;
&lt;p&gt;那么最后，一如既往，祝您身心健康。&lt;/p&gt;</description></item><item><title>蛇年，Snake Lemma！</title><link>https://a-moment096.github.io/posts/2025/02/snake_lemma/</link><pubDate>Thu, 27 Feb 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/02/snake_lemma/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/02/snake_lemma/Post%20Shelter-Inaba%20Kumori.png" alt="Featured image of post 蛇年，Snake Lemma！" /&gt;&lt;p&gt;&lt;em&gt;看了好多证明蛇引理的视频，我也来试试~ 蛇年到了，重在参与嘛&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图出自 &lt;a class="link" href="https://twitter.com/NKNK_NGRMS" target="_blank" rel="noopener"
&gt;ぬくぬくにぎりめし&lt;/a&gt; 太太， 为 &lt;a class="link" href="https://space.bilibili.com/26040194" target="_blank" rel="noopener"
&gt;稲葉曇&lt;/a&gt; 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1jS4y1y7Yf/" target="_blank" rel="noopener"
&gt;ポストシェルター&lt;/a&gt; (Post Shelter)的曲绘。支持正版，就只有30秒试听了（）&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=1921984877" theme="#2980b9" loop="none"&gt;&lt;/meting-js&gt;
&lt;h2 id="写在最前"&gt;写在最前
&lt;/h2&gt;&lt;p&gt;本命年到啦~！作为一个代数爱好者（自称，其实是名词党），最近在B站看到了很多的关于怎么证明蛇引理（Snake Lemma）的视频，比如&lt;a class="link" href="https://www.bilibili.com/video/BV1FZFNezE6D" target="_blank" rel="noopener"
&gt;这个视频&lt;/a&gt;。以前在自学代数的时候也遇到过这么个引理，但是看到这个部分的时候已经人快晕了（大概就是看完这个之后就抛弃了那本书吧，&lt;em&gt;Algebra: Chapter 0&lt;/em&gt;），所以几乎等于没学过。这次看到这么多关于蛇引理的视频，自然是学习一下，这里也做一个记录吧。在本文中你将看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你在说些什么？&lt;/li&gt;
&lt;li&gt;这么简单的前置竟然也要？&lt;/li&gt;
&lt;li&gt;你这里跳步了吧？&lt;/li&gt;
&lt;li&gt;就算我证的不好，我证的很搞笑也不行吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之类的高血压时刻。为了您的身心健康，如果你打算认真了解蛇引理的话，我还是不建议你深究这篇文章。当然，如果你是找乐子的话，我希望这篇文章能带给大家笑容。这篇文章的面向读者应该对最基础的代数有了解，比如集合啊，函数啊之类的，如果会线性代数就更好了，别的东西会中途提到，毕竟是名词党写的文章，当然起点会很低的吧（笑）。话不多说，开始吧。&lt;/p&gt;
$$
\gdef\Ker{\operatorname{Ker}}
\gdef\Coker{\operatorname{Coker}}
\gdef\Img{\operatorname{Im}}
$$&lt;h2 id="简单介绍"&gt;简单（？）介绍
&lt;/h2&gt;&lt;p&gt;蛇引理究竟是什么呢？这是一个代数学定理，简单来讲，它做的事情和很多代数学定理一样：从已有的两个东西来创造出新的东西。比如，如果我们有一个集合以及集合上的等价类/等价关系，我们就可以构建出来一个商集；给定一个群以及它的正规子群，我们就可以构建出商群；把两个空间 $\mathbb{R}$ 叉乘起来（笛卡尔积），我们就得到了 $\mathbb{R}^2$。&lt;/p&gt;
&lt;p&gt;那么蛇引理是针对什么样的代数对象呢？这里就要尝试引入我们的第一个概念：正合列 (Exact Sequence)&lt;/p&gt;
&lt;h3 id="正合列但是先别急"&gt;正合列，但是先别急
&lt;/h3&gt;&lt;p&gt;正合列，同调代数中的重要对象，是由链复型添以特殊的条件而产生的。链复型又是什么？链复型是一系列的交换群或者模通过同态连接起来，且相邻两个同态的复合为0。&lt;/p&gt;
&lt;p&gt;也许你要说：天哪你在说什么鬼东西，这都是啥啥啥呀。既然我们假定读者只拥有最基础的代数知识，我们就从最基础的开始介绍吧。名词党最喜欢的名词介绍环节，启动！&lt;/p&gt;
&lt;h4 id="群交换群"&gt;群，交换群
&lt;/h4&gt;&lt;p&gt;上面说链复型是由交换群或者模带上同态构成的，为了简单，我们就不介绍模 (Module) 了，专注于交换群。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;但是模是什么？我要看口牙！&lt;/summary&gt;如果有人讲模之类的话，可以认为就是一个差一点的线性空间，它就差在标量不再是数域中的元素了，而是环 (Ring) ，一种乘法可能没有逆元的神奇代数结构，里面的元素。这里指出，环想要变成域（有的地方管域叫体，英文都是 Field）的话只需要让环满足交换律，并且它的每个非 0 元素都有乘法逆元就好了。&lt;/details&gt;
&lt;p&gt;那么交换群，或者从头来讲，群，又是什么呢？有人会讲：群就是对称！有对称，就有群！挺好的，但是对称这种几何元素偏偏要符号化成群元素，这一步我倒是走了蛮久的。我们速通嘛，就说简单一点，尽可能地不丧失严谨性吧。群 (Group)，最为代数学中几乎是最基础的代数结构，和其余的许许多多数不清的代数结构类似，遵循这样的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从集合而来。它的 “底下” 一定是一个集合。这样我们就可以讨论这个代数对象中的元素了。&lt;/li&gt;
&lt;li&gt;它的内部有一个或者多个 “运算”。我们可以想象我们早已熟悉的乘法。既然是运算，我们对这么个东西有这样的要求：
&lt;ol&gt;
&lt;li&gt;首先运算是两个元素同时参与的。相乘的总是（起码）两个数。注意不一定非得是不一样的数哦。&lt;/li&gt;
&lt;li&gt;两个元素经过运算之后应该得到一个元素。两个数相乘之后给出的也是一个数字。&lt;/li&gt;
&lt;li&gt;这点不太明显，但是我们的运算总是应该从这个集合来，到这个集合里去。比如 $1\times 1\neq\mathrm{苹果}$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就可以有一个（很基础的一些）代数结构啦。而我们的群，也正是这样的一个代数结构。不过它还有这样的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;群的运算必须要是可以结合的。这意味着如果 $abc \neq (ab)c \neq a(bc)$，那它就不是群。（天啊真的有这样的神经结构吗）&lt;/li&gt;
&lt;li&gt;群的运算&lt;strong&gt;不需要&lt;/strong&gt;是交换的。其实不交换的东西很常见，例如我们要先穿袜子再穿鞋，这肯定和光脚穿鞋后再套个袜子是不一样的啦。学过线性代数的朋友应该更有体会：矩阵乘法是不交换的。&lt;/li&gt;
&lt;li&gt;群得有单位元。何谓单位元？这不是元素吗？这里的单位元是和运算强相关的，说的就是群里的任何元素和这个单位元做运算之后一定得到的是它们自己。&lt;/li&gt;
&lt;li&gt;群中元素都得有逆元。没错，这里逆元的概念也是和运算相关的。所谓 “逆”，就是要把一个元素 “逆转” 回单位元。可以想象单位元就是某个出发的位置，每个元素都代表着某个让你移动的方式。而某个元素对应的逆元，就像你移动之后让你移动回原点的移动方式。能走出去，也得能走回来。就是这样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实上面的这些内容，经过一些整理的话就可以变成比较严格的群的定义了。然而严格定义谁都能查，这里也就偷个懒啦~ 这里指的指出的是，群上的运算我们一般就叫它乘法。而且在代数的语境下，很多运算我们都叫它乘法！所以在讨论代数结构中的乘法时要注意上下文哦~&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;所以群的对称意义究竟在哪？&lt;/summary&gt;
&lt;p&gt;我们讲，集合中的元素位置其实是无所谓的，比如集合 $\{1,2\}$ 和集合 $\{2,1\}$ 是一模一样的。那么，群的对称的意义，就在于群中的元素有两重含义：集合内的一个小不点，以及代表了如何操作这个集合的一个符号。&lt;/p&gt;
&lt;p&gt;我们提到过，群的运算是需要满足上面一大堆条件的。这些条件指向了这样的一个神奇的结果：两个群中的元素相乘，我们可以有意识地将其中一个元素作为操作方式，将另一个元素看作群中茫茫多（或者很少，也许）元素中的某个元素。而这样的运算结果又是群中的某一个元素。&lt;/p&gt;
&lt;p&gt;然后我们再想象这样一副图景：桌子上有一副扑克牌，每一张都分开放，放的很整齐。现在你尝试把这些扑克牌重新排列，这个排列方式取决于你开始重排前看到的第一张牌。在重新排列时，你肯定需要一张一张地取，取到之后会根据你看到的第一张牌来思考应该把它放在哪里，最后你就把它放在了对应的位置。在重复54遍 “取-看-放” 的过程之后，你会惊奇地发现：天哪，竟然又得到了一副扑克牌（？）&lt;/p&gt;
&lt;p&gt;你可能觉得这个发现很无聊，但是这就是对称：在某种操作下又回到自身了。你也许会说：不！位置变了！但是还记得吗？集合中元素位置是无关紧要的。我们这里其实就是在讲群对自身的作用。那么群可以对别的集合进行作用吗？当然！只要某个作用方式满足群的条件，也就是说如果你先做了一个操作，又做了另一个操作（这样就操作两次了，对应群中的两个元素相乘）这俩操作实际上也是你可取操作的一种（群中元素运算后依旧在群里），以及别的条条框框，那么实际上你就是在对这个集合进行着群作用。&lt;/p&gt;
&lt;p&gt;群中蕴含的对称，不在于群自己，而在于它能操作的对象。笨笨的我花了好久才明白这个道理 QAQ。&lt;/p&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;p&gt;太棒了！群是什么，已经狠狠地理解了！那么交换群？诶！交换群一定是运算能满足交换律了吧！&lt;/p&gt;
&lt;p&gt;是的，答案就是这么简单，且无聊。交换群 (Commutative Group，又称阿贝尔群 Abelian group，为了纪念伟大的挪威代数学家阿贝尔)，就是能交换 (Commutativity) 的群 (Group)。你也许会对交换群感到失望，但是代数岂是如此无聊之物！？这一切的原因，其实是：我们还没有引入同态 (Homomorphism)。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;交换群和普通群还是有区别的吧？&lt;/summary&gt;
&lt;p&gt;当给一个普通的群赋予交换性时，它身上所多出来的性质远不止交换性这一条。交换性赋予群的不止表面看起来的两个元素可以交换，更重要的是，给交换群内的结构更加严格的限制。比如后面会提到的，交换群的子群全都是正规子群，因此对于任何一个交换群的子群，都可以用来被模除掉而形成一个子群。&lt;/p&gt;
&lt;p&gt;交换群太特殊了，以至于人们给它划定了一个特别的范畴：阿贝尔范畴（Abelian Category）。事实上，交换群甚至子集就是一个模（也就是我们在介绍蛇引理时一开始所提到的那个代数结构）。然而我们这里不计划过多地介绍交换群有多么特别，而是将目光放在交换群上面所定义的运算。更具体地说，是交换群上面定义的运算的符号，以及相关的记号。&lt;/p&gt;
&lt;p&gt;我们前面提到，群里定义的运算被称为 “乘法”。这是个很有趣的名字：为什么我们叫它乘法？我们熟悉的乘法，比如在 $\mathbb{R}$ 上的乘法，也就是实数乘法，或者在线性代数里我们知道的矩阵乘法，和这里的 “群乘法” 之间有什么样的关系呢？我们指出：实数在作为集合的条件下，赋予我们已经熟悉的乘法后，得到的就是一个群；而线性代数中的矩阵乘法，在将所有的 $n\times{n}$ 方阵看作一个集合时，赋予矩阵乘法后也能形成一个群。&lt;/p&gt;
&lt;p&gt;然而实数乘法和矩阵乘法是有区别的：实数乘法满足交换律，而一般的矩阵乘法并不满足交换律。因此，实数乘法实际上构成了交换群。不过由此我们也可以看到，无论是否满足交换律，我们经常给这样满足若干条件的运算起一个 “乘法” 的名字。这也是群运算一般被称为 “乘法” 的原因。&lt;/p&gt;
&lt;p&gt;但是，不论是实数，还是矩阵，甚至所整数集合、向量等等，它们都有这样的一个运算，我们更加熟悉，且常常称之为 “加法”。这些运算和乘法相比有什么样的特点呢？它们中的一些，在不谈所谓 “交换律” 时，其实和乘法是类似的。然而，在考虑矩阵的加法和乘法时，区别立马就显现了出来：&lt;em&gt;矩阵的加法是满足交换律的，而乘法不满足交换律&lt;/em&gt;。那么我们就这样规定：一般群（或者不满足交换律的群）的运算就称为乘法，而交换群上的运算则称为加法。从记号上来看，我们这里做一个小表格，方便更直接的对比。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center"&gt;项目&lt;/th&gt;
&lt;th style="text-align: center"&gt;一般群&lt;/th&gt;
&lt;th style="text-align: center"&gt;交换群&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;运算&lt;/td&gt;
&lt;td style="text-align: center"&gt;乘法&lt;/td&gt;
&lt;td style="text-align: center"&gt;加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;记号&lt;/td&gt;
&lt;td style="text-align: center"&gt;ab&lt;/td&gt;
&lt;td style="text-align: center"&gt;a+b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;左陪集&lt;/td&gt;
&lt;td style="text-align: center"&gt;aH&lt;/td&gt;
&lt;td style="text-align: center"&gt;a+H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;单位元&lt;/td&gt;
&lt;td style="text-align: center"&gt;1&lt;/td&gt;
&lt;td style="text-align: center"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;交换律&lt;/td&gt;
&lt;td style="text-align: center"&gt;不满足&lt;/td&gt;
&lt;td style="text-align: center"&gt;满足&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里要提出的是，上面的区别在不考虑交换性的情况下，仅仅是记号的区别。事实上，如果你愿意，完全也可以使用乘法记号，不过这就需要在文中特别标注出来就是了。&lt;/p&gt;
&lt;p&gt;最后，这里引出这样一个观点：抽象代数，如研究群、环、域、模的代数结构性质的这些内容，在理解这些代数结构的过程中，最好的例子有两个：一是整数极其衍生结构；二是线性空间以及其上面的矩阵。当然，只是私货而已，如果有什么问题还请见谅。&lt;/p&gt;
&lt;/details&gt;
&lt;h4 id="同态同构等价关系"&gt;同态，同构，等价关系
&lt;/h4&gt;&lt;p&gt;首先，代数中［Homo-］的词头其实很常见（？）。这是代表着两个东西之间一定有什么相同的地方。而同态，正是指出了两个代数结构之间相同之处的东西。请注意这里用到的是 &lt;em&gt;代数结构&lt;/em&gt; 而非 &lt;em&gt;群&lt;/em&gt; 或者 &lt;em&gt;交换群&lt;/em&gt;。同态广泛地存在于代数学中，到处都是同态。那么同态是什么呢？其实你早就见过了。对于 &lt;em&gt;集合&lt;/em&gt; 这个最基础的代数结构而言，同态就是 &lt;em&gt;函数&lt;/em&gt;，或者说 &lt;em&gt;映射&lt;/em&gt;&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;。既然函数是对于集合而言特殊的同态，那么对于群而言，特殊的同态是什么呢？很可惜，没有一个特别的名字，或者大家就直接叫群同态了。然而群同态确实是有其特殊之处的。我们稍后再细讲这种特殊点在哪，以及何来的“同”一字。&lt;/p&gt;
&lt;p&gt;回忆我们很熟悉的集合上的函数，它有这样的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数必须要有定义域，它是一个 &lt;em&gt;集合&lt;/em&gt;，且这个集合里的每个元素都能被函数处理（作用）。不能说有个定义域的元素不能被函数吃掉，那就礼崩乐坏了。函数是不会剩饭的。&lt;/li&gt;
&lt;li&gt;函数必须要有陪域。他也是一个 &lt;em&gt;集合&lt;/em&gt;。请注意这里不是说不是值域，而是陪域。值域是函数能吐出来的东西组成的集合，而陪域则是函数吐出来的东西一定会存在的集合。所以，很自然的，会有一些陪域上的元素不会有任何定义域上的元素去对应。&lt;/li&gt;
&lt;li&gt;定义域中的每个元素 &lt;em&gt;能且只能&lt;/em&gt; 对应陪域上的一个元素，而陪域上的元素可以有0个，1个或者很多个定义域上的元素对应。这就像投篮，球可以投不中，可以一个球一个框，也可以很多球进一个大框里，但是不能一个球同时进两个框。&lt;/li&gt;
&lt;li&gt;判断两个函数是否相等（没错，函数作为数学对象是可以判断是否与另一个相等的）的铁则是：定义域相同，陪域相同，定义域上的每个元素通过两个函数作用后得到的结果总是一样的。也就是说，要检测函数的三个要素都是一样的。表达式也许会骗人，但 &lt;em&gt;函数的定义&lt;/em&gt; 永远是诚实的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;天啊我怎么又讲了一遍函数是什么？原因是：函数，作为同态的一个例子，自然就包括了同态的许多特点。然而同态还有一个重要的特性，也是被冠以 “同” 字的原因：同态必须保持结构！我们没有在集合中看到这样的特点，是因为集合里什么结构都没有。也许有人说：集合里的元素都是有名字的呀？什么 1 啊 2 啊的，这不就有结构那样的东西了嘛。这里要明确的是：集合里这些看似特殊的元素，它们的特殊性全都源自于我们为了能区分它们所给的，甚至就是为了能数清楚这些元素，不至于把它们搞混。So，集合真的很单纯，它上面的结构都是后面赋予的。当然，你也可以说 “没有结构” 也是一种结构，因为 &lt;em&gt;函数不会把集合变成别的什么不是集合的东西&lt;/em&gt;，保持了 “没有结构” 的特点（结构）。&lt;/p&gt;
&lt;p&gt;哦，好，但是说了一圈，到底怎么保持结构？群同态到底是什么样的？观察上面函数的特点，我们提炼一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同态要有来有去，且来去都是同一类东西，不能来去之后东西不一样了。这说明 &lt;em&gt;同态不会给对象添加或删去任何结构&lt;/em&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;就是说，群同态只能连接两个群。或者，&lt;em&gt;一个群上如果作用了一个群同态，那么它就必须给出一个群&lt;/em&gt;。这点对于其他所有的代数结构都是一样的。&lt;/p&gt;
&lt;p&gt;还是一头雾水？是不是觉得随便哪个集合上的函数都能在集合变身成函数后也跟着变成同态？没关系，就群同态而言，我们其实可以写出群同态需要满足的特点（多亏了运算的存在）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有两个群 $G$ 和 $H$，它们之间有个从 $G$ 到 $H$ 的群同态 $\varphi$。我们记群 $G$ 的运算为 $\times_G$，记群 $H$ 的运算为 $\times_H$，群 $G$ 中有俩元素 $g_1$ 和 $g_2$。这样一来，由于 $\varphi$ 是群同态，有：&lt;/p&gt;
$$\varphi(g_1 \times_G g_2) = \varphi(g_1) \times_H \varphi(g_2)$$&lt;/blockquote&gt;
&lt;p&gt;而且它有一个很神奇且重要的特点：群同态只能把一个群的单位元映射到另一个群的单位元。这点乍看很神奇甚至不可思议，但是经过简单的证明就可以得到这样的结论了。这也是为了保持群的结构而对群同态做出的一个很强的限制。这也说明了，代数结构越是复杂，同态的限制就会越大。&lt;/p&gt;
&lt;p&gt;最后我们讲一种特殊的同态（或者态射，我们这里不区分两者，后面在范畴部分会做出说明），它需要有一个态射作为基础。我们设有这样的一个态射 $f:\\,A\to B$，且在 $A$ 中有一个保持原有 $A$ 结构的子结构 $A'$，在集合层次上则为包含关系。此时我们就可以定义所谓的 &lt;em&gt;限制&lt;/em&gt; （Restrict），就是把定义域从 $A$ 换到了其子结构 $A'$ 上而已。它的记号为：$f|:\\, A'\to B$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们接下来介绍同构 (Isomorphism)。它在集合函数中的对应就是所谓的一一对应函数了。回忆所谓的单射和满射，单射说一个萝卜一个坑，满射说值域就是陪域。而同时满足这两个条件的话，这个函数就是一一对应的函数啦。我们立刻使用一些新词来讲这些事情，因为函数（映射）是集合间的同态嘛。&lt;/p&gt;
&lt;p&gt;同态中有单态 (Monomorphism)，也有满态 (Epimorphism)。而同时满足这两点的，即为所谓的同构了。它们的要求和集合函数是一模一样的。然而还有别的定义方法，使用态射的逆（啊没错它们都是态射但是这就留到范畴论再说吧）即可定义同态的单或满。回忆之前学过的逆函数这一存在，一个函数的逆函数再作用到函数的话就会变成恒同映射（把一个元素映射到它自己）。这是一种双边逆，更常见的情况则是一个态射只有左逆或者只有右逆。&lt;em&gt;我们称有左逆的态射为单态，有右逆的态射为满态，有双边逆的则为同构&lt;/em&gt;。这个我们不证，有兴趣可以挑一些例子看看。请把重点放在 “能不能找到原来的元素” 以及 “如果能找到原来的元素，那么一定会如何”，并注意函数的复合是从右到左的。&lt;/p&gt;
&lt;p&gt;这里顺带提出原像（Inverse image）的概念。原像是和某一个陪域中的元素，以及一个态射相关的。它本身是一个集合，记录了所经过该态射后能得到该陪域中元素的所有定义域中的元素。它的记号以及形式化的表达是：若存在一态射 $f\vcentcolon\space A\to B$ 以及 $b\in B$，则 $b$ 在 $f$ 下的原像记为 $f^{-1}$，定义为：&lt;/p&gt;
$$
f^{-1}\vcentcolon=\left\{\space a \space \vert\space\forall a \in A, f(a) = b\space\right\}.
$$&lt;p&gt;那么这样一来，单态则是所有陪域上元素的原像只能是空的或者只能有一个元素的态射，而满态则是所有陪域上的元素都有非空原像的态射。利用这个概念，同构还可以定义为所有陪域上元素的原像有且只有唯一一个元素的态射。&lt;/p&gt;
&lt;p&gt;同构从字面意思来理解，是 “保持结构” 的映射。可是之前还说同态是保持结构的映射，这两个区别在哪里？事实上，同构比同态要求高多了。同构要求的是 “构造完全相同”，而同态则只要求 “是同一类东西，不会多结构，也不会丢结构”，却可以修改这个结构。比如，同态可以让一个大群变成一个小群，搞得里面的每个元素以前有更丰富的运算结果，结果到了小群里好多元素被捏在一起了，这些丰富的结果也就没了。而同构会很严格地将一个群变成另一个大小一模一样的群，它们结构的丰富程度或者精细程度是一模一样的。在只关心群这个整体以及它怎么与其他群发生转变，完全不关心群内部元素有什么特别之处时，我们可以说，&lt;em&gt;同构的两个群，它们在同构意义下可以被视作是相同的&lt;/em&gt;。顺带一提，集合的同构就是映射到元素个数相同（集合的势相等）的另一个集合。这也是个大坑，感兴趣可以搜 Schröder–Bernstein 定理或者伯恩斯坦定理。&lt;/p&gt;
&lt;p&gt;对于群而言，群的同态会把群的一个或几个元素捏在一起形成新群的一个元素。同态是创造新群的一个重要方式。但是假如我们考虑 &lt;em&gt;把几个元素捏在一起形成一个新的元素&lt;/em&gt; 实际上意味着 &lt;em&gt;对原来的群中的元素进行分类&lt;/em&gt;，那我们就会形成很有趣的结构，商群 (Quotient Group)。我们不会深入这部分，但是这个思想是极其重要的，因此我们需要介绍另一个概念：等价关系与等价类。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;小学数学，甚至幼儿园数学，经常会遇到这样的题目：把一堆苹果分成若干份，每份有几个苹果；把苹果平均分成若干份，最后剩下几个苹果。这样的题目是为了让孩子熟悉除法，而我们这里则要指出，这就是除法，或者所谓的 “商” 所代表的含义。而我们在分苹果时所做的事情，就是在对苹果分类。&lt;/p&gt;
&lt;p&gt;我们要如何进行分类呢？特别是对一堆苹果而言，分成堆时我们做了什么？也许我们有某个标准，也许就是简单的 “我乐意”，但分成堆的过程中每个苹果最终都有属于自己的一堆。假如我们要分成三堆，那么我们完全有理由将三堆起不同的名字，比如：科比，牢大，曼巴。这样一来，每个苹果就都有了一个属性，一个标签。而苹果之间有什么关系吗？有的。我们观察同一堆的苹果，如牢大这堆，会发现这样的（显而易见）的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个属于牢大的苹果，那么他就属于牢大（？）&lt;/li&gt;
&lt;li&gt;如果一个苹果在牢大里，另一个苹果也在牢大里，那么它们俩就都在牢大里，不论进入牢大这堆的顺序&lt;/li&gt;
&lt;li&gt;如果苹果A和苹果B都在牢大里，苹果B和苹果C也在牢大里，那么苹果A和苹果C就一定在牢大这里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不论分类手法如何，不管分类标准怎么样，上面这三条总是成立的。而在分好之后，对任何人都可以只宣称这堆苹果属于哪一堆，不用管它具体怎么样了。有人问这个苹果是哪个，都可以回答这个苹果是从科比或者牢大或者曼巴这堆里取出来的。&lt;/p&gt;
&lt;p&gt;还是一头雾水？上面的例子是想说明这样的一件事：只要你选了，那就会形成一个标准，这个标准内的每个成员都会接受这样的束缚，而这个约束是有 &lt;em&gt;自反性&lt;/em&gt;，&lt;em&gt;反身性&lt;/em&gt; 和 &lt;em&gt;传递性&lt;/em&gt;的。这些性质就刻画了一个 “关系”，称为 &lt;em&gt;等价关系&lt;/em&gt;。我们刚刚用分好的类来说明这类关系一定存在，而反过来讲，根据这样的关系，也一定能进行这样的分类。最后分出来的 “每一堆”，我们就称为等价类。&lt;/p&gt;
&lt;p&gt;分类是代数学中另一个极为重要的话题。有一些出色，重要且惊艳的研究正是建立在这样的分类问题上的，比如传说中的 &lt;em&gt;有限单群分类&lt;/em&gt;，洋洋洒洒几千字的论文将整个单群分类问题整的明明白白。分类如此重要的原因还在于帮助我们创造新的代数结构，也就是所谓的 &lt;em&gt;商&lt;/em&gt;。比如使用同态对群进行划分则会涉及著名的 &lt;em&gt;群同构基本定理&lt;/em&gt;，描述了用同态下的等价关系创造出的商群有什么样的信息。&lt;/p&gt;
&lt;p&gt;我们这里先不深入介绍商群，因为它将涉及到子群 (Subgroup)，陪集 (Coset)，正规子群 (Normal subgroup) 等概念，太啰唆了。这里只指出商群的记号为 $G/H$，其中 $G$ 和 $H$ 都是群，且 $H$ 是 $G$ 的正规子群。这个商群的元素是这样的：每个元素都是一个集合，这个集合内是群 $G$ 中的元素，并且这些群 $G$ 中的元素都相互等价，而这个等价关系则由群 $H$ 这样确定：元素 $a$ 和 $b$ 等价由 $a^{-1}b \in H$ 决定。换句话说，我们根据群 $H$ 制定了元素的分类标准，把分好类后的每个 “元素堆” 作为商群中的每个元素。能分多少堆，商群就有多少个元素。&lt;/p&gt;
&lt;p&gt;要注意的是由于等价关系，商群中每个元素（也就是 $G$ 中元素的集合）里都可以选出唯一的一个 $G$ 中元素来代表。那么既然如此，我们就使用在代表元的头顶加个尖尖的东西来代表这个集合了。比如有一个等价类 $A$ 中有一个元素 $a$，此时我们就可以用这个元素 $a$ 来代表这个等价类 $A$：$\hat{a} = A$。这个记号还是比较重要的，所以这里提前介绍一下。&lt;/p&gt;
&lt;p&gt;太棒啦！感觉智慧满大脑了~ 但是这么多前置了，和蛇引理有关系吗？还有多少前置需要呢？答案令人振奋呀：还有一节就好了！我们已经明白了同态是什么样的，交换群又是啥，商群里的元素怎么确定，有什么样的特点。我们只需要再看一看最后两个和同态有千丝万缕联系，作为 “群同构基本定理” 中的 C 位的两个特殊的代数对象，核 (Kernel) 与像 (Image)，就可以开始一窥蛇引理的神秘了~。&lt;/p&gt;
&lt;h4 id="核与像"&gt;核与像
&lt;/h4&gt;&lt;p&gt;核的概念其实很简单，它高度依赖于同态，本身是一个特殊的集合（我们先看它单纯的集合结构）。它是同态的定义域上所有能被对应到陪域的 &lt;em&gt;零元素&lt;/em&gt; 的元素，记号为 $\Ker$。假设有某个同态 $\phi$，那么在这个同态下的核就记为 $\Ker\phi$。这里的零元素应该是代数结构中普遍存在的单位元，而称为零元素的主要原因是因为对我们即将研究的许多代数结构而言，它们上面的结构实际上是交换的。交换的运算我们会叫它们 &lt;em&gt;加法&lt;/em&gt;。而我们熟悉的加法的单位元就是 $0$。&lt;/p&gt;
&lt;p&gt;我们上面只说了核底下依赖的集合是怎样选取的，然而由于同态的性质，核上经常都会有额外的代数结构。这一点很容易确定：对群而言，单位元自己本身就是一个平凡群，其上的唯一运算就是单位元和单位元进行运算之后得到单位元自己。那么既然单位元是一个群，由同态的要求，我们马上就可以得知，群同态的核很自然地就拥有群结构。不但如此，我们在此不加说明地断言：群同态的核总是群的定义域的一个正规子群！而有了正规子群，我们马上就可以讨论定义域的群商去这个同态的核所得到的商群了。事实上，群同构基本定理中就和同态的核关系非常密切，且经常使用核来构造商群。&lt;/p&gt;
&lt;p&gt;对于核而言，我们还想提到这三点：首先核一定是依赖于某个同态的，没有同态是没有办法讨论核的。从它的记号就可以看出，我们选择使用 $\Ker$ 记录同态的符号而非其定义域，然而也请切记核作为集合而言一定是定义域的子集。&lt;/p&gt;
&lt;p&gt;其次想要提到的是核在 &lt;em&gt;同调代数&lt;/em&gt; （也许也不是？）中的意义：核衡量了同态的性质，告诉了我们一个同态距离单态究竟有多远。这是由于这样的定理：&lt;em&gt;核中的元素只有一个（也就是单位元）当且仅当同态是单态&lt;/em&gt;。那么如果核越大，同态距离单态就越远了；核越小，同态就越像单态。&lt;/p&gt;
&lt;p&gt;最后一点也许会复杂一些，我们想提到的是：群同态的核由于一定是正规子群，而正规子群又一定能够被商掉。考虑我们上面提过的构造商结构的过程：被商的集合/结构是作为一个选择方式出现，而这个选择方式就是这个结构中的所有元素都被视为同一个元素。我们进行这样的猜测：这样用核来构造的商群中的元素，每个元素都是一个集合，而这些集合与核是相似的：它们都有同样的大小。幸运的是这样的猜测是成立的。最后也不卖关子了：商群中的元素就是正规子群的陪集，而每个陪集的大小都是相等的。所谓的陪集就是把群里面的子群用某个元素乘一下（移动一下）。这里说 “集” 有两个层面，一是我们不计划赋予它别的结构，他们就作为集合存在于商群；二是我们没法赋予群结构，除了最平凡的那个正规子群。更一般的陪集是没有办法满足单位元要求以及逆元要求的。&lt;/p&gt;
&lt;p&gt;核真的很重要，所以我们聊了许多。不过这主要是由于核与商群之间重要的联系。有了这样的铺垫，我们理解像将会更迅速：像也是一个子群，但不是更特殊的正规子群。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;像我们早就熟悉了，就集合层面而言，就是值域 “更代数”的一个名字。而同样由于同态的存在，像也一定是一个群。但是不同于核，像并不总是正规子群。这真是一个悲伤的故事，我们不能再愉快地构造商群了。也许你之前幻想着，既然核可以衡量同态与单态的距离，是不是像也可以衡量同态与满态的距离呢？因为很显然可以看到，像越大越可能是满态，像与陪域相同那就是满态了。然而很可惜，我们不用这种方式。&lt;/p&gt;
&lt;p&gt;但是我们有三个好消息：第一条是，虽然像不是个正规子群，但是我们依旧可以用像构造商结构！第二条则是，虽然像不能衡量同态的信息，但是它构造的商结构可以！我们还给它一个特别的名字：余核 (Cokernel)。第三条则是，我们其实要研究的是交换群，而对交换群而言，所有的子群都是正规子群的！这样一来，前面讲的商结构也就可以是商群啦。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;子群，商群，陪集，商结构，到底是怎么回事？&lt;/summary&gt;
&lt;p&gt;在讲商群时，终究还是无法避免陪集的概念。陪集和商群之间到底是什么样的关系？陪集之间又有什么样的联系？陪集到底是什么样子的东西？&lt;em&gt;商&lt;/em&gt; 究竟是什么？我们讲了这么久的子群，正规子群，它们到底都是啥？这里我们斗胆写一写吧。&lt;/p&gt;
&lt;p&gt;先看看子群吧，其实子群的概念很简单：一个群的子群，实际上就是子集加上原群的运算。这样一来，子群的单位元一定就是原群的单位元，而子群的运算就是原群的运算了。这个还是相对比较简单的一个概念，麻烦的是所谓的正规子群。而为了讨论正规子群，必须要讨论所谓的陪集。我们把陪集往后放一放，先讲商群中的元素们：陪集。&lt;/p&gt;
&lt;p&gt;我们已经提到，商群就是对群按照其正规子群的需求进行分类从而得到的一个更小的群。这个更小的群里面是一个个的陪集，我们讲陪集中的元素都是相互等价的，因此，这个更小的群里的元素虽然都是集合，但是完全可以从每个集合中取一个元素来代表这个集合（由于等价关系），这个元素就被称为代表元。所以你可能会见到商群中的元素是用一个个原群中的元素带上标记构成的。但是还请记住，商群中的元素始终都是集合，也就是陪集。&lt;/p&gt;
&lt;p&gt;我们再谈谈陪集。陪集是这样一个集合：它必须依赖一个群里的元素，以及这个群的一个子群。我们记较大的群为 $G$，它的子群为 $H$。那么我们取 $G$ 中的一个元素 $g$ 之后，再和子群 $H$结合一下，就得到了所谓的陪集了。具体是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;还是先提醒：$H$ 是住在 $G$ 里面的，它们拥有一模一样的运算，所以 $G$ 中的元素是完全可以与 $H$ 中的元素运算的。&lt;/li&gt;
&lt;li&gt;我们从群 $G$ 中取出一个元素 $g$。这个元素是任意的，只要在 $G$ 里就好。然后还要把 $H$ 中的元素一个一个地取出来，准备进行运算。我们要取出所有 $H$ 中的元素，不遗漏不重复。&lt;/li&gt;
&lt;li&gt;用 $g$ 和 $H$ 中的元素依次进行运算。在做运算时，我们先把 $g$ 放在 $H$ 中元素的左边。最后得到的结果放在一个篮子里（或者框里，也可以）。&lt;/li&gt;
&lt;li&gt;最后检查这个框子，我们给它贴上标签：$gH$。这个框就是我们想要的陪集，准确地说是 $H$ 在 $G$ 中元素 $g$ 作用下的 &lt;em&gt;左&lt;/em&gt; 陪集。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自此，我们便成功得到了一个左陪集。如果在进行运算时将 $g$ 放在 $H$ 的右边，则称之为右陪集，记号也变为 $Hg$。注意到陪集中的元素一定是在 $G$ 中的元素，我们自然好奇：陪集内元素有什么样的特点呢？我们回顾上面的内容：陪集内元素相互等价，等价关系为 $a^{-1}b \in H$。我们来看看是怎么回事。我们更多地关注左陪集，右陪集是类似的思路。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：$a^{-1}b \in H$ 当且仅当 a 与 b 等价，亦即 $aH = bH$。&lt;/p&gt;
&lt;p&gt;首先，$a$ 与 $b$ 都一定属于各自的陪集，因为 $H$ 是一个群，群里有单位元，则陪集 $aH$ 中肯定有 $a$，$bH$ 中也肯定有 $b$。&lt;/p&gt;
&lt;p&gt;既然 $a^{-1}b \in H$，那肯定就有一个元素 $h$ 就是 $a^{-1}b$。由于乘法逆元的性质，我们给两边左乘 $a$，就有了 $b = ah$。回忆 $H$ 在 $a$ 的左陪集的定义，这就说明了：$b$ 也是 $aH$ 中的元素。&lt;/p&gt;
&lt;p&gt;此时我们想到，既然 $H$ 是一个群，$h$ 在 $H$ 里了，那 $h^{-1}$ 也肯定在里面。我们就给 $b=ah$ 的右边同时乘以 $h^{-1}$，就有得到了：$a=bh^{-1}$。这同时也说明了 $a$ 也是 $bH$ 中的元素。这样一来，我们就证明了 $aH = bH$，因为我们的 $a$, $b$ 是任意选择的 $G$ 中元素，这样的任意性保证了不会选取特殊的点。&lt;/p&gt;
&lt;p&gt;其次，当 $aH = bH$ 时，有这样的情况：$a$ 与 $b$ 相等，则结论自然；若是 $a$ 与 $b$ 不相等，这时由于群乘法的封闭性，一定要有一个 $h$ 满足这样的关系：$ah = b$。现在我们视线移向群 $G$ 后，便可以同时左乘 $a^{-1}$，这时就得到了我们想要的结论。至此，我们证明了这样的选择方式确实是构成了一个等价关系。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;最后我们关注陪集间的关系：左陪集是不一定等于右陪集的。这点如果能恒成立的话，那么这个群 $H$ 就一定是一个正规子群。另外，群 $H$ 的所有左陪集都有同样的大小。这一点的理由是：左乘群 $g$ 中的元素这个动作总是可逆的，再左乘回 $g^{-1}$ 就可以了。这样一来，左乘 $g$ 就实际形成了一个集合间的双射，也就是所谓的同构。它保证了元素个数相同。也正因如此，用左乘 $a$ 定义的 $H \to aH$ 就保证了 $H$ 与 $aH$ 的元素个数相同了。由于 $g$ 是任意选取的，所以任意的左陪集都有相同个数的元素了。这个结论对右陪集而言也是显而易见的。&lt;/p&gt;
&lt;p&gt;另外我们提一下记号的问题。对于使用乘法记号的群而言，由于我们的子群本身就是一个群，所以一定有一个单位元。而根据左陪集的形态，我们就知道了：每个左陪集中一定有一个元素，这个元素就是子群 $H$ 的单位元乘上我们左陪集所左乘的元素。简单来说，如果有一个左陪集 $gH$，那么这个左陪集里面就一定有一个元素 $g 1_H$。而既然左陪集中每个元素之间都是等价的，我们很自然地就可以使用这个元素来代表这个左陪集。至于记号，我们上面已经介绍了：$\hat{g}$ 就可以代表 $gH$。诶？那假如我用单位元去左乘以这个子群，得到的就是？没错，就是子群本身形成的陪集。而这个特殊的陪集在我们下面定义的商群乘法下自然就是我们需要的单位元了。&lt;/p&gt;
&lt;p&gt;我们定义正规子群为左陪集等于右陪集的子群。在这个定义下，很明显就可以看出，满足交换律的交换群里没有不正规的子群了，因为很轻易地就得到了左陪集等于右陪集，只需要把交换律下放到陪集内元素的计算过程中即可得到。那么对于交换群/阿贝尔群而言，陪集的记号是什么样的呢？我们很轻易就可以类比出来：既然乘法记号的群是用一个元素左乘子群得到左陪集，那么加法记号的群就用一个元素加上一个子群得到这个子群的陪集即可。同样，我们可以使用这个加上去的元素来代表这个陪集，方法也是在上面戴个小帽子。&lt;/p&gt;
&lt;p&gt;有了正规子群，我们就可以愉快地进行商群的构造了。然而，为什么必须是正规子群呢？不能商去一般的子群吗？答案藏在商群运算的合理性中&lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;为了尝试从普通的子群构造商群，我们取子群的左陪集们然后就可以形成一个集合了。这个集合内的每个元素都是子群的左陪集。现在我们希望给这个集合上面添加运算。由于左陪集的元素是形如 $gH$ 这样的，所以我们自然希望 $g_1H \cdot g_2H = (g_1g_2)H$，也就是可以直接借用我们在群 $G$ 或 $H$ 中已经有的乘法了。这样定义的乘法满足了群运算的所有性质。然而，定义这个乘法不能靠我们一厢情愿，我们得检查定义的是否合理，即设 $a, a' ,b$ 是满足了 $aH = a' H$ 的任意的 $G$ 中的元素，我们要有 $(aH)(bH) = (ab)H = (a'b)H = (a'H)(bH)$。&lt;/p&gt;
&lt;p&gt;根据陪集定义，我们取任意的 $h_1$, $h_2$ 以及由它们决定的某个 $h_3$，则有 $ah_1bh_2 = a'bh_3$。由于 $aH=a'H$，根据之前的论述，我们指导一定有某个 $h_4$ 满足 $a = a'h_4$。我们带入前面式子，有 $a'h_4h_1bh_2 = a'bh_3$。根据群乘法可逆的条件，有 $h_4h_1bh_2 = bh_3$，我们再把 $h_2$ 的逆乘到等式右边，根据 $H$ 中乘法封闭性，就有：$h_5b=bh_6$。由于我们的 $h_1$，$h_2$ 是任意的，$a$，$b$ 也是任意的，所以 $h_3$ 和 $h_4$ 也不受额外条件的束缚，进而 $h_5$ 与 $h_6$。再回忆我们的左陪集和右陪集的定义，因此我们可以认为：为了满足我们的乘法条件，则必须要有 $Hb = bH$，这正说明了 $H$ 必须是正规的。至此，你应该已经发现：为满足运算的合理性，子群 $H$ 必须是正规子群。&lt;/p&gt;
&lt;p&gt;我们也可以这样理解。取 $G$ 中的任意两个元素 $g_1$与 $g_2$，再取 $H$ 中任意的两个元素 $h_1$ 与 $h_2$，我们要保证 $g_1h_1g_2h_2 = g_1g_2h_3$，其中 $h_3$ 可以是某个由计算过程得到的一个 $H$ 中的元素。要想把 $g_2$ 往左挪过去和 $g_1$ 凑成一对儿的形式，我们必须要让 $g_2$ 和 $h_1$ 存在某种形式的 “交换律”，这样的交换律必须保证 $g_2$ 还是 $g_2$，$h_1$ 则必须还是 $H$ 中的元素。但是，很可惜，这样的 “交换律” 只能存在于真的交换群，或者最低限度的办法：让左陪集等于右陪集，也就是正规子群中。否则这两点无法保证。&lt;/p&gt;
&lt;p&gt;上面这个说明，也是为了指出证明定义合理的重要性。这一点在代数中是十分重要的。而在讨论完陪集和正规子群的重要性后，我们最后要讨论的是：&lt;em&gt;商&lt;/em&gt; 到底是什么。&lt;/p&gt;
&lt;p&gt;我们其实已经指出过，商就是所谓的分类。小学学到的 “分堆问题” 就已经是对 &lt;em&gt;商&lt;/em&gt; 这个字非常好的诠释了。至于为什么用了 “商” 这个字…… 首先，我不知道；其次，也许可以问商鞅？（什么地狱笑话）&lt;/p&gt;
&lt;p&gt;商结构远不止存在于群或者集合中。商结构几乎存在于任何代数对象里。我们可以对拓扑空间做商结构，就像是把纸/空间缝起来/黏起来一样，这样我们就可以得到各种有趣的拓扑空间，比如甜甜圈（环面）、克莱因瓶、莫比乌斯环带等；我们可以把整数轴折叠起来，这样可以得到一个有限群（还很有可能是循环群）；我们还可以把 $\mathbb{R}$ 上多项式空间（就是所有以实数作系数的多项式组成的线性空间）商去多项式 $x^2+1$，这样得到的就是我们熟悉的复空间（复述域）。这里我们提出一种理解商空间的方法：把空间的某些点/线/面或者什么东西黏起来。这个 “黏起来” 的动作，实际上就是把某些点看作同一个点，而这样就等于定义了一个等价关系：黏起来后到同一个点的原空间内的点就在同一个等价类里面。&lt;/p&gt;
&lt;p&gt;此时你可以看到，如果你有一种分类方法，并且你可以用什么办法把代数对象里的元素放到不同的几堆儿里，那你就已经可以生成一个商结构了。它最最最最最起码也是一个商集，而要是你分类方法足够好，你得到的商结构就会更好。我们最后提一下商结构的记号，一般有两类表示方法：一是商去一个等价关系，二是商去用这个等价关系生成的等价类。这两种记号一般都是代表着同一个含义的。利用这个等价关系对原代数结构进行划分会得到若干等价类，其中的一个就是商去等价类记号中的那个等价类。&lt;/p&gt;
&lt;p&gt;So，这就是对这么几个代数学结构的解释了。希望你不要因为这些文字而感到眩晕的同时，得到一些对这些代数结构直观的解释。我们回到主线吧。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="正合列以及一点点点点范畴论"&gt;正合列，以及一点点点点范畴论
&lt;/h3&gt;&lt;p&gt;现在我们已经清楚了什么是交换群，什么是同态，什么是核，像，商群以及余核。是时候看看我们想要研究的结构了：正合列，以及对应的图。下面就是我们要研究的对象，也是一个图的例子：两个整合列所组成的图。&lt;/p&gt;
&lt;figure&gt;
&lt;img src="image/Commute_Diag.svg" style="width:60%"&gt;
&lt;figcaption&gt;两个整合列，通过整合列间的同态链接&lt;/figcaption&gt;
&lt;/figure&gt;
你可以在图中看到两个虚箭头，这两个虚箭头我们先把它们看成实线的，也就是实际存在的。后面证明蛇引理的时候这两个箭头是可以不存在的（当然也就没有连接着的0了）。
&lt;h4 id="链复型"&gt;链复型
&lt;/h4&gt;&lt;p&gt;我们先来说说正合列（Exact Sequence）。上图中的正合列有两个，分别是 $0\to A \to B\to C\to 0$ 以及 $0\to A' \to B'\to C'\to 0$。它们中的 $0$, $A$ 等我们称之为 &lt;em&gt;点&lt;/em&gt;，实际上是一个个交换群（一般是模，我们这里取交换群即可），而每个箭头都代表着一个同态。这些同态有着特殊的要求，如果这些同态只是一般的同态，那它们就什么都不是。为了使之成为整个列，我们需要先得到所谓的链复型（Chain Complex，上下文明确时可能直接叫复型 Complex）。&lt;/p&gt;
&lt;p&gt;链复型要求使用同态将一系列的数学对象连接起来，通常这些数学对象以及对应同态还会有一定的顺序，且同态之间的复合还要满足特殊的要求。具体而言，链复型要求这样的序列：&lt;/p&gt;
$$\cdots\xrightarrow{d_{i+2}} M_{i+1}\xrightarrow{d_{i+1}} M_i \xrightarrow{d_i} M_{i-1} \xrightarrow{d_{i-1}} \cdots$$&lt;p&gt;满足条件：$d_{i+1}\circ d_{i} = 0$ 对于所有的 $i$ 都成立。这样的链复型可以被记作 $(M_\bullet,d_\bullet)$。这样的定义蕴含了下面的信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交换群的序号从高到低，同态序号也从高到低&lt;/li&gt;
&lt;li&gt;对于所有的同态而言，左侧的同态复合上右侧同态得到的是零同态，也就是把所有的元素映射到单位元上（对于交换群，单位元就是0）&lt;/li&gt;
&lt;li&gt;由上面一条，如果左侧同态复合右侧同态得到了恒通映射，就说明左侧的同态必须把元素映射到右侧同态的核里面。若不然，则无法达成两次复合后为零同态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链复型的结构要求每个点都是同一种结构（交换群），且某个点里的任何一个元素沿着链复型移动两次后一定会映射到单位元（后面称零元）上。这样的代数结构是为了方便我们讨论所谓的 &lt;em&gt;同调&lt;/em&gt;，也正因如此，链复型是同调代数中最基础也最重要的代数结构之一。&lt;/p&gt;
&lt;h4 id="同调群正合正合列"&gt;同调群，正合，正合列
&lt;/h4&gt;&lt;p&gt;上面提到，正合列是在链复型商加条件得到的，而这个所谓的条件就是 &lt;em&gt;正合&lt;/em&gt; 条件。而为了讨论正合，我们还要引入同调群的概念。有了同调群，正合就非常好判断了。&lt;/p&gt;
&lt;p&gt;我们还是用上面的链复型来举例，所谓的同调群是指这样的商结构：&lt;/p&gt;
$$H_n(M_\bullet) \vcentcolon= \Ker d_n/\Img d_{n+1},$$&lt;p&gt;即一个同态的核与上一个同态的像之间的商群。当链复型的某个点处（即某一个 $n$）的同调群是平凡群（即只有一个元素的群，记作 $0$）时，我们称这个点上是 &lt;em&gt;正合的&lt;/em&gt;。而如果每个点都是正合的，我们就叫这个链复型为正合列。表达正合关系也可以不借助同调群，因为同调群等于平凡群就相当于说&lt;/p&gt;
$$\Ker d_n = \Img{d_{n+1}},$$&lt;p&gt;从这个角度来看也许更好理解正合是什么样的关系。仅从集合的角度来讲，链复型的要求就是在说 $\Img d_{n+1}$ 必须在 $\Ker d_n$ 的里面，它们之间可能有缝隙：$\Img d_{n+1} \subseteq \Ker d_n $；而正合则表示，这两个集合之间是没有缝隙的。这也许也是&lt;strong&gt;正&lt;/strong&gt;合这个字的来源吧。&lt;/p&gt;
&lt;p&gt;最后我们指出，我们上面的那个图片里所给出的两个正合列更为特殊，因为很短，所以叫它 &lt;em&gt;短正合列&lt;/em&gt;。不难看到，由 $0$ 出发的态射是单态，到 $0$ 结束的态射则是满的。而又根据正合的条件，可以得到 $f$ 必须是单态（不然 $\Ker f \neq 0$），$g$ 则必须是满态（否则 $\Img g \neq 0$。&lt;/p&gt;
&lt;h4 id="图与交换图"&gt;图与交换图
&lt;/h4&gt;&lt;p&gt;学代数的时候会遇到许许多多用箭头代表的态射，而我们也常常需要将态射复合起来形成新的态射。有时我们又会发现，一个态射可以通过两种甚至多种不同的态射复合方式得到。单靠语言经常会感到乏力，自然而然地，我们想到用图（Diagram）来绘制出这样的想法，把一些态射按照对应的数学对象连接起来。上面链复型或者正合列的表示实际上已经是一副图了，但是这个图还是比较简单的。而当我们发现一个态射可以通过不同的态射复合方式得到时，我们就可以把它们画出来，这样的图我们称是交换的，这种图我们叫做交换图（Commutative Diagram）。&lt;/p&gt;
&lt;p&gt;以上面的用两个短正合列组成的那个图举例，如果有 $\beta\circ f = f'\circ\alpha$ 以及 $\gamma\circ g = g'\circ\beta$，那么它就是一个交换图。我们后面把态射复合时中间的圆圈 $\circ$ 省略掉。&lt;/p&gt;
&lt;h4 id="一点点的范畴论"&gt;一点点的范畴论
&lt;/h4&gt;&lt;p&gt;我们最后简单地提一嘴范畴论吧。范畴论是从拓扑那里来的，是根据不同的几何结构间精巧的关系而诞生的描述这种关系的语言，但是后来逐渐被大家发现，好像很多数学结构之间也是可以构建出类似关系的。自此，便有数学家开始建立范畴论，用以正式地，形式化地描述不同数学结构它们内部的或之间的关系。&lt;/p&gt;
&lt;p&gt;我们举一些简单的例子，来看看什么是一个 &lt;em&gt;范畴&lt;/em&gt;（Category）。一个很简单的例子就是 &lt;em&gt;所有&lt;/em&gt; 的集合以及集合之间的 &lt;em&gt;所有&lt;/em&gt; 函数们所构成的范畴 $\mathsf{Set}$ 了（具体某个范畴的记号一般使用无衬线体，根据情况省略部分字母），另一个例子则是所有群以及所有的群之间的同态所构成的范畴 $\mathsf{Grp}$。可以看到很多都是 “所有的数学对象以及它们之间所有的同态构成的范畴” 这样的形式。这样的范畴还是比较基础且常见的，且根据这样的形式，我们可以很自然地总结出别的一些范畴，比如 $\mathbb{R}$ 上的所有线性空间以及所有的线性映射构成的范畴 $\mathsf{Vect_\mathbb{R}}$，所有的环以及其同态构成的映射构成的范畴 $\mathsf{Rng}$，等等等等&lt;sup id="fnref:3"&gt;&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;范畴之间是可以相互联系起来的，这种联系我们也可以像箭头一样写出来，称为函子（Functor）。而函子之间也可以做出联系，称为所谓自然变换（Nature Transformation）。不过好消息是，我们不需要关注这些内容，而只需要关注某一个具体范畴（具体来讲，就是阿贝尔群范畴 $\mathsf{Ab}$）的内部即可。&lt;/p&gt;
&lt;p&gt;范畴的作用除了给出不同类型的数学对象之间有什么样的联系之外，也给我们提供了一个讨论问题的舞台。我们可以直接讲我们在某个范畴中研究什么样的问题，此时范畴本身就给出了我们要研究内容的重要信息。另外，范畴论给了我们一些用以描述数学对象关系的语言，它们通常可以一针见血地指出数学对象间是什么样的关系，当然也因为过于抽象且过于具有总结性而被戏称为 “抽象废话”。&lt;/p&gt;
&lt;p&gt;最后，借助范畴论中的一些内容，比如交换图，我们可以方便地描述数学对象之间的关系。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;所以什么是范畴呢？&lt;/summary&gt;
我们这里引入范畴的原因其实非常地单纯：希望能引入所谓的交换图这一概念。虽然它本身的引入其实用不太上范畴，但是也许是出于我的私心吧，感觉这里引入范畴也能更好地规范我们研究问题的范围。
&lt;p&gt;那么什么是范畴呢？范畴其实就是一系列对象以及它们之间态射所构成的集合体。我们这里引用著名代数学教材，李文威老师的《代数学方法》中对于范畴的定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;范畴的定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一个范畴 $\mathcal{C}$ 是指以下的资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个集合 $\mathrm{Ob}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong&gt;对象&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;另一个集合 $\mathrm{Mor}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong&gt;态射&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，对上面两个集合之间有这样的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两集合间有一对映射： $s\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$ 和 $t\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$，它们分别指出了态射的&lt;strong&gt;来源&lt;/strong&gt;与&lt;strong&gt;目标&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于态射而言，有这样的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对某两个对象 $X,Y\in\mathrm{Ob}(\mathcal{C})$，我们可以从上面这一对映射中得到这两个对象之间的所有态射的集合：$\mathrm{Hom}_\mathcal{C}(X,Y)\vcentcolon=\space s^{-1}(X)\cap t^{-1}(Y)$。在明确所指范畴的情况下可简记为 $\mathrm{Hom}(X,Y)$。这样的集合也被称为 $\mathrm{Hom-}$ 集；&lt;/li&gt;
&lt;li&gt;对于任意的一个对象 $X$，一定存在一个态射 $\mathrm{id}_ {X} \in \mathrm{Hom}_{\mathcal{C}}(X,X),$ 这个态射被称为 $X$ 到自身的恒等态射；&lt;/li&gt;
&lt;li&gt;给定任意的三个对象 $X,Y,Z\in\mathrm{Ob}(\mathcal{C})$，有这样在其 $\mathrm{Hom-}$ 集之间的映射，称为&lt;strong&gt;合成映射&lt;/strong&gt;，定义为：
$$\begin{align*}
\circ\vcentcolon\space\mathrm{Hom}_\mathcal{C}(Y,Z) \times \mathrm{Hom}_\mathcal{C}(X,Y)&amp;\to \mathrm{Hom}_\mathcal{C}(X,Z)\\
(f,g)&amp;\mapsto f\circ g\\
\end{align*}$$
且当不至于混淆时可以省略中间的 $\circ$，将 $f\circ g$ 简记为 $fg$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，对上面的合成映射而言，有这样的两个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结合律：对于任意的态射 $h,g,f\in\mathrm{Mor}(\mathcal{C})$，如果映射的合成 $f(gh)$ 和 $(fg)h$ 都有定义，那么 $$f(gh) = (fg)h.$$&lt;/li&gt;
&lt;li&gt;对于任意的态射 $f\in\mathrm{Hom}_\mathcal{C}(X,Y)$，其与恒等映射之间的复合满足关系：
$$f\circ\mathrm{id}_X = f = \mathrm{id}_Y\circ f.$$&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;那么以上，就是范畴的比较正式的定义。可以看到它还是有依赖一些集合论的内容的，但这只依赖于对象集合和态射集合之间的映射，以及在 $\mathrm{Hom-}$ 集之间的映射，并不涉及某个具体的代数结构，特别是没有涉及到在集合上添加运算得到的代数结构。我们一般称这样有集合作为 “基底” 的范畴为 &lt;em&gt;具体范畴&lt;/em&gt;。另外，由于范畴的定义非常灵活，实际上可以定义出非常抽象的范畴，比如以态射作为对象的范畴。&lt;/p&gt;
&lt;p&gt;最后要指出的是，范畴最关键的应该是态射，而不是范畴内的对象。范畴论以研究对象间的态射来研究范畴的行为。从范畴的定义中也可以看到，众多的要求都是对态射提出的，而非对对象。在使用或研究范畴时，应注意这一点。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="所以蛇引理到底讲了什么"&gt;所以，蛇引理到底讲了什么
&lt;/h3&gt;&lt;p&gt;终于，我们把为了描述蛇引理讲了什么而需要的一些基础内容介绍完了。可以看到，蛇引理还是需要比较多的前置的。下面就是这个所谓的蛇引理了。我们介绍的是建立在两个短正合列所构成的交换图上的简单版本的蛇引理。具体内容如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;蛇引理：&lt;/p&gt;
&lt;p&gt;设有如下图所给出的交换图：&lt;/p&gt;
&lt;figure&gt;
&lt;img src="image/Commute_Diag.svg" style="width:60%"&gt;
&lt;/figure&gt;
其中第一行和第二行均为正合列，每个点均为阿贝尔群（交换群）。由这样的两个正合列，我们可以构造出下面的正合列：
&lt;figure&gt;
&lt;img src="image/Snake.svg" style="width:90%"&gt;
&lt;/figure&gt;
且当交换图中的虚线箭头成立时，对应的虚线箭头也成立。&lt;/blockquote&gt;
&lt;p&gt;这条引理由于构造出的正合列需要像蛇一样从交换图的左上角开始出发一路拐到右下角而得名。真是恰当的名字。由于我们已经知道所谓的余核，所以上面的正合列实际上还可以写成这样更加对称的形式：&lt;/p&gt;
&lt;figure&gt;
&lt;img src="image/Snake_Coker.svg" style="width:90%"&gt;
&lt;/figure&gt;
&lt;!-- $$
0\dashrightarrow \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma \dashrightarrow 0
$$ --&gt;
&lt;details&gt;&lt;summary&gt;对称？对称在哪？&lt;/summary&gt;
我们常常讲 “对称”，对称常常能带来强烈的美感。然而，对称到底是什么？
&lt;p&gt;我们从小就知道轴对称，稍晚会学到中心对称，旋转对称等等。然而这些对称始终没有一个综合的描述方法，它甚至不像是数学的内容，反而更像是美术的内容。然而，有了群，我们就可以描述这样的对称性了：对称，就是使用一个群对其进行作用后仍然能回到自身的性质。对称就蕴含于群内部。&lt;/p&gt;
&lt;p&gt;然而我们这里打算提到的对称，并不是和群相关的，而是和交换图相关的。从交换图上可以看到，如果把底下的链条用余核来代替，那么这个图就是非常对称的：上面是核构成的链条，下面是余核构成的链条；左下角是一个单态，而右上角则是一个满态。然而我们肯定不能单纯满足于这样的只从图上看到的对称，我们想问这样的问题：余核，它和核的定义区别如此之大，为什么会这么自然地存在于这个图内？它们俩之间究竟有什么样的关系，让最后的这个交换图呈现了这样的形状？或者问得更简单一些：余核，什么是 &lt;em&gt;余&lt;/em&gt;？它好像是剩余的意思，但是从英文上来看又完全看不出这样的关系。&lt;em&gt;余&lt;/em&gt; 到底是什么？&lt;/p&gt;
&lt;p&gt;我们做一点剧透：因为范畴和交换图，即因为核与余核之间定义的对称性。可能会有人有这样的疑问：核与余核之间的定义的对称性？从形式上来看完全没有任何的对称性呀？我们指出：在范畴论的语言下，两者完全可以使用 &lt;em&gt;泛性质&lt;/em&gt; 进行定义。我们后面会提到所谓的泛性质是什么。&lt;/p&gt;
&lt;p&gt;我们观察核的定义：核是对一个同态定义的。比如有这样的（群）同态：$\varphi \vcentcolon G\to H$，那么这个同态 $\varphi$ 的核就是一些群 $G$ 中的元素所组成的集合，这些集合在同态 $\varphi$ 的作用下会映射到群 $H$ 的单位元处。或者我们采用原像的写法，$\Ker \varphi = \varphi^{-1} (1_H)$。&lt;/p&gt;
&lt;p&gt;那么我们应该怎么把他改写成使用范畴定义的东西呢？我们抓住范畴论的核心思想：使用态射来研究对象。作为一个同态的核，它在映射之后一定会到单位元上；作为一个群，它一定是同态的定义域的子群。我们可否用这个性质来做文章？答案是肯定的：我们就如此定义，但通过范畴论的语言来描述这个过程。&lt;/p&gt;
&lt;p&gt;我们定义态射 $\varphi \vcentcolon G\to H$ 的核是这样的一个群范畴 $\mathsf{Grp}$ 中的一个对象 $\Ker \varphi$，这个对象到同态 $\varphi$ 的定义域 $G$ 之间存在一个包含同态&lt;/p&gt;
$$\begin{align*}
\iota \vcentcolon \Ker \varphi &amp;\hookrightarrow G\\
g &amp;\mapsto g
\end{align*}$$&lt;p&gt;（我们这里使用带钩箭头标明它是一个单态）；此外，这个对象满足这样的性质：对于任意的同态 $\alpha\vcentcolon X\to G$，只要满足条件&lt;/p&gt;
$$\varphi\circ\alpha = 0,$$&lt;p&gt;（此处 $0$ 代表零映射，或者叫平凡映射（Trivial Map），即将所有的元素都映射到单位元 $1_H$ 上），那么同态 $\alpha$ 即可被唯一地分解，即对某个 $\alpha$ 而言，存在唯一的一个同态 $\overline{\alpha}\vcentcolon X\to \Ker \varphi$，满足 $\alpha = \iota\circ\overline{\alpha}$。将这些性质使用交换图来描述的话，就是说下面的这个交换图成立：&lt;/p&gt;
&lt;figure&gt;
&lt;img src="image/Kernel.svg" style="width:40%"&gt;
&lt;figcaption&gt; 核的定义 &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;换句话来说，对于任意满足条件 $\varphi\circ\alpha = 0$ 的态射 $\alpha \vcentcolon X \to G$，它们都一定可以被分解成两个映射，且这个分解方式是固定的：先有一个唯一的映射 $\overline{\alpha}$ 将 $X$ 映射到一个群上，然后再从这个群出发，保持原样地通过包含映射 $\iota$ 映射到原态射的陪域 $G$ 中。而这样的固定且特殊的元素，就是我们要找的映射 $\varphi$ 的核，也就是 $\Ker \varphi$。&lt;/p&gt;
&lt;p&gt;我们观察这样的定义，它实际上确实定义出了我们熟悉的核，只不过是用了更加范畴论的形式，并没有研究元素内部是如何映射的，而是使用了 &lt;em&gt;平凡映射&lt;/em&gt; 来包含所有我们需要的信息，再通过唯一分解的方式来确定它的地位。它只是换了一种更加 fancy 的说法而已。&lt;/p&gt;
&lt;p&gt;而接下来，我们就要仿照这样的形式，来定义余核。我们先来观察已有的余核定义，它被定义为同态的陪域模除掉同态的像得到的结构。为此，我们需要先来看看商的泛性质。我们依旧在群范畴内讨论这个问题，但是它很容易就可以推广到其他的结构中。&lt;/p&gt;
&lt;p&gt;从商的构造过程来看，构造商结构时需要取一个等价关系，然后根据这个等价关系进行划分，最后将所有的等价类放在一起，每个等价类作为一个商结构中的一个元素，这就是取商的过程。如果要在范畴论中讨论这个问题，那么就需要从与商相关的态射出发考虑这个问题。首先我们看取商的过程。&lt;/p&gt;
&lt;p&gt;鉴于上面的过程的统一性，我们将这个过程化为一个态射，称之为商映射 (Quotient Map)，记作 $\pi$。当明确左或右陪的元素时，也可以在这个记号的左下标处记下该元素，如从整数群构造 n 阶循环群的过程，其商映射就可以记为 $\pi_n\vcentcolon\mathbb{Z}\to\mathbb{Z} /n\mathbb{Z}$。有了这样的记号，我们的讨论也会更加便利。&lt;/p&gt;
&lt;p&gt;既然从态射角度出发，我们想观察：假如从群 $G$ 到群 $G'$ 有一个同态 $\varphi$，而群 $H$ 是 $G$ 中的正规子群（因此可以被模掉）且 $H\subseteq \Ker \varphi$（为了保证商群依旧能映射到 $G'$ 上）。那么，这个同态 $\varphi$ 与 $G$ 模 $H$ 得到的子群 $G/H$ 之间有什么样的联系呢？我们有这样的定理，同样，可以用交换图来表示：如果有上述条件存在，那么则存在一个唯一的映射 $\overline{\varphi}$，使得 $\varphi = \overline{\varphi} \circ \pi$，即下面的图交换：&lt;/p&gt;
&lt;figure&gt;
&lt;img src="image/Quotient.svg" style="width:40%"&gt;
&lt;figcaption&gt; 商的泛性质 &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;怎么理解这个图的交换性呢？当我们把 $G$ 映射到 $G'$ 时，由于该映射的核的限制，必须有和核的元素个数一样多的元素被映射到同一个 $G'$ 中的元素里（考虑我们定义的核，以及商映射的特点）；当将 $G$ 商映射到 $G/H$ 上面时，由于 $\Ker \varphi$ 的元素比 $H$ 中的元素数量要多（上面的子集关系），此时从 $G$ 到$G'$ 的同态 $\varphi$ 对其定义域 $G$ 的 “收缩力度” 是一定不如商映射 $\pi$ 的。因此，我们一定可以从商映射得到的 $G/H$ 中再做一次映射，从 $G/H$ 重映回 $G'$，使得 $\varphi$ 最后被表示为 $\overline{\varphi}$ 与 $\pi$ 的复合。也就是说，$\varphi$ 被分解为了两步：首先，通过正规子群进行分类，由于我们取的正规子群比核小，所以商群内的每个元素必定被映射到同一个元素内;在进行这样的分类后，再进行一次映射，把分好的等价类按照其中元素原有的根据 $\varphi$ 的映射方式来将这些等价类映射到对应的 $G'$ 中的元素里。由于拉格朗日定理，子群的关系保证了这样分类得到的等价类个数一定是整除态射 $\varphi$ 的像的，这也就保证了这个同态是良好定义的，并不会出现一个等价类映射到两个 $G'$ 中元素，或者映射到同一 $G'$ 中元素的等价类数目不同这样的情况。&lt;/p&gt;
&lt;p&gt;在理解上面定理的含义后，我们指出：实际上我们可以借助商的这一泛性质来定义商结构和商映射，即：设 $G$ 是一个群，其有一正规子群 $H$，则通过如下两个泛性质即可定义商群 G/H 与商映射 $\pi$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在一个群 $G/H$ 和一个群同态 $\pi\vcentcolon G\to G/H$，满足 $\Ker \pi = H$；&lt;/li&gt;
&lt;li&gt;对任意的群 $G'$ 与 群同态 $\varphi\vcentcolon G\to G'$，如果 $H \subseteq \Ker \varphi$，则存在一个唯一的群同态 $\overline{\varphi} \vcentcolon G/H \to G'$，使得上面的交换图成立。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也许你有疑问：我们不是在看余核是怎么回事吗？你怎么扯到商结构和商映射用泛性质的定义了？正是由于有了商结构的泛性质，我们才能更好地定义我们已经知道的余核。&lt;/p&gt;
&lt;p&gt;这里也不继续卖关子了，为了定义余核，我们需要做的事情只有三件：一，将上面核的泛性质图里的所有箭头转向；二，把 $\Ker \varphi$ 换成 $\Coker \varphi$，把带钩箭头换成双箭头（代表满态），再把包含映射记号 $\iota$ 换为商映射记号 $\pi$；最后，我们再仿照核的定义，来讲所谓的余核是什么的时候，需要将群改为阿贝尔群（交换群）。我们先把表示它泛性质的图画出来；为了方便对照，我们把核对应的泛性质图用另一种形式画出并附上（两种交换图是完全等价的）：&lt;/p&gt;
&lt;div style="display: flex"&gt;
&lt;figure style="float: left; flex: 50%"&gt;
&lt;img src="image/Coker.svg" style="width:80%"&gt;
&lt;figcaption&gt; 余核 &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure style="float: left; flex: 50%"&gt;
&lt;img src="image/Ker.svg" style="width:80%"&gt;
&lt;figcaption&gt; 核 &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;相信到了这一步，你一定会相信所谓的 “对称” 绝非空穴来风。所谓的余核，说得简单点，就是把核的泛性质里的所有箭头都反转后定义出来的东西而已；甚至于对于范畴论而言，所谓的 “余” 就是将某个对象的泛性质里箭头全部反转后出现的对偶。一个著名的范畴论笑话是这么讲的：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;A mathematician is a device for turning coffee into theorems, and a comathematician is a device for turning cotheorems into ffee.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们再来看看余核的泛性质。很容易就可以看到余核的交换图的右侧出现了我们熟悉的身影：商结构和商映射的泛性质。通过这个小块我们得以了解到，$\Coker \varphi$ 应该具有某种商结构，需要用 $H$ 商去它的一个正规子群。那么它具体应该商去谁呢？注意到两点：&lt;/p&gt;
&lt;p&gt;第一点是，商结构的特点决定了它要商掉的那个正规子群本身是可以作为陪集存在于商群中的。举个简单快速的例子，$A/B$ 这个商群里 $B$ 本身就是一个陪集，是用 $A$ 中单位元 $1_A$ 去陪 $B$ 得到；而这个特殊的陪集，由于用来左陪的元素是 $A$ 中单位元，它在商群 $A/B$ 中一定也是担任单位元的责任；&lt;/p&gt;
&lt;p&gt;另一个点则来自于 $G\to X$ 必须是平凡映射这一要求。我们根据余核的泛性质，可以轻松地取这样的 $\beta$，让它就等于 $\pi$，这样一来 $\overline{\beta}$ 就变成了恒等映射，$X$ 也就变成了我们研究的 $\Coker \varphi$。那么，从群 $G$ 出发，在映射到 $\Coker \varphi$ 时必须到它的单位元上，那么从商映射的特点看，所有的 $G$ 中的元素都必须在经过 $\varphi$ 映射后出现到 $\Coker\varphi$ 商去的那个正规子群里。而满足这样条件的东西只有一个，即 $\Img \varphi$，且还有一个要求，就是 $\Img \varphi$ 必须是正规的，这就要求 $H$ 是交换群，进而要求整个泛性质中的群都得是交换群。&lt;/p&gt;
&lt;p&gt;如此，我们又成功地从余核的泛性质的定义里拿到了我们熟悉的，用商群定义的那个余核。这也进一步指明了核与余核在范畴论意义下的对偶关系。然而，对于核以及余核而言，它们的定义还可以更加 fancy 一些：我们可以使用极限和余极限来定义核与余核，这里就不过多展开了，毕竟这篇文章不是讲范畴论的，而是为了证明蛇引理的来着（）&lt;/p&gt;
&lt;/details&gt;
&lt;h2 id="准备证明吧"&gt;准备证明吧
&lt;/h2&gt;&lt;p&gt;我们的手牌已经集齐了，现在等待着我们的就是要证明这个引理。这个引理涉及到的阿贝尔群很多，同态也很多。我们需要一步一步地朝着目标前进，否则这个大个家伙是没办法一次搞定的。&lt;/p&gt;
&lt;h3 id="证明思路"&gt;证明思路
&lt;/h3&gt;&lt;p&gt;从最后的结果来看，我们有这样的几个问题是需要验证的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f|$ 的定义是否合理&lt;/li&gt;
&lt;li&gt;$g|$ 的定义是否合理&lt;/li&gt;
&lt;li&gt;$\hat{f'}$ 如何定义，是否良定&lt;/li&gt;
&lt;li&gt;$\hat{g'}$ 如何定义，是否良定&lt;/li&gt;
&lt;li&gt;$\delta$ 如何定义，是否良定&lt;/li&gt;
&lt;li&gt;每个点处是否正合&lt;/li&gt;
&lt;li&gt;若原交换图虚线箭头成立，得到的正合列是否对应虚线箭头也成立&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们不计划纠结于为什么核与余核在这里出现的如此频繁，只将之作为待证明的结论；也就是说，我们不考虑为什么选择了这样的构造，只考虑证明这个构造为什么是正确的。另外，我们可以发现第1点与第2点是很相似的，同样第3点与第4点也是很相似的。&lt;/p&gt;
&lt;p&gt;在正式开始进行验证之前，我们做一些符号上的约定，以免待会儿晕符号。如果是 $A$，$B$，$C$ 中的元素，我们就用对应的小写字母代表；如果是 $A'$，$B'$，$C'$ 中的元素，我们就在对应小写字母的上面也对应地加上这个 $\prime$。如果需要从同一个群中取两个元素，为了区分它们，我们会再在右上角添加上 $*$ 来表示。如果是经过了同态/映射的作用，在需要时会加上其属于的群以做提示，而不再用 $\prime$ 或者别的字母做记号，除非这样的记号是必须的。&lt;/p&gt;
&lt;p&gt;好了，我们开始正式的证明过程吧。&lt;/p&gt;
&lt;h3 id="验证-f-的定义然后-g"&gt;验证 $f|$ 的定义，然后 $g|$
&lt;/h3&gt;&lt;p&gt;我们第一个要验证的是 $f|$ 的定义，或者说仔细考虑怎么样去定义它。从图上可以看到，这个同态是 $f$ 在 $\Ker \alpha$ 上的限制，对它的定义的验证则是要验证 $f|$ 是否真的能把 $\Ker \alpha$ 映射入 $\Ker \beta$ 中，即验证 $\Img f| \subseteq \Ker \beta$。&lt;/p&gt;
&lt;p&gt;为了验证这件事，我们只需要任意取 $\Ker \alpha$ 中的元素，如果这些点在 $f|$ 的映射下都属于 $\Ker \beta$，就可以验证这样的包含关系了（这也是子集的定义）。既然如此，我们取 $\Ker \alpha$ 中的一个元素 $a$，根据核的性质，既然 $a$ 在 $\alpha$ 的核内，我们知道 $\alpha (a) = 0 \in A'$，再根据同态的性质，群同态只能将单位元/零元映射到单位元/零元上，我们知道 $f' \alpha (a) = 0 \in B'$。由于交换图的性质，我们有：$\beta f (a) = f' \alpha (a) = 0$。请注意 $\beta (f(a)) = 0$ 就意味着 $f(a)$ 这一点位于 $\Ker \beta$，即 $f(a) \in \Ker \beta$，而这恰恰就是我们要证明的：任意一个 $\Ker \alpha$ 中的元素 $a$ 在经过 $f|$ 映射之后，都位于 $\Ker \beta$ 中。&lt;/p&gt;
&lt;p&gt;这里有一个点需要指出：为什么我们明明要验证的同态是 $f|$，最后却直接使用了 $f$ 的性质？这是因为：$f|$ 除了更改了定义域的范围之外，所有的信息都得以保留。由于我们任取的 $a$ 满足 $a\in\Ker \alpha \subseteq A$，所以 $f|$ 对在 $\Ker\alpha$ 中语境下的 $a$ 所产生的影响，和 $f$ 对 $A$ 中语境下的 $a$ 产生的影响是一模一样的。这保证了我们可以放心大胆地使用 $f$ 的性质。&lt;/p&gt;
&lt;p&gt;最后我们指出，这里的验证过程没有借助图表交换以及核的性质以外的任何要素，因此这套证明也可以直接照搬到下一个交换块，也就是关于 $g|$ 的定义的验证问题上。这里就不啰嗦了。&lt;/p&gt;
&lt;h3 id="验证-hatf-的定义顺带-hatg"&gt;验证 $\hat{f'}$ 的定义，顺带 $\hat{g'}$
&lt;/h3&gt;&lt;p&gt;接下来要验证的就是 $\hat{f'}$ 的定义了。我们要验证的东西其实和上面类似，也是 $\Img \hat{f'} \subseteq \Coker \beta$。然而我们现在还不知道 $\hat{f'}$ 具体是怎样的，只知道它的定义域是 $\Coker \alpha$。所以我们先来看看 $\Coker \alpha$ 里都有什么，再看看 $\hat{f'}$ 是一个什么样的同态，最后来考虑验证上面所要求的定义。&lt;/p&gt;
&lt;h4 id="operatornamecoker-alpha-里是什么样的"&gt;$\operatorname{Coker} \alpha$ 里是什么样的
&lt;/h4&gt;&lt;p&gt;由于 $\Coker \alpha = A' / \Img \alpha$，其中的每个元素都应该是 $\Img \alpha$ 这种形式的陪集。&lt;/p&gt;
&lt;p&gt;我们先考察一般的阿贝尔群（交换群）里某个同态的余核是什么样的。对于一般的阿贝尔群 $A$ 以及其上的某个同态 $f\vcentcolon\\,A\to B$ 而言，这里的等价关系是这样定义的：若 $a,a^* \in A$ 且 $a - a^* \in \Img f$，则认为 $a \sim a^* $，即 $a$ 与 $a^* $ 等价。这里的减号应该与 $a^* $ 一起理解为 $a^* $ 的逆元。这就形同 $a^{-1}a^* $ 在一般的乘法群中判定元素是否等价时一样。&lt;/p&gt;
&lt;p&gt;与此同时，其他的等价类（陪集），按照加法记号，也应该可以写作这样的形式：$a+\Img \alpha$。（假如你没有点开哪些小箭头的话）我们使用代表元的记号来记录这个陪集，即 $\hat{a} = a+\Img \alpha$。我们在余核中定义的运算，则是借助余核所在的群的运算所定义的：直接将代表元按照原群中的运算进行，最后给它带上帽子（找到对应的等价类）。写成符号形式则是：假设有同态 $f: A\to B$，则这个同态的余核为 $\Coker f = A/\Img f \subseteq A$，再设余核这个群中有两个元素 $\hat{a}$ 与 $\hat{a^* }$，则余核中的运算为：$\hat{a}+_\mathrm{Coker}\hat{a^* } = \widehat{a+_A a^* }$。&lt;/p&gt;
&lt;p&gt;现在一切都明了了。对于我们所要研究的问题而言，$\Coker \alpha$ 中的元素，就是一个个等价类，这些等价类用原群的元素作为代表元进行标记，如 $\hat{0}$, $\hat{a'}$ 这样。而其运算直接继承自群 $A'$，具体而言，只需要将用来与子群作用的元素相运算，最后再作用回子群即可。&lt;/p&gt;
&lt;h4 id="hatf-是什么样的"&gt;$\hat{f'}$ 是什么样的
&lt;/h4&gt;&lt;p&gt;从交换图上可以看到，$\hat{f'}$ 是从 $\Coker \alpha$ 到 $\Coker \beta$ 上的。而在 $\Coker \alpha$ 中的元素则是众多的以代表元所代表的等价类。那么，在使用 $\hat{f'}$ 作用到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$ 后，得到的则应该是位于 $\Coker \beta$ 中的一个元素，这个元素应该是形如 $b'+\Img \beta$ 这样的等价类，自然也可以被表示为 $\hat{b'}$。这就是我们需要验证的同态，$\hat{f'}$，具体在做的事。&lt;/p&gt;
&lt;p&gt;让我们写的更加明确一些：我们要定义的 $\hat{f'}$ 应该是这样的：&lt;/p&gt;
$$\begin{align*}
\hat{f'}\vcentcolon\space \Coker \alpha &amp; \to \Coker \beta \\
a' + \Img \alpha &amp; \mapsto b' + \Img \beta,
\end{align*}$$&lt;p&gt;其中 $a'\in A'$ 与 $b' \in B'$ 之间的关系有：$f'(a') = b'$。&lt;/p&gt;
&lt;p&gt;那么就有值得注意的一些问题。两个元素等价时，它们自然属于同一个等价类，但这两个元素本身是可以不同的。假如两个不同但等价的元素在进入等价类后再被商群间的同态所映射，应该会得到一个目标群上的等价类。另外，自然，我们也要验证这个同态的像确实在陪域内。我们开始验证吧。&lt;/p&gt;
&lt;h4 id="开始验证"&gt;开始验证
&lt;/h4&gt;&lt;p&gt;我们取 $\Coker \alpha$ 中的一个元素 $\hat{a}$，这个元素是一个等价类，等价关系由 $a' - a'^* \in \Img \alpha \hArr a' \sim a'^* $ 给出。此时我们就取这个等价类中的这两个元素 $a',\\, a'^* \in A'$。那么，此时这两个元素在经过 $f'$ 作用后得到的就是 $f' (a')$ 以及 $f'(a'^* )$。这两个 $B'$ 中的元素应该依旧会被映射到同一个等价类中，也就是两个元素等价。判断两元素等价的条件则类似于前面的判断条件：$f' (a') - f'(a'^* ) \in \Img \beta$。我们可以看到：由于 $f'$ 是一个同态，同态是保运算的，则 $f' (a') - f'(a'^* ) = f'(a' - a'^* )$。注意到 $a' - a'^* \in \Img \alpha$，由像的性质，我们就一定可以找到一个存在于 $A$ 中的一个元素 $a$，使得 $\alpha(a) = a' - a'^* $。&lt;/p&gt;
&lt;p&gt;我们理一下思路：我们先选取了两个在 $A'$ 中等价的元素；这两个元素的差，根据等价类划分的规则，必须是属于 $\alpha$ 的像的，那么就一定有一个对应的 $A$ 中的元素 $a$ 在 $\alpha$ 的作用下等于这两个 $A'$ 中元素的差。那么这时，我们就可以使用图表交换的性质了：$f'(\alpha(a)) = \beta(f(a))$。请注意这个地方：右侧显示 $\beta(f(a))$ 是属于 $\beta$ 的像的：$\beta(f(a)) \in \Img \beta$。这就说明了 $f'(\alpha(a)) = f'(a' - a'^* ) \in \Img \beta$。这样，我们就得到了我们所需要的：任取两个 $A'$ 中的等价元素，它们最终被映入了 $B'$ 的等价类，因为 $f' (a') - f'(a'^* ) \in \Img \beta$。&lt;/p&gt;
&lt;p&gt;那么这样我们就可以进一步进入到对 $\hat{f'}$ 的验证：如果 $a'\in A'$ 且 $a'^* \in A'$ 且二者等价，就有 $a' + \Img \alpha = a'^* + \Img \alpha$。我们希望这两个应该相等的等价类在经过 $\hat{f'}$ 的映射后得到的是同一个 $\Coker \beta$ 中的元素。那我们就直接进行运算：&lt;/p&gt;
$$\begin{align*}
\hat{f'}(a' + \Img \alpha) &amp;= f'(a') + \Img \beta\\
&amp;= f' (a'^* +a'-a'^* ) + \Img \beta\\
&amp;= f' (a'^* ) + f'(a'-a'^* ) + \Img \beta \\
&amp;= f' (a'^* )+ \Img \beta\\
&amp;= \hat{f'}(a'^* + \Img \alpha).
\end{align*}$$&lt;p&gt;我们来解释一下上面的运算过程。第一步是使用了我们上面对函数做出的定义；第二步就是单纯地进行了个加减，不过这里的加减能成立必须利用交换群的性质；第三步则是利用了 $f'$ 作为阿贝尔群同态的定义；第四步则要应用到我们刚刚得到的结论： $f' (a') - f'(a'^* ) \in \Img \beta$；第五步则就是单纯运算回以 $\hat{f'}$ 表达的形式，完成我们的证明。&lt;/p&gt;
&lt;p&gt;自此，我们证明了：两个任意的 $A'$ 中元素，当它们等价时，会且总是会被 $\hat{f'}$ 映射到同一个 $\Img \beta$ 中的元素。这句话还可以换个说法：我们定义的这个同态，是不依赖于等价类代表元的选取的（我们选了两个代表元，结果一样）；或者简单一些：这个同态是良定的。&lt;/p&gt;
&lt;p&gt;我们完全可以按照相似的逻辑处理 $\hat{g'}$。这得益于我们上面的定义以及验证没有用到除了交换图提供的信息外的任何额外附加信息。所以我们就不特别定义并验证这个 $\hat{g'}$ 了，直接借用这里的定义以及验证方法即可。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;如何验证一个同态是良定的&lt;/summary&gt;
&lt;p&gt;在代数学中，我们常常会尝试给某个数学对象附上一个同态，或者给两个数学对象之间定义同态。然而，这样的过程并不总是顺利的：可能我们定义的东西到实际验证时是有问题的。就我个人的观点而言，这些问题包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义域上同一个元素被映射到了不同的陪域中的元素（违反映射的定义）；&lt;/li&gt;
&lt;li&gt;不保持对象间的结构（不保运算，不保连续等）；&lt;/li&gt;
&lt;li&gt;定义域不对，超出或小于定义域；&lt;/li&gt;
&lt;li&gt;超过了陪域的范围，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等。而我们所说的验证一个同态是良定的，实际上就是在尝试验证上面的这些问题都不会出现。一般而言，后两个问题都不太容易出现，一般的验证过程都是在验证前两个问题是否存在。&lt;/p&gt;
&lt;p&gt;我们先看第一个，这个的验证方法非常地朴实无华，即通过验证两个定义域上相等的元素，它们在经过同态作用之后是否依旧相等。如果是保持相等的，则证明一个元素不会被映射到两个不同的元素上，从而完成第一个问题的验证。这里要提到的是，对于商群这样，元素是陪集这样集合的情况，还有必要验证一个陪集内的元素是否能被从商群出发的同态映射到定义域上的同一个元素中。不过这一点也可以归结为对第二个问题的验证，即同态是否能够保持对象间的结构。&lt;/p&gt;
&lt;p&gt;针对商群这样的结构，如果一个陪集内的元素被映射到了不同的定义域上的元素，那么就证明这样的映射并不能保持商群的元素，即陪集，内部所有元素等价的条件。除了这样的结构性质外，另一个常见的结构即定义好的代数运算，或者说是同态区别于函数的性质。我们也可以说，先对元素做运算再通过同态映射，其结果应该等同于先做完同态的映射，再在陪域内进行运算。这也许可以被称为同态和运算之间的 “交换性”。&lt;/p&gt;
&lt;p&gt;虽然第三和第四个问题一般不会出现，但是在从零开始构造一个同态时，对它们的验证依旧是有必要的。特别是第四条，即对于陪域的验证，我们要求同态的像必须是陪域的子集，否则这个映射就不是良定义的。从上面的一系列验证过程中，我们也能够看到对于这一条件的验证。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="delta-的定义与验证"&gt;$\delta$ 的定义与验证
&lt;/h3&gt;&lt;p&gt;这个 $\delta$ 的定义算是证明蛇引理过程中的一个难点吧，这也是蛇引理的关键一步，也是 “蛇” 这个字的由来吧。我们应该如何从一个核映射到余核呢？从交换图上来看，是需要从 $C$ 中的子集映射到 $A'$ 上的等价类的。这应该如何是好呢？&lt;/p&gt;
&lt;h4 id="delta-应该是什么样的"&gt;$\delta$ 应该是什么样的
&lt;/h4&gt;&lt;p&gt;好消息是：我们对同态 $g$ 以及 $f'$ 是有一些说法的：$g$ 一定是满态，而 $f'$ 则一定是单态。这是根据这两个正合列的性质，或者说是正合列中 $C$ 点与 $A'$ 点的性质而得到的。我们前面也有提到这个结论，这里简单说明一下：由于 $C$ 映射到平凡群的同态一定是一个满态，这个满态的核就一定是 $C$ 本身；由于正合的要求，$g$ 的像就必须是 $C$ 了，也就是 $g$ 是满的；由于 $0$ 到 $A'$ 作为同态必须也只能映射到 $A'$ 中的单位元，所以这个映射的像就只能是那个单位元自己形成的平凡群；由于正合列的性质，$f'$ 的核则只能是这个平凡群，也就是说它是一个单态。&lt;/p&gt;
&lt;p&gt;这两个信息对于 $\delta$ 的构造是必须的，否则我们没有一个很好的从 $C$ 一路走回 $A'$ 的方法。当然，有了上面的提示，我们很自然想到，这个 $\delta$ 的构造应该是什么样的。它会从 $C$ 出发，从 $g$ 反着走到 $B$ 点，在经过 $\beta$ 的映射之后，再通过 $f'$ 反过来到 $A'$ 上。我们来更细致地考察这个映射构造过程的每一步吧。&lt;/p&gt;
&lt;h4 id="delta-的具体构造"&gt;$\delta$ 的具体构造
&lt;/h4&gt;&lt;p&gt;我们的 $\delta$ 是从 $\Ker \gamma$ 开始的，自然我们就取 $C$ 中的子集 $\Ker \gamma$ 里的一个元素 $c$。得益于满态的性质，我们一定是可以在 $B$ 中找到某个元素 $b$，使得 $g(b) = c$ 的。&lt;/p&gt;
&lt;p&gt;注意到我们对 $c$ 的选取，这个 $c$ 是在 $\Ker \gamma$ 内的，所以就会有： $\gamma(g(b)) = 0$。再根据图的交换性，我们就有了 $g'(\beta(b)) = \gamma(g(b)) = 0$，也就是说 $\beta(b) \in \Ker g'$。&lt;/p&gt;
&lt;p&gt;这时我们要根据正合列的性质来继续向 $A'$ 推进。由于正合性，我们有 $\Img f' = \Ker g'$，因此 $\beta(b) \in \Img f'$，而既然 $\beta(b)$ 出现在了 $f'$ 的像中，就一定会有一个 $A'$ 中的元素，我们记作 $a'$，一定会在 $f'$ 映射后到我们之前拿到的 $\beta(b)$ 上。&lt;/p&gt;
&lt;p&gt;最后，由于 $f'$ 是单态，上面说的那个 $a'$ 在此时是唯一确定的。而这个唯一确定的元素在 $A'$ 对应的商群 $\Coker \alpha$ 中自然也是属于唯一的一个等价类的。&lt;/p&gt;
&lt;p&gt;我们现在回溯一下这个过程：我们取了 $\Ker \gamma$ 中的一个元素 $c$，它一定对应了某个 $B$ 中的 $b$。但要注意的是，因为仅有 $g$ 是满态的要求，这个 $b$ 可能不唯一。接着我们从这个 $b$ 自然地得到了 $\beta(b)$，而它则有 $A'$ 中存在且唯一的对应元素 $a'$。这个元素，很自然地，在 $\Coker \alpha$ 中就有了唯一的等价类。总结下来就是：每个 $\Ker \gamma$ 中的元素经过我们上面的映射过程，都是可以得到 $\Coker \alpha$ 中的等价类的。&lt;/p&gt;
&lt;p&gt;然而这给了我们一个亟待解决的问题：这个映射链最后是需要组合成一个同态 $\delta\vcentcolon\\,\Ker \gamma \to \Coker \gamma$ 的，而作为一个同态，每个定义域上的元素能且只能对应到陪域上的唯一一个元素。然而从我们刚刚的映射链过程来看，由于 $c$ 在 $B$ 中对应的元素个数是不确定的，虽然每个 $b$ 中元素都能对应到唯一的 $A'$ 中的等价类，但可能所有满足 $g(b) = c$ 的 $b$ 所能对应的 $A'$ 的等价类是不一样的。用更形式化的语言来讲，我们现在要解决，或者要证明的问题就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设存在两个 $B$ 中的元素 $b,\\,b^* $，满足 $g(b) = g(b^* )$，求证这两个元素在经过映射链 $\beta$ 与 $f'$ 的反向作用（我们以后就记这个反向作用为 $(f')^{-1}$ 了，这个记号是合理的，我们后面会提到） 后得到的元素在 $A'$ 中是等价的，其中等价关系由 $a' - a'^* \in \Img \alpha$ 给出。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果这个命题得到了验证，那么就说明这条路走得通，一个唯一的 $\Ker \gamma$ 中的 $c$，不论它在 $B$ 中对应有多少个元素，最后都会在 $A'$ 里对应到同一个等价类里，也就是在 $\Coker \alpha = A'/\Img \alpha$ 中有唯一的一个元素与之对应。这样就验证了 $\delta$ 的定义。&lt;/p&gt;
&lt;h4 id="delta-构造的验证"&gt;$\delta$ 构造的验证
&lt;/h4&gt;&lt;p&gt;我们开始上面这个命题的证明吧。这里需要注意的第一个问题，同时也是指明了我们应该朝着哪个方向前进的信息，是：我们最后要得到的内容是和 $\Img \alpha$ 有关的。为此，我们一定是要用到 $\alpha$ 这个映射的相关信息的，而这也不可避免地涉及到 $A$ 这个群。因此，我们得想办法先把 $g(b) = g(b^* )$ 这个信息反映到 $A$ 这个群内。&lt;/p&gt;
&lt;p&gt;好消息是，通过同态的性质，我们很容易就可以得到：$g(b-b^* ) = 0$，也就是说 $b-b^* \in \Ker g$。我们故技重施，得到 $b-b^* \in \Img f$，这让我们可以讨论已有的 $g(b)$，$g(b^* )$ 与 $A$ 中的元素的关系，即我们一定可以找到至少一个 $A$ 中的元素 $a$，使得 $f(a) = b-b^* $。&lt;/p&gt;
&lt;p&gt;我们通过图的交换性可以得知，$\beta f (a) = \beta (b-b^* ) = f'\alpha(a)$。这时我们需要用到关于单态的一个性质。这个性质我们之前也提过，甚至这是关于单态的定义：&lt;em&gt;具有左逆的态射为单态&lt;/em&gt;。如此一来，我们给第二个等号的左右两边同时作用上 $f'$ 的左逆。注意到左逆的定义，我们就有了：&lt;/p&gt;
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} f'\alpha(a) = \alpha(a)$$&lt;p&gt;回忆我们之前所提到的，$(f')^{-1}$ 由于 $f'$ 是单态，所以能唯一地确定 $B'$ 中元素在 $A'$ 中所对应的元素；$\beta$ 本身就是一个良定的同态，因此，以上这些就说明了这样一个事实：$(f')^{-1} \beta$ 是一个良定的从 $B$ 到 $A'$ 的同态，且 $(f')^{-1} \beta (b-b^* )$ 作为 $A'$ 的元素，它同时也是位于 $\Img \alpha$ 的。&lt;/p&gt;
&lt;p&gt;那么此时我们再使用 $(f')^{-1} \beta$ 作为同态的性质，有：&lt;/p&gt;
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} \beta (b)-(f')^{-1} \beta(b^* ) \in \Img \alpha$$&lt;p&gt;至此，我们对上面进行总结：设有两个 $B$ 中的元素 $b$ 与 $b^* $，它们满足 $g(b) = g(b^* )$，则我们可以在 $A'$ 中找到这样对应的两个元素 $(f')^{-1} \beta (b)$ 和 $(f')^{-1} \beta (b^* )$，使得这两个元素在我们已经定义好的等价关系下是等价的。&lt;/p&gt;
&lt;p&gt;如此，我们的这个命题得证。进而，我们就成功地构造出了良定的 $\delta$：&lt;/p&gt;
$$
\begin{align*}
\delta\vcentcolon\space\Ker\gamma&amp;\to\Coker\alpha\\
c&amp;\mapsto (f')^{-1} \beta (b) + \Img\alpha,
\end{align*}
$$&lt;p&gt;其中，$c \in \Ker \gamma$ 且 $c = g(b)$。&lt;/p&gt;
&lt;h4 id="一些旁注"&gt;一些旁注
&lt;/h4&gt;&lt;p&gt;我们可以看到，为了构造 $\delta$，我们必须利用 $g$ 的满态性质以及 $f'$ 的单态性质，还需要利用交换图右侧部分的交换性。而在验证其定义的过程中，我们同样必须利用 $g$ 的满态性质以及 $f'$ 的单态性质（这里 $g$ 的满态性是直接作为命题的前置条件而存在的），然后还需要利用交换图左侧部分的交换性。$\delta$ 的构造充分利用了我们已有的所有条件，因此算是这个引理证明比较困难的一部分，同时也是关键的部分。而关于前面 $f|$，$\hat{f'}$ 的构造与验证过程中，都只用到了图的交换性，并没有利用 $g$ 是满态以及 $f'$ 是单态的条件。&lt;/p&gt;
&lt;p&gt;我们再来关注 $\delta$ 的构造过程。我们从 $\Ker \gamma$ 中选择了任意的元素 $c$，它在 $g$ 的诸多原像 $b$ 们由于交换图的交换性质，在经过 $\beta$ 的映射到达 $B'$ 后都是位于 $\Img f'$ 上的。由于都在 $\Img f'$ 上，讨论 $(f')^{-1}$ 自然也是有意义的。&lt;/p&gt;
&lt;p&gt;另外我们结合后面对该定义的验证过程，可以看到这个元素 $c$ 是怎么一步步抵达 $\Coker \alpha$ 的：这个元素 $c$ 在 $B$ 中的原像可能包含一个或者多个元素，这些元素经过 $\beta$ 映射后都存在于 $\Img f'$ 中，这个过程里可能有些元素映射到了 $B'$ 里的同一个元素上，也有可能并不是这样，不过这里没有关系。接着它们在单射 $(f')^{-1}$ 的影响下，各不相同地映射到 $A'$ 上，最后分类到同一个等价类中（纯符号地讲，其实就是加上了 $\Img \alpha$）。&lt;/p&gt;
&lt;p&gt;验证过程说明了，只要都是在 $c\in\Ker\gamma$ 的原像里，注定都是会被分到同一个 $\Coker\alpha$ 的等价类里面的。然而，这个分类过程其实是在最后，在得到 $(f')^{-1}\beta(b)$ 后才完成的。好在，由于左侧块的交换性，在从 $c$ 找 $B$ 中原像的过程中，所有符合条件的 $b$ 之间的等价关系（指最终分类到同一 $\Coker \alpha$ 的元素中）早已被确定好了。&lt;/p&gt;
&lt;p&gt;这里再重申一下单态和满态的性质。单态意味着若陪域中的元素的原像要么非空，要么则只有一个元素，同时单态拥有唯一的左逆；满态则意味着陪域中的所有元素的原像都不是空集。我们利用满态原像的性质得出，$\Ker \gamma$ 中的元素一定可以在 $B$ 中找到对应元素，而又通过单态的性质得出，在已知 $\beta(b)$ 存在于 $f'^* $ 的条件下，$A'$ 中有且只有唯一一个元素与之对应，且通过给 $\beta (b-b^* )$ 作用左逆得出它存在于 $\alpha$ 的像内。&lt;/p&gt;
&lt;h3 id="operatornameker-beta-处正合性的证明"&gt;$\operatorname{Ker} \beta$ 处正合性的证明
&lt;/h3&gt;&lt;p&gt;前面我们证明了我们要验证的点的 1-5，借此我们成功地将这些核呀余核呀之类的连起来了。然而，要成为正合列，它需要在中间的每个点上都是正合的。现在已经到手的链条是这样的：&lt;/p&gt;
$$\Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma $$&lt;p&gt;这条链条的中间一共有 $\Ker\beta$，$\Ker\gamma$，$\Coker\alpha$，$\Coker\beta$ 四个点，我们需要分别验证它们两边的态射在它们自身处都是正合的。鉴于 $\delta$ 所连接的 $\Ker\gamma$，$\Coker\alpha$ 处的正合性会比较复杂（由于 $\delta$ 比较复杂），我们先验证 $\Ker \beta$ 处的正合性，再验证 $\Coker \beta$ 的，最后到剩下的两个。&lt;/p&gt;
&lt;p&gt;为了验证正合性，我们需要验证：$\Img f| = \Ker g|$。由于链条上的都是态射，这个等号只需要集合意义上的成立即可在阿贝尔群意义上同样成立，而证明两个集合相等最常用的方法之一便是验证相互包含：$\Img f| \subseteq \Ker g|$ 且 $\Img f| \supseteq \Ker g|$，而为了实现这样的目的，我们会从待验证命题中较小的集合中取点，证明它一定在较大的那个集合中，即可验证这样的子集关系了。&lt;/p&gt;
&lt;p&gt;在我们开始之前，我们把 $\Ker \beta$ 所在短链条写出来，方便后面观察：&lt;/p&gt;
$$ \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma $$&lt;p&gt;那我们就开始吧，先从 $\Img f| \subseteq \Ker g|$ 开始。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-f-subseteq-operatornameker-g"&gt;证明 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$
&lt;/h4&gt;&lt;p&gt;我们就取 $\Img f|$ 中的一个元素 $b$，根据像的性质，一定有一个 $a\in \Ker\alpha$ 满足 $f|(a) = b$。而 $f|(a)$ 实际上就是 $f$ 在 $\Ker \alpha$ 上的一个限制，所以也就有 $f(a) = b$；同时，我们取 $g|(b) = c$，由于 $g|$ 也是 $g$ 在 $\Ker\beta$ 上的限制，所以 $g|(b) = g|(f(a)) = g(b) = g(f(a)) = c$。此时，我们考虑原正合列：&lt;/p&gt;
$$A\xrightarrow{f} B \xrightarrow{g} C,$$&lt;p&gt;
我们得到：$f(g(a)) = 0$。由此就得到了 $c = 0$。由于这个结论不依赖于 $b$ 的选取方式，我们就以这种方式得到了 $g|(b) = c = 0$ 恒成立，进而 $b \in \Ker g|$。而这，正说明了这样一件事：如果一个 $\Ker \beta$ 中的元素 $b$ 在 $\Img f|$ 里，那么它就一定在 $\Ker g|$ 中。这就证明了 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$。&lt;/p&gt;
&lt;p&gt;这个命题的得证完全依赖与原正合列的性质，且通过证明该命题，我们得知上面的短链条已经是一个链复型了。下面我们需要证明的就是另一个方向的包含性，也就是：&lt;/p&gt;
&lt;h4 id="证明-operatornameim-f-supseteq-operatornameker-g"&gt;证明 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$
&lt;/h4&gt;&lt;p&gt;我们故伎重施，取 $\Ker g|$ 中的一个元素，也叫它 $b$ 好了。既然它在 $g|$ 的核中，那么就有 $g|(b) = 0$，我们此时把 $b$ 放到 $B$ 集合中，此时 $g|(b) = g(b) =0$，说明 $b\in\Ker g$。而根据原链条的正合性，我们有 $\Ker g = \Img f$，因此 $b\in\Img f$。&lt;/p&gt;
&lt;p&gt;然而到此依然不能证明 $b\in\Img f|$，因为 $\Img f|$ 是 $\Img f$ 的子集，无法从一个元素位于更大的集合中来判定它一定在更小的集合里。我们需要更多的信息。然而既然 $b\in\Img f$，我们就可以找到 $A$ 中的一个元素 $a$，使得 $f(a) = b$。又因为根据 $b$ 的取法，它在 $g|$ 的定义域 $\Ker \beta$ 上，一定就有 $\beta(b) = \beta(f(a)) = 0$。此时，我们根据交换图的性质，可以得到 $f'(\alpha(a)) = \beta(f(a)) = 0$。&lt;/p&gt;
&lt;p&gt;这样的结果有什么用处呢？回忆 $f'$ 的性质，它是一个单态，因此就一定有左逆 $(f')^{-1}$。我们给上式的左右两边同时左乘（左作用）上 $(f')^{-1}$，就得到：$(f')^{-1}f'(\alpha(a)) = (f')^{-1}(0) = 0 = \alpha(a)$。观察最后一个等号，这又说明了 $a \in \Ker \alpha$。&lt;/p&gt;
&lt;p&gt;我们整理一下当前得到的信息，我们有 $\Ker g|$ 中的一个元素 $b$，它在 $A$ 中有一个对应的元素 $a$，我们又得到了这个元素 $a\in\Ker\alpha$。请注意 $f|$ 的定义域正是 $\Ker\alpha$。这就说明了：$b$ 在 $A$ 中对应的元素一定也在 $\Ker\alpha$ 里，也就是 $b\in\Img f|$。同样，由于 $b$ 的选取不依赖于任何的额外条件，我们就证明了 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$。至此，联合上一小节的结论，我们得出结论：该短链在 $\Ker\beta$ 处正合。&lt;/p&gt;
&lt;h4 id="一点注解"&gt;一点注解
&lt;/h4&gt;&lt;p&gt;可以看到，前半部分的证明非常简单，直接借助原正合列性质即可，这样直接就证明了这个链条是一个链复型；而后面为了证明正合性的部分则需要使用到 $f'$ 是单态的条件。也许我们在证明 $\Coker \beta$ 处的正合性时，也会遇到这样的特点？我们直接开始吧。&lt;/p&gt;
&lt;h3 id="operatornamecoker-beta-处正合性的证明"&gt;$\operatorname{Coker} \beta$ 处正合性的证明
&lt;/h3&gt;&lt;p&gt;和上面一样，我们证明这样的正合性，会以对应映射的像与核相互包含为切入点进行。这次我们还是先证明这个短链：&lt;/p&gt;
$$
\Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta \xrightarrow{\hat{g'}} \Coker \gamma
$$&lt;p&gt;是一个链复型（$\Img \hat{f'} \subseteq \Ker \hat{g'}$），再证明在中间的 $\Coker \beta$ 处是正合的（$\Img \hat{f'} \supseteq \Ker \hat{g'}$）。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-hatf-subseteq-operatornameker-hatg"&gt;证明 $\operatorname{Im} \hat{f'} \subseteq \operatorname{Ker} \hat{g'}$
&lt;/h4&gt;&lt;p&gt;照旧我们选择 $\Img \hat{f'}$ 中的一个元素，由于 $\Img \hat{f'} \subseteq \Coker \beta$，这个元素将会是等价类 $\hat{b'} = b' + \Img \beta$。我们想要证明，在前面这个条件下的任何 $\hat{b'}$ 都会被 $\hat{g'}$ 映射到 $\hat{0} \in \Coker \gamma$ 上。既然 $\hat{b'}\in\Img\hat{f'}$，我们就可以取到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$，使得 $\hat{f'}(\hat{a'}) = \hat{b'}$。&lt;/p&gt;
&lt;p&gt;此时，请回忆我们是如何定义 $\hat{f'}$ 的：我们直接借助了原有的同态 $f'$，使得具有了这样的性质：&lt;/p&gt;
$$\hat{f'}(\hat{a'}) = \hat{f'}(a'+\Img \alpha) = f'(a') + \Img \beta = b'+\Img \beta = \hat{b'} = \widehat{f'(a)}.$$&lt;p&gt;带着这条性质，我们观察到：若是对 $\hat{b'}$ 作用上 $\hat{g'}$，就有：&lt;/p&gt;
$$\hat{g'}(\hat{b'}) = \hat{g'}(\hat{f'}(\hat{a'})) = \hat{g'}(\widehat{f'(a')}) = \widehat{g'(f'(a'))} = \hat{0},$$&lt;p&gt;其中，第一个等式是我们一开始取到的 $\hat{f'}(\hat{a'}) = \hat{b'}$，第二个等式是利用了我们上面给出的 $\hat{f'}$ 的性质，而第三个等式则是同样，再次利用 $\hat{g'}$ 它与 $\hat{f'}$ 同样的性质（因为定义是类似的）。最后，第四个等式则利用了原正合列的性质，有 $g'(f'(a')) = 0$。由此，我们再一次地，像上面证明 $\Ker \beta$ 处正合的第一部分一样，证明了 $\Coker \beta$ 处正合的第一部分：无论 $\hat{b}$ 如何取，只要它位于 $\Img \hat{f'}$ 中，就一定位于 $\Ker \hat{g'}$ 中。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-hatf-supseteq-operatornameker-hatg"&gt;证明 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$
&lt;/h4&gt;&lt;p&gt;下来我们就证明 $\Coker \beta$ 处正合的第二部分。我们希望能从 $\Ker \hat{g'}$ 中取到的元素能够以某种方式放到 $B'$ 中去，然后借助原正合列的性质去取得在 $A'$ 中或者 $\Coker \alpha$ 中的一些结论。 因此依旧，我们取 $\hat{b'} \in \Ker \hat{g'} \subseteq \Coker \beta$。由于 $\hat{b'}$ 在 $\hat{g'}$ 的核中，我们有 $\hat{g'}(\hat{b'}) = \hat{0}$。我们把这个运算拆开，有&lt;/p&gt;
$$\begin{align*}
\hat{g'}(\hat{b'}) &amp;= \hat{g'}(b' + \Img \beta) \\
&amp;= g'(b') + \Img \gamma\\
&amp;= \hat{0} = \Img \gamma,
\end{align*}$$&lt;p&gt;
由此可以得知，$g'(b') \in \Img \gamma$。然而，这和我们之前所做到的并不一样：$g'(b')$ 只是位于 $\Img \gamma$ 中，它并不等于 $0$。不过，我们依旧可以借助这个条件。&lt;/p&gt;
&lt;p&gt;从 $g'(b') \in \Img \gamma$ 条件中可以得知，一定有一个 $c \in C$ 使得 $\gamma(c) = g'(b')$。而此时，又由于 $g$ 是满射，我们知道一定有一个 $b \in B$ 使得 $g(b) = c$。把它们组合起来，就有了： $\gamma(g(b)) = g'(b')$，此时根据交换图的性质，就有了 $g'(b') = \gamma(c) = g'(\beta(b))$。我们现在把最右边这项移项到最左边，就有了 $g'(b'-\beta(b)) = 0$。&lt;/p&gt;
&lt;p&gt;通过上面的方式，我们成功构造出了一个位于 $g'$ 的核中的元素。因此，直接借助短链&lt;/p&gt;
$$A'\xrightarrow{f'} B' \xrightarrow{g'} C'$$&lt;p&gt;是正合的这一条件，就有：$b'-\beta(b) \in \Ker g' = \Img f'$。&lt;/p&gt;
&lt;p&gt;我们现在再看看这个新构造出的，位于 $\Img f'$ 中的这个元素的等价类是什么样的。我们把 $\hat{b'}$ 写成 $b' + \Img \beta$ 的形式，此时又由于 $\beta(b)$ 自然就在 $\Img \beta$ 中： $\beta(b) \in \Img \beta$，我们就有 $b'+\Img \beta = b' - \beta(b) + \Img \beta$。这意味这我们新构造出的这个更好的元素，它与我们一开始选择的 $b'$ 是等价的，都可以作为 $\hat{b'}$ 的代表元。&lt;/p&gt;
&lt;p&gt;现在我们现在想知道的是，对于等价类 $\hat{b'} = b'-\beta(b) + \Img \beta$，是否一定存在 $\Coker \alpha$ 中的某个等价类，使得它在 $\hat{f'}$ 的作用下就是我们已有的 $\hat{b'}$。为此，我们回到刚刚构造出的，位于 $\Img f'$ 中的这个元素 $b'-\beta(b)$。既然在 $f'$ 的像内，就一定有一个或者几个元素 $a' $ 满足 $f'(a' ) = b'-\beta(b)$。我们知道，$a'$ 在 $A'$ 中的等价类是 $\hat{a'} = a'+\Img \alpha$。而该等价类经过 $\hat{f'}$ 的作用后得到的结果是：&lt;/p&gt;
$$
\hat{f'}(a'+\Img\alpha) = f'(a') + \Img\beta = b'-\beta(b) + \Img\beta = b'+\Img\beta.
$$&lt;p&gt;好，我们现在总结我们已有的信息。我们从一个任意的 $\Coker \beta$ 中的元素 $\hat{b'}$ 出发，构建出了一个位于 $\Ker g'$ 中的元素 $b'-\beta(b)$，其中 $b$ 是直接根据 $b'$ 确定的。这个新的元素所处的等价类就是我们之前挑选的等价类。另外，我们从构造的元素出发，得到了若干个位于 $A'$ 中的元素 $a'$。它所在的等价类则是 $\hat{a'}\in\Coker \alpha$。现在，我们可以注意到：我们只挑出来了一个 $\hat{b'}$，剩下的所有的东西都是由它以及它相关的量决定的。也就是说，$\hat{b'}$ 决定了这些 $\hat{a'}$。而经过上面式子的验证，有 $\hat{f'}(\hat{a'}) = \hat{b'}$。这就说明了：任取一个位于 $\hat{g'}$ 的核内的元素，我们都能确定出一些 $\hat{a'}$，它们全都是满足 $\hat{f'}(\hat{a'}) = \hat{b'}$ 的。&lt;/p&gt;
&lt;p&gt;这就证明了我们想要的结论：任意一个 $\hat{g'}$ 的核内的元素都是 $\Coker \alpha$ 中元素的像，也就是 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$。再结合上一节证明的内容，我们就证明了这个链条在 $\operatorname{Coker} \beta$ 处是正合的。&lt;/p&gt;
&lt;h4 id="callback"&gt;Callback
&lt;/h4&gt;&lt;p&gt;可以看到，对于 $\operatorname{Coker} \beta$ 处正合性的证明，是和 $\operatorname{Ker} \beta$ 处正合性的证明很类似的。不过我个人感觉，后面证明的这个，相比于 $\operatorname{Ker} \beta$ 处正合性的证明是要难一些的。这可能是因为需要手动构造一个 $b'-\beta(b)$ 来满足应用正合性的条件，以及对余核的性质的不熟悉吧。总之，顺利地证明了。而下面要证明的，就和我们自己构造出的 $\delta$ 相关了。&lt;/p&gt;
&lt;h3 id="operatornameker-gamma-处正合性的证明"&gt;$\operatorname{Ker} \gamma$ 处正合性的证明
&lt;/h3&gt;&lt;p&gt;接下来我们尝试证明短链&lt;/p&gt;
$$\Ker\beta\xrightarrow{g|}\Ker\gamma\xrightarrow{\delta}\Coker\alpha $$&lt;p&gt;在中间一点处的正合性。我们依旧采取原来的策略。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-g-subseteq-operatornameker-delta"&gt;证明 $\operatorname{Im} g| \subseteq \operatorname{Ker} \delta$
&lt;/h4&gt;&lt;p&gt;照旧取一个 $\Img g|$ 中的元素 $c\in C$，我们希望能证明 $\delta(c) = \hat{0}$ 恒成立，这样一来自然就有 $\Img g| \subseteq \Ker \delta$ 了。&lt;/p&gt;
&lt;p&gt;既然 $c\in\Img g|$，就会有一个元素 $b\in \Ker\beta$ 使得 $g|(b) = c$。又由于这个 $b$ 是在 $\beta$ 的核中的，因此 $\beta(b) = 0$。此时我们再作用上 $(f')^{-1}$，由于 $f'$ 是单态，所以把 $0\in B'$ 作用上它的左逆只能得到唯一的元素 $0\in A'$，而这对应的 $\Coker \alpha$ 中作为元素等价类正是 $\hat{0}$。&lt;/p&gt;
&lt;p&gt;注意到我们上面的步骤，实际上就是在对 $c$ 作用 $\delta$。因此，我们得到了我们想要的结论：$\delta(c) = \hat{0} \in \Coker \alpha$，也就证明了本命题。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-g-supseteq-operatornameker-delta"&gt;证明 $\operatorname{Im} g| \supseteq \operatorname{Ker} \delta$
&lt;/h4&gt;&lt;p&gt;我们还是取 $c\in \Ker \delta$。因此，$\delta(c) = \hat{0} = 0 + \Img \alpha$。我们回顾 $\delta$ 的构造，或者说从 $c\in\Ker\gamma$ 出发抵达 $\Coker \alpha$ 的过程，如果 $\delta(c) = \Img \alpha$，那么 $c$ 就一定会经理这样的过程：它首先在 $B$ 中找到原像中的元素 $b$ 们，然后把这些元素打包被 $\beta$ 映射到 $B'$ 上，此时由于我们的构造，所有的 $\beta(b) \in \Img f'$。此时就一定有许多对应的 $a' \in A'$ 满足 $f'(a') = \beta(b)$。最后由于 $\delta(c) = \hat{0} = \Img \alpha$，必须要有 $a' \in \Img\alpha$ （注意，不是 $a' = 0$，因为只需属于 $\Img \alpha$ 即可满足条件）。&lt;/p&gt;
&lt;p&gt;经过上面的过程，我们得到了这样和原条件等价的条件，即必须至少有一个 $a'\in\Img\alpha$，它由 $f'(a') = \beta(b)$ 确定，而 $\beta(b)$ 中的 $b$ 则从 $c$ 的原像中找到。&lt;/p&gt;
&lt;p&gt;因此，我们先关注这个集众多条件于一身的 $a'$，由于其处在 $\alpha$ 的像内，就一定有 $a\in A$ 使得 $\alpha(a) = a'$。此时我们从 $a$ 出发，利用交换图的性质，就有 $f'(\alpha(a)) = \beta(f(a))$。注意到我们 $a'$ 上的两个条件，将它们带入这个关系，就得到 $f'(\alpha(a)) = f'(a') = \beta(b) = \beta(f(a))$。&lt;/p&gt;
&lt;p&gt;我们关注最后一个等号，它说明了这样的问题：$\beta(b) = \beta(f(a))$，则有 $\beta(b-f(a)) = 0$，也就是 $b-f(a)$ 是属于 $\Ker \beta$ 的。回顾这个元素的构造过程，$b$ 是任意一个在 $c$ 的原像中的元素，这里的 $a$ 是根据 $a'$ 任意选取的在原像内的元素，$a'$ 又是 $\beta(b)$ 在其原像内任意选取的元素。我们看到，$b$ 和 $a$ 都是除了利用 $c\in\Ker\gamma$ 和交换图性质以外任意选取的符合条件的元素，如果对它作用 $g|$ 之后能够回到 $c$，就说明这样的一件事：$c$ 的原像内元素不管怎么选，总会以某些形式回到 $\Ker\beta$，进而映射到 $g|$ 的原像内。&lt;/p&gt;
&lt;p&gt;幸运的是，这很好验证：$g|(b-f(a)) = g(b-f(a)) = g(b) - g(f(a)) = g(b) = c$。第一个等号来自 $g|$ 的定义，当将之放入 $B$ 中考虑是就可以使用 $g$ 替代；第二个等号来自 $g$ 是同态的保运算性质；第三个等号来自链复型的要求；而最后一个等号就是我们一开始选取 $b$ 的方式。这正是说明了我们前面讲的：$c$ 原像中的 $b$，会以 $b-f(a)$（其中 $a$ 也是由 $c$ 间接决定的）的形式出现在 $\Ker\beta$ 里，最后被 $g|$ 映射回 $c$，而这就证明了任何一个 $\Ker\gamma$ 中的元素，其都是 $\Img g|$ 中的元素，也就证明了本命题。再结合上一条命题的证明，我们成功得到了这条链条在 $\Ker\gamma$ 上的正合性。&lt;/p&gt;
&lt;h4 id="一点绕过的弯路"&gt;一点绕过的弯路
&lt;/h4&gt;&lt;p&gt;第二个命题的证明其实没有特别顺利。这主要是因为对 $\delta$ 构造的理解不够导致的，或者说太过希望 $\delta$ 有一个好的显式表达而造成的。在取到 $a' = \alpha(a)$ 的时候，我希望直接得到 $b$ 是一定属于 $\Ker\beta$ 的结论，虽然感觉上会有和之前类似的从 $b$ 出发构造的属于 $\Ker\beta$ 的元素一样的桥段，但由于依赖 $\delta$ 的显示表达，我卡在了 $(f')^{-1}$ 只是左逆而非右逆这一点上。因为如果按照我之前的思路，就一定要遇到 $f'((f')^{-1}(\beta(b)))$ 这样的元素。而由于 $(f')^{-1}$ 并非右逆，这个式子是无法约化到 $\beta(b)$ 上的。&lt;/p&gt;
&lt;p&gt;可以看到，最后解决这个问题的方法，是直接采用 $\delta$ 在构造过程中的表现，在从 $B'$ 至 $A'$ 的过程中选择使用 $\beta(b)$ 一定在 $f'$ 的像中的条件，从而绕过了这个问题。虽然说用形式化的思路，比如限定这里 $f'$ 的范围，从而让做出一些限定条件的 $f'$ 成为同构来解决这个问题，但这始终不是个很好的方案。&lt;/p&gt;
&lt;p&gt;另外，就是 $b$ 一定属于 $\Ker\beta$ 的错觉。实际上，$b$ 可以不在 $\Ker\beta$ 中，只需要 $b$ 和某个经过 $g|$ 映射后等于 $0$ 的东西结合之后位于 $\Ker\beta$ 即可。当然我们现在知道，这个东西就是从 $c$ 一路确定下来的 $f(a)$ 了。&lt;/p&gt;
&lt;p&gt;好了，我们开始准备证明蛇引理主体的最后一部分吧：$\Coker\alpha$ 处的正合性。&lt;/p&gt;
&lt;h3 id="operatornamecoker-alpha-处正合性的证明"&gt;$\operatorname{Coker} \alpha$ 处正合性的证明。
&lt;/h3&gt;&lt;p&gt;我们不多废话，还是先证明 $\Img \delta \subseteq \Ker \hat{f'}$，后证明 $\Img \delta \supseteq \Ker \hat{f'}$。对应的短链是：&lt;/p&gt;
$$\Ker \gamma \xrightarrow{\delta} \Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta$$&lt;h4 id="证明-operatornameim-delta-subseteq-operatornameker-hatf"&gt;证明 $\operatorname{Im} \delta \subseteq \operatorname{Ker} \hat{f'}$
&lt;/h4&gt;&lt;p&gt;取 $\Img \delta$ 中的元素 $\hat{a'} \in \Coker\alpha$，通过证明 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$ 即可证明本命题。由于 $\hat{f'}$ 的定义，我们有 $\hat{f'}(\hat{a'}) = \widehat{f'(a')} = f'(a') + \Img \beta = 0 + \Img \beta$，也就是说只需要证明 $f'(a') \in \Img \beta$，我们就能证明本命题。由于 $\hat{a'}\in\Img\delta$，一定有一个 $\Ker\gamma$ 中的元素 $c$ 满足 $\delta(c) = \hat{a'}$。&lt;/p&gt;
&lt;p&gt;我们这时使用 $\delta$ 的定义：若 $\delta(c) = \hat{a'}$，就说明一定有一个 $b\in B$，这个 $b$ 在 $c$ 的原像中，而且 $\beta(b) = f'(a')$。啊，这不就是我们要的结论吗？既然 $f'(a') = \beta(b)$ 了，那自然 $f'(a')$ 就在 $\beta$ 的像里面了呀。就这样，我们证明了这个命题。&lt;/p&gt;
&lt;h4 id="证明-operatornameim-delta-supseteq-operatornameker-hatf"&gt;证明 $\operatorname{Im} \delta \supseteq \operatorname{Ker} \hat{f'}$
&lt;/h4&gt;&lt;p&gt;还是一样，取 $\Ker \hat{f'}$ 中的元素 $\hat{a'} \in \Coker\alpha$。既然在 $\Ker\hat{f'}$ 里，我们就有 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$（我们是不是刚刚见过这句，那就快进吧），进而 $f'(a') \in \Img \beta \subseteq B'$。那么，既然是在 $\Img \beta$ 中的，我们就取所有满足 $\beta(b) = f'(a')$ 的 $b\in B$。此时我们用交换图右侧的交换性，给这个式子左右两边左作用上 $g'$，就得到&lt;/p&gt;
$$0 = g'(f'(a')) = g'(\beta(b)) = \gamma(g(b)),$$&lt;p&gt;其中第一个等号来自交换图下面的链复型的性质，第二个等号就是作用 $g'$ 的结果，第三个等号则是交换图的性质。观察这个式子的左右两端，不难根据核的定义得到结论：只要是满足条件的 $b$，$g(b)$ 就全都在 $\Ker \gamma$ 中。&lt;/p&gt;
&lt;p&gt;到这里其实已经证明完了，因为我们仅从 $\hat{a'}\in\Ker\hat{f'}$ 出发，仅利用交换图就得到了所有满足条件的 $b$，证明了它们全都会在 $g$ 的作用下进入到 $\Ker\gamma$ 里，也就是说，$\hat{a'}$ 确定了且一定对应到了 $\Ker\gamma$ 中的某些元素。这就说明了 $\Img \delta \supseteq \Ker \hat{f'}$。&lt;/p&gt;
&lt;p&gt;我们写详细点，多写几步，那么让 $g(b) = c$，根据 $\delta$ 的定义（或者作用过程），对 $c$ 作用上 $\delta$ 后，将会先有若干个满足 $g(b) = c$ 的 $b$，紧接着这些 $b$ 将被 $\beta$ 映射到 $B'$ 里，最后从 $A'$ 里找到对应的原像，用它们生成一个等价类。而由于我们上面的过程，最后找到的 $A'$ 中的元素所生成的等价类，就是我们一开始的 $\hat{a'}$。这就说明 $\delta(c) = \hat{a'}$。 由于 $\hat{a'}$ 是我们随意取的在 $\Ker\hat{f'}$ 中的元素，都能得到 $\delta(c) = \hat{a'}$，因此 $\hat{a'}$ 确实就存在于 $\Img \delta$ 里。&lt;/p&gt;
&lt;p&gt;至此，我们证明了该命题，并结合上一个证明的命题，一起证明了链条在 $\Coker \alpha$ 处是正合的。&lt;/p&gt;
&lt;h3 id="虚线箭头的相关证明"&gt;虚线箭头的相关证明
&lt;/h3&gt;&lt;p&gt;其实上面已经证明完了蛇引理的主体部分。下来我们将证明最后的两个命题：若交换图中的上下两个链条都是短正合列（也就是有 $0\to A$ 和 $C' \to 0$ 成立），那么在从该交换图中得到的正合列的头尾就可以补上 $0\to\Ker\alpha$ 以及 $\Coker\gamma\to 0$，使得 $\Ker\alpha$ 以及 $\Coker\gamma$ 处正合。&lt;/p&gt;
&lt;p&gt;我们还是先证第一个，也就是从 $0\to A$ 的存在可以得到 $0\to\Ker\alpha$ 且 $\Ker\alpha$ 处正合。&lt;/p&gt;
&lt;h4 id="证明-operatornamekeralpha-处的正合性"&gt;证明 $\operatorname{Ker}\alpha$ 处的正合性
&lt;/h4&gt;&lt;p&gt;若有 $0\to A$，则根据正合列的性质（或者直接看交换图下面的那个链条），我们就有 $f$ 也是个单态。因此，对 $f$ 做出在 $\Ker\alpha$ 上的限制得到的 $f|$ 并不会改变它是单态的事实（只缩小了定义域）。此时，由于 $f|$ 是单态，它的核根据单态的性质，就一定是一个平凡群。&lt;/p&gt;
&lt;p&gt;此时我们补上 $0\to\Ker\alpha$，由于它一定是单态，它的像只能是平凡群。这自然地就证明了链条在 $\Ker\alpha$ 处是正合的。&lt;/p&gt;
&lt;h4 id="证明-operatornamecokergamma-处的正合性"&gt;证明 $\operatorname{Coker}\gamma$ 处的正合性
&lt;/h4&gt;&lt;p&gt;如果有 $C'\to 0$，则根据正合列的性质，我们知道 $g'$ 就必须是满态，这也就意味着 $\Img g' = C'$。&lt;/p&gt;
&lt;p&gt;我们来看我们定义出的 $\hat{g'}\vcentcolon\space\Coker\beta\to\Coker\gamma$，任取它的定义域上的一个元素 $\hat{b'} = b'+\Img\beta$，经过 $\hat{g'}$ 映射后得到的 $\Coker\gamma$ 中对应的元素则是 $g'(b') + \Img\gamma$。然而由于 $\Img g' = C'$，这说明 $g'(b')$ 会随着所有对 $\hat{b'}$ 的选取而跑遍任何一个这里的 $C'$ 中的元素，进而使 $\hat{g'}$ 也是一个满态。自此，我们就可以给 $\Coker\gamma$ 的右端补上 $\Coker\gamma\to 0$ 的同时保持其正合性，因为补上的映射的核正是 $\Coker\gamma$。&lt;/p&gt;
&lt;h3 id="证完串起来"&gt;证完串起来
&lt;/h3&gt;&lt;p&gt;至此，我们完全证明了前面列出的所有结论，进而证明了蛇引理。简单盘点我们证明过的东西，我们做了这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造了五个阿贝尔群间的同态，一一验证了它们的定义是 OK 的；&lt;/li&gt;
&lt;li&gt;对四个点上的正合性做出证明，具体是先向前得到前一个同态的像在后一个的核内，再证明后一个的核再前一个的像内，从而得到正合&lt;/li&gt;
&lt;li&gt;对得到的正合列在交换图上下链条都是短正合列的情况做出补充。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里有几个值得一提的点。首先，我们在一开始就得到了 $f|$ 和 $g|$ 的定义，它貌似是直接给出的，但应该是由我们自己定义的，即便定义好之后也是同样的形式。由于阿贝尔群同态的核天生就是其定义域上的阿贝尔子群，除了使用原同态在核上的限制来定义以外，并没有什么更好的定义方法了。&lt;/p&gt;
&lt;p&gt;另外，我们尝试给定义的 $\delta$ 一个具体的表达式，然而这个做法其实可能并不好（我们也应该已经看到了，$(f')^{-1}$ 可能会造成一些问题）。这个同态可以被称作 &lt;em&gt;连接同态&lt;/em&gt;，是蛇引理中连接上下两个正合列的的很重要的一个同态。&lt;/p&gt;
&lt;p&gt;然后，就余核来看，如果对它的一些性质更加熟悉，可能证明过程会更加简单。不过我们也在证明过程中看到了关于它的一些性质，这里就不再赘述，只提一点，就是余核内的单位元（零元）代表的不是简单的 $0$，而是一个等价类。我们还可以看到核与余核之间的一些微妙的联系。然而这里就不过多讨论这些了，这些更多是属于范畴论的内容。从范畴的角度来看，它们的区别就是用来定义的交换图内的箭头方向不一样而已。&lt;/p&gt;
&lt;p&gt;还有就是，我们对正合性做出验证时，并没有按照从左向右的顺序，而是先验证了处于交换图中间位置对应的点的正合性，再验证了两边的。这也许是受到了我所看的视频的影响吧。我想在这里做出另一个推荐的证明顺序，即从链条的左边开始，先证明这个链条是一个链复型，再证明它的正合性。从上面的证明过程来看，其实证明它是链复型的过程非常简单，难点则是那个反包含的证明。当然，我暂时也不计划再证明一次，这次写的很多了，就这样吧。&lt;/p&gt;
&lt;p&gt;此外，基础版本的蛇引理不包含最后的两个同态，就是 $0\to A$ 和 $C'\to 0$。另一个角度来讲，为了从交换图中得到一条正合列，我们只需要这些最低限度的条件。不过，蛇引理还可以继续拓展下去，不过就不叫蛇引理了。&lt;/p&gt;
&lt;p&gt;最后，我们要指出，我们这里做证明的方法，就是所谓的追图（Diagram Chasing）。这种方法从交换图的某个点内的元素为起点，沿着交换图中的态射移动，最终 “追” 到我们需要的元素为止，从而证明某个结论。追图是同调代数中重要的证明方法，其中最基础的一个证明例子便是这里的蛇引理。不过，这里的证明确实较为冗长，如果借助更高级更复杂的数学工具/技巧，比如范畴论，那么证明应该会更加简短一些，形式也更精简一些，不过可能很难看懂，我也不会这些（）&lt;/p&gt;
&lt;h2 id="证毕后的一点感想"&gt;证毕后的一点感想
&lt;/h2&gt;&lt;p&gt;一开始动工的时候，我是没想到竟然能写这么多的。也许是因为我太罗嗦了吧，前面讲了很多的前置，也不知道讲清楚没有，而后面证明过程的很多话又都是套话；又或者我觉得写详细一些，易懂一些，可能会比较好，所以就把证明过程中我的一些想法以及口头的一些表达揉进去了。个人而言我还是挺喜欢思考这些东西并把思考过程写下来的。我也有想过把这篇拆成几个部分，不过目前先写在一起吧。即便看完这么多也需要好久好久。&lt;/p&gt;
&lt;p&gt;可以看到里面有一些可以点开的隐藏了的内容，有许多还没有写好，标记着 “Under Construction~”。这些内容应该会在某天我心血来潮之后再次补好吧（补档：我写好了！）。不过也有可能会删掉，或者直接拆分出来？我也不好现在就下判断。另外我还计划在这篇文章的后面，也就是在证明结束后，再补一个不那么啰嗦的证明过程。这样的话，已经有代数基础的朋友也许就可以直接跳到精简版的来看？emmm不过既然已经有代数基础了，想必来看这篇也就是图一乐了。还是希望能嘴下留情~ 作为一个普通的数学爱好者，能证完这个我感觉还挺有成就感的啦。&lt;/p&gt;
&lt;p&gt;不过必须承认的是，写的过程中我还是回头修改了不少表述不太合适的部分，以及这篇证明是离不开网络上的众多优秀资料的帮助的。感谢互联网，互联网万岁！~&lt;/p&gt;
&lt;p&gt;最后，祝您身心健康，生活愉快~&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;我其实挺纠结应该说 &lt;em&gt;函数&lt;/em&gt; 还是 &lt;em&gt;映射&lt;/em&gt; 的。函数我认为用以指代给集合上每个点指派一个数字的东西更合适，更符合我心目中对函&lt;strong&gt;数&lt;/strong&gt;的想象。而映射又太广泛了，因为很多地方代数结构之间不会一板一眼地讲 “同态”，而是直接就说映射了。思来想去，还是函数更合适，毕竟接触最多，接受程度也最广泛。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;这里所谓的合理性，在一般数学教材中称为良定义，而一个定义是合理的也被称为良定的。很奇怪的说法……良定……&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;有数学家表示应区别含幺环范畴 $\mathsf{Ring}$ 与不含幺的环范畴 $\mathsf{Rng}$，我觉得环应该含有乘法幺元，且应该省略元音字母 $\mathsf{i}$，所以写成这样。请根据上下文确定环范畴具体是什么样的含义。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item><item><title>多相场模型与巨势方程</title><link>https://a-moment096.github.io/posts/2025/01/mpf_gp/</link><pubDate>Sun, 05 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/01/mpf_gp/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/01/mpf_gp/ShoujouRei_MikitoP.png" alt="Featured image of post 多相场模型与巨势方程" /&gt;&lt;p&gt;&lt;em&gt;记录一下目前使用到的两个相场模型，包括它们的推导，假设和缺陷&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图出自 &lt;a class="link" href="https://twitter.com/katorei_" target="_blank" rel="noopener"
&gt;かとうれい&lt;/a&gt; 太太， 为 &lt;a class="link" href="https://space.bilibili.com/108833238" target="_blank" rel="noopener"
&gt;Mikito P&lt;/a&gt; 所作的 &lt;a class="link" href="https://www.bilibili.com/list/ml1197098078?spm_id_from=333.1007.0.0&amp;amp;oid=27304533&amp;amp;bvid=BV1Rs411N7Aq" target="_blank" rel="noopener"
&gt;少女レイ&lt;/a&gt; 的曲绘&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=1334077117" theme="#2980b9" loop="none"&gt;&lt;/meting-js&gt;
&lt;h2 id="简介"&gt;简介
&lt;/h2&gt;&lt;p&gt;目前在做的 U-Nb 体系不连续析出的模拟，里面用到了这两个演化方程。之前一直没有仔细思考过这两个演化方程到底是什么来头，为什么这个体系适合使用这两个方程，导致现在想大概修改一下它们也无从下手。这里就作为笔记记录下这两个方程的推导方法，优缺点，以及我个人的一些看法吧。&lt;/p&gt;
&lt;h2 id="多相场模型"&gt;多相场模型
&lt;/h2&gt;&lt;h3 id="模型介绍"&gt;模型介绍
&lt;/h3&gt;&lt;p&gt;多相场模型（或者说是界面场模型，差不多吧）是适用于非保守场的演化方程，来自于 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
&gt;I. Steinbach 和 F. Pezzolla 的文章&lt;/a&gt;。它的形式为：&lt;/p&gt;
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p&gt;这里的 $F$ 是自由能泛函，$\tilde{N}$ 是有效序参量的个数，$\tilde{L}_{\alpha\beta}$ 是有效序参量里两相之间的界面移动参数，而括号内的差则是表示一种算符，即&lt;/p&gt;
$$
\left(\frac{\delta }{\delta \phi_\beta} - \frac{\delta }{\delta \phi_\alpha} \right)F = \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha}.
$$&lt;p&gt;简单来说，这篇文章考虑了使用界面场来描述不同相之间的界面并且演化，而非使用相自身的序参量作为演化参量。虽然最后还是会落到使用相自身的序参量来演化，但是界面场的思想融入到来这个演化模型中。最主要的改进应该是在考虑界面场的同时，考虑每个点处的有效序参量，也就是不为 0 的相的序参量，这样一来还可以简化计算（虽然实际计算过程中也可以只用传统的所有相的计算就是了）。&lt;/p&gt;
&lt;p&gt;平心而论，这篇文章写的逻辑结构并不是非常清晰，公式推导过程更是灾难，甚至符号都有一些问题，但是谁让这个模型好用呢？那就不多讲废话了，直接开始推导这个方程吧。要注意的是，这里的推导过程和作者的推导过程略有出入，同时也参考了 &lt;a class="link" href="https://doi.org/10.1016/j.commatsci.2023.112047" target="_blank" rel="noopener"
&gt;Q. Huang et al 的这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="模型推导"&gt;模型推导
&lt;/h3&gt;&lt;p&gt;对多相问题而言，我们引入一个约束：每个点上的所有序参量之和为一常数 1。即：&lt;/p&gt;
$$
\sum_{\alpha = 1}^{N} \phi_\alpha = 1,
$$&lt;p&gt;由于对时间求导的线性性，又有：&lt;/p&gt;
$$
\sum_{\alpha = 1}^{N} \frac{\partial \phi_\alpha}{\partial t} = 0.
$$&lt;p&gt;设我们现在已经有一个自由能泛函 $F[\{\phi\},\{\nabla\phi\}]$，其形式为：&lt;/p&gt;
$$
F[\{\phi\},\{\nabla\phi\}] = \int_\Omega f\left(\{\phi\},\{\nabla\phi\}\right) \,\mathrm{d}\omega,
$$&lt;p&gt;即我们写出了其能量密度形式。我们现在希望能把上面引入的约束进一步引入这个能量泛函内，因此我们使用 Lagrange 乘数法，引入 Lagrange 乘数 $\lambda$ 到自由能密度中，则有：&lt;/p&gt;
$$
\begin{aligned}
l \left(\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right) &amp; = f\left(\left\{\phi \right\},\left\{\nabla\phi \right\}\right) - \lambda\left( \sum_{\alpha = 1}^{N} \phi_\alpha - 1 \right); \\
\mathcal{L}\left[\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right] &amp;= \int_\Omega l \,\mathrm{d}\omega.
\end{aligned}
$$&lt;p&gt;然后我们令 $\mathcal{L}$ 对 $\phi_\alpha$ 做变分，得到：&lt;/p&gt;
$$
\begin{aligned}
\frac{\delta \mathcal{L}}{\delta \phi_\alpha} &amp; = \frac{\partial l}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial l}{\partial \nabla \phi_\alpha} \\
&amp; = \frac{\partial f}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial f}{\partial \nabla \phi_\alpha} - \lambda \\
&amp; = \frac{\delta F}{\delta \phi_\alpha} - \lambda .
\end{aligned}
$$&lt;p&gt;此时我们应用所谓的 “Relaxation Ansatz”，即这个变分导数值为 $\phi_\alpha$ 的演化速率，即：&lt;/p&gt;
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta \mathcal{L}}{\delta \phi_\alpha}\\
&amp;= -\frac{\delta F}{\delta \phi_\alpha} + \lambda
\end{aligned}
$$&lt;p&gt;则根据上面的约束条件，我们能解出 $\lambda$ 为：&lt;/p&gt;
$$
\lambda = \frac{1}{N} \sum_{\alpha = 1}^{N} \frac{\delta F}{\delta \phi_\alpha}
$$&lt;p&gt;此时将 $\lambda$ 带入应用 “Relaxation Ansatz” 后的变分结果中，得到：&lt;/p&gt;
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta \neq \alpha} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= - \frac{1}{N} \sum_{\beta \neq \alpha} \left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F \\
\end{aligned}
$$&lt;p&gt;最后，我们考虑到由于我们只考虑有效序参量，即不为 0 的序参量，这里的 $N$ 可以修改为 $\tilde{N}$；括号内属于对两相间的界面场的驱动力描述，对于不同的两相驱动力，驱动力大小应该是不同的，所以我们给驱动力前面乘以和两相相关的界面移动参数，$\tilde{L}_{\alpha\beta}$。这样一来结果为：&lt;/p&gt;
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p&gt;即我们的多相场模型。&lt;/p&gt;
&lt;h3 id="模型解释"&gt;模型解释
&lt;/h3&gt;&lt;p&gt;上面的推导过程，在最后一步之前都是比较合理的。然而为什么最后能把 $\tilde{L}_{\alpha\beta}$ 硬生生塞进求和里面呢？也许只能通过物理的角度去尝试解释。这个公式在考虑 “Relaxation Ansatz” 时没有引入移动性的一些参数，比如经典 Allen-Cahn 方程里的移动性矩阵，也是为了方便公式推导，否则会陷入求和地狱，得到的 $\lambda$ 的值会变成：&lt;/p&gt;
$$
\lambda = \frac{\sum_\alpha\sum_\beta{}L_{\alpha\beta}\frac{\delta F}{\delta \phi_\beta}}{\sum_\alpha\sum_\beta{}L_{\alpha\beta}},
$$&lt;p&gt;带入公式后会得到：&lt;/p&gt;
$$
\frac{\partial \phi_\alpha}{\partial t} = \frac{\sum_\beta{L_{\alpha\beta}}}{\sum_\xi\sum_\zeta L_{\xi\zeta}}{\sum_\xi\sum_{\zeta\neq\beta} L_{\xi\zeta}\left( \frac{\delta }{\delta \phi_\beta} -\frac{\delta }{\delta \phi_\zeta} \right)F}
$$&lt;p&gt;虽然严谨，但是难以理解，而当考虑到这里的移动性参数可以直接集成在 $\tilde{L}_{\alpha\beta}$ 和 $\tilde{N}$ 后，整个式子都会变得更简洁，物理意义也更加明确。&lt;/p&gt;
&lt;p&gt;另外，在 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
&gt;I. Steinbach 和 F. Pezzolla 的文章&lt;/a&gt; 里，$\left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F$ 被解释为界面场 $\psi_{\alpha\beta}$，这也是为什么这个模型叫做界面场模型。而这篇文章中的推导过程里，如果考虑使用界面场进行推导的话，可以绕过求取 $\lambda$ 的显式表达，因为这个 $\lambda$ 对所有相都是相同的，而界面场这样差值的定义方式注定会消去 $\lambda$ 的影响。&lt;/p&gt;
&lt;p&gt;最后，我们指出，这个演化方程并没有对自由能 $F$ 做出任何的约束，因此该模型适用性非常广。事实上，多相场模型的应用极为广泛，经常可以在近年的相场模拟文章中见到。所以，尽管看起来这个模型的推导（在我看来，也许是我的问题）并不足够可靠，但是它很好用。是的，很好用。&lt;/p&gt;
&lt;h2 id="巨势方程"&gt;巨势方程
&lt;/h2&gt;&lt;h3 id="模型介绍-1"&gt;模型介绍
&lt;/h3&gt;&lt;p&gt;为了演化保守场变量，我们经常需要使用 Cahn-Hilliard 方程。然而，为了得到更好的结果，又或者当我们遇到了一些由演化方程引入的数值上的问题，我们也许需要对这个经典的方程做一些改变，就像上面的 Allen-Cahn 方程和多相场模型之间的关系一样。对于浓度这个最经典的变量而言，我们有总浓度场模型（考虑整个模拟域的浓度），相浓度场模型（考虑每个相内部的物质浓度），以及我们这里要介绍的巨势方程（演化模拟域内的化学势）。&lt;/p&gt;
&lt;p&gt;在介绍巨势方程具体的表达式之前，我们先来看一下所谓的“相浓度”和“总浓度”吧。我们知道，对于整个体系而言，其组分数量（元素）是固定的，而一个体系中可能有多个晶粒，而每个晶粒又可能分属不同的相。对不同的相而言，其成分很有可能是不同的。因此，一个组分的浓度在每个相内应该是不变的（不随位置变化），而在整个模拟域内会发生改变（随着相的不同而变化）。另外，浓度的改变是依赖于扩散势的，扩散势梯度会引导浓度进行变化，从高势处流向低势处。因此，相生长过程中浓度的变化可以认为是相浓度不同所导致的相之间扩散势不同所引发的。根据这一点，我们还可以通过演化模拟域内扩散势的变化来间接地模拟浓度的变化。这里我们要介绍的巨势方程，就是这么一个用来模拟扩散势变化的方程。&lt;/p&gt;
&lt;p&gt;巨势方程的表达式如下：&lt;/p&gt;
$$
\frac{\partial \mu_i}{\partial t} = \left[\phi_\alpha \frac{\partial c_j^\alpha}{\partial \mu_i} \right]^{-1} \left( \nabla\cdot \bar{M}_{jk} \nabla\mu_k + R_j - c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \right).
$$&lt;p&gt;我需要解释一下这个方程的记号。首先，和往常相似，$c$ 代表相浓度（即一个相内部的浓度），$\phi$ 代表相。此外，这个公式中的 $\mu$ 代表化学势（严格来讲是巨势，这也是这个方程名称的由来，但为方便理解我们就称为化学势），$M$ 代表浓度的移动性参数， $R$ 代表可能存在的浓度/物质源。再者，这个方程实际上使用了爱因斯坦求和约定，即如果一个乘积中一个指标出现了两次，那么就对这个指标求和。我们举个例子，比如方程右侧圆括号中的最后一项的记号代表的是：&lt;/p&gt;
$$
c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \coloneqq \sum_{\alpha}^{N}c_j^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p&gt;因此，上面的方程实际上是一个复杂求和。另外，记号中的 $i,j,k$ 都是用以标记元素（组分）的，我们设一共有 $K$ 个组分，所以独立组分一共有 $K-1$ 个（最后一个的量可以用 1 减去其余所有的组分的量），同时 $\alpha,\beta$ 等是用来标记相的，我们设一共有 $N$ 个相。根据我们的记号，上面的公式中如果有某个量没有重复指标（重复指标通常也称为哑指标，dummy index），则说明这个变量实则是代表了一个向量，这个向量根据指标的记号区别有 $N$ 或者 $K-1$ 个分量。而如果一个变量有两个指标，则说明这个变量实则是一个矩阵。我们后文记 $K-1$ 为 $\tilde{K}$ 以方便书写。&lt;/p&gt;
&lt;p&gt;最后我们要解释的是中括号和 $-1$ 的上标。这个记号是代表我们先以括号内的元素组成一个矩阵，然后对矩阵求逆。至此方程中的下标记号应该已经全部清晰明了了。&lt;/p&gt;
&lt;h3 id="方程推导"&gt;方程推导
&lt;/h3&gt;&lt;p&gt;下面我们来尝试对这个方程进行推导。我们直接从 Cahn-Hilliard 方程出发：&lt;/p&gt;
$$
\frac{\partial \tilde{c}_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \frac{\delta F}{\delta \tilde{c}_j} + R_i.
$$&lt;p&gt;这里我们再次对记号做一些解释。这里我们先不使用爱因斯坦求和约定，方便解释方程内部发生了什么，另外这里的 $\tilde{c}_i$ 代表的是体系内的总浓度。我们加上了波浪线是为了强调是整个体系内的总浓度，方便和后面的相浓度做出区分。&lt;/p&gt;
&lt;p&gt;由于我们这里使用了总浓度，它实际上可以使用相浓度和相分数来表示：$\tilde c_i = \sum_\alpha^N \phi_\alpha c^\alpha_i$。另外我们知道，$\frac{\delta F}{\delta \tilde{c}_j}$ 实际上是表示的体系内化学势（巨势）。所以我们直接用 $\mu_j$ 来替代。这样就有：&lt;/p&gt;
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p&gt;现在我们把目光聚焦在等式左侧，因为等式右侧，可以看到，其实已经是最终结果的一部分了。对于等式左侧，首先对有限求和而言，求导的线性性保证了我们可以把求导和求和交换次序。然后我们考虑使用对乘积偏导（求导）的规则，则有：&lt;/p&gt;
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \sum_\alpha^N\left(\phi_\alpha \frac{\partial c^\alpha_i}{\partial t} + c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} \right) = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p&gt;我们考虑把求和拆开，把含有相分数对时间求偏导的部分挪到等式右侧，则有：&lt;/p&gt;
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i - \sum_\alpha^N c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} .
$$&lt;p&gt;接下来是比较关键的一步，我们考虑把浓度和化学势联系起来。即考虑相浓度作为化学势的函数：$c_i^\alpha = c_i^\alpha\left( \mu_1, \mu_2, \cdots, \mu_{\tilde{K}} \right)$。这样我们就可以使用求（偏）导的链式法则，有：&lt;/p&gt;
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t},
$$&lt;p&gt;然后考虑到对成分求和实际上与相无关，我们把对成分求和的求和号挪到最外面，这样就得到了：&lt;/p&gt;
$$
\sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p&gt;我们先在这里暂停一下，回忆矩阵乘法的记号。设我们有两个矩阵，一个 $n\times m$ 矩阵 $A = \{a_{ij}\}$ 和一个 $m\times p$ 矩阵 $B = \{b_{jk}\}$，则它们的乘积矩阵 $C$ 应该是一个 $n \times p$ 矩阵，它的元素可以记为：$\sum_j^m a_{ij}b_{jk}$。另外，我们考察偏导 $\frac{\partial c^\alpha_i}{\partial \mu_k}$ ，这个偏导在当 $i$ 和 $k$ 都在 $\tilde{K}$ 个元素中取值时，实际上它组成了一个 $\tilde{K} \times \tilde{K}$ 矩阵中的元素。对应的，我们可以把 $\partial \mu_k$ 看作一个具有 $\tilde{K}$ 个分量的向量（或者 $\tilde{K} \times 1$ 的矩阵）。&lt;/p&gt;
&lt;p&gt;根据上面的内容，我们可以发现，实际上这里的求和可以写作两个矩阵的乘积（或者矩阵乘以一个向量）。至此我们采用爱因斯坦求和约定，则有：&lt;/p&gt;
$$
\sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} \coloneqq \phi_\alpha\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p&gt;我们把上面等式右边的三个因子做简单的区分，前两个因子的乘积实际上由于 $\alpha$ 指标重复的原因，代表了一个求和，而后又因为这个求和与第三个因子的 $k$ 指标重复，代表了矩阵的乘法。或者我们可以把 $\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}$ 理解为矩阵中的第 $\left( i,k \right)$ 个元素&lt;/p&gt;
&lt;p&gt;那么经过上面的说明，我们将等价变量依次带回，并对整个方程使用爱因斯坦求和约定重写，则有下面的结果：&lt;/p&gt;
$$
\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p&gt;现在我们可以将上式翻译为：一个 $\tilde{K} \times \tilde{K}$ 的矩阵 $\left\{\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k} \right\}$ 与一个 $\tilde{K} \times 1$ 矩阵 $\frac{\partial \mu_k}{\partial t}$ 相乘，得到的结果是三个 $\tilde{K} \times 1$ 矩阵相加。而我们希望的是能够得到演化体系扩散势变化的方程，这正好可以用 $\frac{\partial \mu_k}{\partial t}$ 来表示。所以我们的最后一步就是在等式两边同时左乘上这个 $\tilde{K} \times \tilde{K}$ 矩阵的逆矩阵，得到了：&lt;/p&gt;
$$
\frac{\partial \mu_k}{\partial t} = \left[\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\right]^{-1}\left(\nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}\right).
$$&lt;p&gt;也许你会发现这个式子和我们一开始给出的式子在下标上有差别。这个实际上是为了公式美观而改变了下标的排列顺序。只要保证公式内部的记号顺序一致，就可以保证公式，或者说矩阵乘法的逻辑顺序一致，因此我们这里得到的结果和上面给出的公式是没有本质区别的。&lt;/p&gt;
&lt;h3 id="模型解释-1"&gt;模型解释
&lt;/h3&gt;&lt;p&gt;我知道，这里其实留了很多的坑，比如说什么是巨势方程里的“巨势”？巨势和化学势有什么关系？为什么非要用化学势/巨势来演化整个体系，用总浓度不好吗？相浓度不行吗？我们来一个个解释这些问题。&lt;/p&gt;
&lt;p&gt;首先，巨势是什么呢？我们知道，热力学中有很多不同的热力学函数，比如焓 $H$，熵 $S$，内能 $U$，吉布斯自由能 $G$，亥姆霍兹自由能 $F$ 等等。巨势，又称朗道自由能也是一种热力学函数，其表达式为：&lt;/p&gt;
$$
\Omega \coloneqq F-\mu N = U-TS-\mu N,
$$&lt;p&gt;其中 $F$ 是亥姆霍兹自由能，$U$ 是内能，$T$ 是体系温度，$S$ 是熵，$\mu$ 是化学势，$N$ 是体系内的粒子数。巨势的微分形式为：&lt;/p&gt;
$$
\mathrm{d}\Omega = \mathrm{d}U-T\mathrm{d}S-S\mathrm{d}T-\mu\mathrm{d}N-N\mathrm{d}\mu = -P\mathrm{d}V-S\mathrm{d}T-N\mathrm{d}\mu.
$$&lt;p&gt;巨势在体系达到热力学平衡的时候会取到最小值。当体系内的其余变量 $V$，$T$ 不变时，巨势的变化实际上就反映了化学势的变化。另外我们还可以从这个公式中得到浓度的表达方式：考虑将巨势除以体系的体积得到能量密度，此时 $N$ 将从体系内粒子数量变为体系内的粒子浓度/数密度 $\rho$。假设我们还得到了物质的原子体积 $V_a$，那么浓度 $c$ 就可以表达为：&lt;/p&gt;
$$
c = V_a \rho = V_a \left(\frac{\partial \Omega}{\partial \mu}\right)_{V,T}.
$$&lt;p&gt;据此，我们可以考虑将浓度表达为化学势的函数。这也是前述的浓度能对化学势求导的一个佐证吧。&lt;/p&gt;
&lt;p&gt;那么，为什么要用巨势方程呢？它对比总浓度或者相浓度有什么优势呢？我们考虑一个多元多相体系，每个相内部都有多种组元，在相内部这些组元的浓度是固定的，而相与相之间的组元浓度一般是不同的。当发生相变时，相内物质浓度可能会发生变化。在这个情况下，我们如果想演化整个体系的浓度分布情况，就不可避免地必须演化每个相的浓度分布。&lt;/p&gt;
&lt;p&gt;我们首先会想到使用相浓度去演化整个体系，这样再将相浓度和相分数相结合就可以得到整个体系内的浓度分布。这个方法从理论上讲很不错，但从实际处理过程中会发生一些数值问题：在相界面处，特别是相分数较小的情况下，不可避免的要用一个数去除以一个非常小的（接近于0）的数字。由于 Cahn-Hilliard 方程是直接对总浓度进行演化的，因此必须先从总浓度中拆分出相浓度才可以直接演化相浓度。从总浓度反推相浓度时，不可避免要处理在界面上的浓度分配，这时必须要借助某种假设来正确地把浓度分配到每个相中。一般采用的假设是假设界面上的每个点上，每个相的化学势都相等。根据这点，总浓度和相浓度的关系可以表达为：&lt;/p&gt;
$$
c^i = \sum_\alpha\phi_\alpha c_\alpha^i
$$&lt;p&gt;这里，相浓度前的 $\phi_\alpha$，相分数，就会引发问题。假设现在需要演化某个很靠近某个相内部的位置（或者说 $\phi_\alpha \approx 1$ 的区域），此时将会有很多别的相的相分数约等于 0。为了演化各自的相浓度，就需要把这个相分数除过去，此时由于计算机精度问题，很容易造成结果不稳定。&lt;/p&gt;
&lt;p&gt;那如果直接考虑总浓度呢？总浓度实际上就是最传统的 Cahn-Hilliard 方程，而为了求得相的演化速率，还是需要通过某种方式去推出每个相中的浓度分配问题。这样会增加过多的计算量：反求相浓度的过程实际上是解线性方程组问题。也就是说，使用相浓度，会遇到数值问题，使用总浓度，又会增加很多的计算量，到头来不过是和相浓度方法的先后顺序调换一下，在反求相浓度的时候依旧可能遇到数值问题。&lt;/p&gt;
&lt;p&gt;然而，使用扩散势时，这个问题被巧妙地隐藏到了偏导数中。这样相当于用某种方法绕过了这样的数值问题，保持了合理的计算开销。简单来说就是，又快又好。&lt;/p&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;p&gt;其实很不好意思地说，这篇内容实际上只是对这两个公式做了一些简单的推导，而后面的解释部分我自认为写的并不好。好像所有的解释最后都要归结到一个结论上：好用。这个点实际上在考虑纯理论时是没有什么用处的：我需要精准的理论来描述物理现象，结果你却告诉我 XXX 然后 YYY 最后得到这些东西，它的理论背景可能不够强，但是它好用就够了。我相信这样的解释是很难真正地打动某个人的心的。&lt;/p&gt;
&lt;p&gt;然而，好用其实就已经够了，因为这些理论到头来本就是为了能够帮助我们在某个假设的基础上能够更好地做模拟。在这里，这个基础假设可以说是 relaxation ansatz 以及等势假设。首先第一个假设能够让我们的体系从一个非平衡态&lt;em&gt;演化&lt;/em&gt;到平衡态，而不是只能直接地给出一个平衡态下的数量场，而第二个假设则能够解决相场法中界面上物质分配的问题，让演化能够得以在多相的情况下正常进行下去。这些假设，不论从过程还是结果来看，都是很有必要的。而除了这些假设外，（在不考虑我自己推导过程不够严谨的情况下，）推导过程都是尽可能严谨的。得到的结果，也正如上面所说，好用。&lt;/p&gt;
&lt;p&gt;上面这一大段，我希望能传达到的意思就是，这些公式已经在较少的叫宽松的假设的基础上用尽可能严谨的逻辑推导出了可用，好用的结果，那么作为使用这些公式的人来讲，它好用就够了，坚持实用主义也许是更实际的做法。当然了，阅读本段的您也可以认为是我对自己的推导过程没有什么自信的开脱就是了，嘿嘿嘿~&lt;/p&gt;
&lt;p&gt;那么最后，祝您生活愉快~&lt;/p&gt;</description></item><item><title>关于泛函导数和变分法-来自相场公式推导的问题</title><link>https://a-moment096.github.io/posts/2025/01/functional_derivative/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/posts/2025/01/functional_derivative/</guid><description>&lt;img src="https://a-moment096.github.io/posts/2025/01/functional_derivative/HelloWorld-r-906.jpg" alt="Featured image of post 关于泛函导数和变分法-来自相场公式推导的问题" /&gt;&lt;p&gt;&lt;em&gt;本文系拾人牙慧之作，仅为解决公式推导过程中的一些边角料的数学问题，内容如有错漏还请谅解。另外，感谢老大中先生的《变分法基础》第三版。本文的主要内容几乎全部参考本书。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;头图出自 &lt;a class="link" href="https://x.com/amn_amn_/status/1580863274081349632" target="_blank" rel="noopener"
&gt;雨野&lt;/a&gt; 太太，为 &lt;a class="link" href="https://twitter.com/arukuremu" target="_blank" rel="noopener"
&gt;r-906&lt;/a&gt; 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1Ee4y1E7J6/" target="_blank" rel="noopener"
&gt;Hello World!&lt;/a&gt; 的曲绘&lt;/em&gt;&lt;/p&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"&gt;
&lt;style type="text/css"&gt;
[data-scheme="dark"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-withlist .aplayer-info {
border-bottom-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer.aplayer-fixed .aplayer-list {
border-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-body {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info {
border-top-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time {
color: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="dark"] .aplayer .aplayer-list {
background-color: var(--card-background);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb {
background-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover {
background-color: var(--accent-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li {
color: var(--card-text-color-main);
border-top-color: var(--card-separator-color);
}
[data-scheme="dark"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li.aplayer-list-light {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-index {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-list li .aplayer-list-author {
color: var(--card-text-color-secondary);
}
[data-scheme="dark"] .aplayer .aplayer-lrc {
text-shadow: -1px -1px 0 var(--body-background);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:before {
background: linear-gradient(to bottom, var(--card-background) 0%, rgba(0,0,0,0) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc:after {
background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, var(--card-background) 100%);
}
[data-scheme="dark"] .aplayer .aplayer-lrc p {
color: var(--card-text-color-main);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher {
background: var(--card-background-selected);
}
[data-scheme="dark"] .aplayer .aplayer-miniswitcher .aplayer-icon path {
fill: var(--card-text-color-tertiary);
}
[data-scheme="light"] .aplayer {
background: var(--card-background);
border: 1px solid var(--card-separator-color);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-title {
color: var(--card-text-color-main);
}
[data-scheme="light"] .aplayer .aplayer-info .aplayer-music .aplayer-author {
color: var(--card-text-color-secondary);
}
[data-scheme="light"] .aplayer .aplayer-list li:hover {
background: var(--card-background-selected);
}
&lt;/style&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"&gt;&lt;/script&gt;
&lt;script src="https://a-moment096.github.io/js/Meting.min.js"&gt;&lt;/script&gt;&lt;meting-js auto="https://music.163.com/#/song?id=2076684514" theme="#2980b9" loop="none"&gt;&lt;/meting-js&gt;
&lt;p&gt;2025.06.06 更新：感谢&lt;a class="link" href="https://github.com/which-is-my-way" target="_blank" rel="noopener"
&gt;@which-is-my-way&lt;/a&gt;指正，公式 &lt;a class="link" href="#modify" &gt;16&lt;/a&gt; 补上点乘单位法向量&lt;/p&gt;
&lt;h2 id="晶体相场公式带来的问题"&gt;晶体相场公式带来的问题
&lt;/h2&gt;&lt;p&gt;在一个阳光明媚的晚上，师兄找到我问了一个问题：下面的这个相场公式是怎么组装起来的？具体来讲是：从下面的公式（2）和公式（3）是怎么得到公式（4）的：
&lt;/p&gt;
$$
\begin{align}
F &amp;= \int_V f \mathrm{d}v\\ &amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \left( \omega\left( \nabla^2 \right) \psi + \psi^3 \right)+ \xi.
\end{align}
$$&lt;p&gt;
这里我们做一些简单的背景介绍吧。这个公式来源于&lt;a class="link" href="https://doi.org/10.1103/PhysRevE.70.051605" target="_blank" rel="noopener"
&gt;这篇文章&lt;/a&gt;，是提出晶体相场理论的文章，其重要性不言而喻，近乎所有的该领域的文章在使用这篇文章的结果时都需要引用这些个公式。我们这里不对晶体相场做太多介绍了（因为我也不了解，虽然也有相场两个字，但是几乎只有最最基础的假设相似而已了），简单介绍一下这些公式（名称）这些方便后面表述。其中公式（1）是指体系总能量可以表达为能量密度对体积的积分（这里先不给出能量和能量密度的参量），这里可以看到总能量实际上是一个泛函；（2）是指能量密度的具体构造，（3）是和传统相场形式相类似的一个演化方程，在传统相场里是 &lt;em&gt;Cahn-Hilliard&lt;/em&gt; 方程。而（4）就是将（3）中的变分展开得到的结果，或者说是具体计算过程中使用的公式的显式表达。&lt;/p&gt;
&lt;p&gt;另外我必须提到的一点是，这里列出的公式并不完整，比如 $\omega$ 是什么我并没有做说明，这是为了复述一下我的心路历程（即便是笔记，也不希望太死板，毕竟是从实际问题来的）。当然，后面会把完整的问题复述，以及推导过程完整地列出来的。&lt;/p&gt;
&lt;h2 id="传统相场公式对吗"&gt;传统相场公式，对吗？
&lt;/h2&gt;&lt;p&gt;拿到这个公式的时候其实并不是直接从文献拿到的，而是几张图片（大概就是公式（2）（3）和（4））。而我看到公式的第一反应是：这符号不是很对吧？把 $\psi$ 放到括号外面？这不太对吧？然后我便开始按照以往推导传统相场能量变分的方式推导了。我们来看看传统相场公式吧。
&lt;/p&gt;
$$
\begin{align}
F(c, \nabla c ) &amp;= \int_{\Omega} f(c, \nabla c )\, \mathrm{d}\omega = \int_{\Omega} f_b(c, \eta) + \kappa_c \left| \nabla c \right|^2 \mathrm{d}\omega;\\
\frac{\partial c_i}{\partial t} &amp;= \nabla \cdot M_{ij} \nabla \frac{\delta F}{\delta c_j \left( r,t \right)},
\end{align}
$$&lt;p&gt;
其中，公式（6）即为 Cahn-Hilliard 方程，而公式（5）则是传统相场中的总能构造的一种常见（最基础的）形式，其中 $f$ 是能量密度，$f_b$ 是体自由能密度。可以看到能量泛函是依赖于（?）浓度和浓度的梯度的。对这个公式的推导我们直接使用三维条件下的 Euler-Lagrange 方程：
&lt;/p&gt;
$$
\begin{align}
\frac{\delta F\left[ x,y,y' \right]}{\delta x} = \frac{\partial f}{\partial x} - \nabla \cdot \frac{\partial f}{\partial \nabla x}.
\end{align}
$$&lt;p&gt;
这样一来，这个公式就可以被展开了，只需要按照能量泛函的具体表达形式带入，然后求一下偏导，很快就会得到结果。&lt;/p&gt;
&lt;p&gt;说实话，这是在太棒了，只需要用很多现成（?）的内容，做一些非常简单（?）的推导，就（?）可以得到最后体系的演化方程具体表达形式。那心动不如行动，直接把这一套挪到上面的原始问题吧。很好，我们先对 $\psi$ 求偏导，得到（?）下面的东西：
&lt;/p&gt;
$$
\frac{\partial f}{\partial \psi} = \frac{1}{2}\omega\left( \nabla^2 \right)\psi + \psi^3,
$$&lt;p&gt;
然后，我们要对 $\nabla \psi$ 求偏导了。嗯，$\nabla \psi$ …… 但是这里是 $\nabla^2$ ？话说回来为什么要用 $\omega$ 带括号把 Laplacian 算子包起来呀？啊？&lt;/p&gt;
&lt;p&gt;这对吗？这不对吧？&lt;/p&gt;
&lt;h2 id="重新审视问题omega-是什么"&gt;重新审视问题，$\omega$ 是什么？
&lt;/h2&gt;&lt;p&gt;问题看来根本不是我想得那么简单。还是需要从零开始一步步建立起这个问题的合理描述，并找到真正的解决方法。首先要解决的，就是 $\omega(\nabla^2)$ 这个奇怪的写法。假如这个写法是对的，那 $\omega$ 就不是什么参数之类的东西了，就应该是算符的一个函数或者别的什么东西了。&lt;/p&gt;
&lt;p&gt;找到原始文献，查看定义，我们得到了 $\omega$ 的真面目：
&lt;/p&gt;
$$
\begin{align}
\omega (\nabla^2) = r + \left(1 + \nabla ^2\right)^2,
\end{align}
$$&lt;p&gt;
其中的 $r$ 是一个复杂的常数，不用关心。果不其然。$\omega$ 应该解释为一个对 $\nabla^2$ 算子做一种变换得到的新的算子。或者说，它是把算子映射到算子的一个映射。太棒了，我们把这个结果带入公式（1）中的 $f$ 吧：
&lt;/p&gt;
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\\
&amp;= \frac{\psi}{2} \left(r + \left(1 + \nabla ^2\right)^2 \right)\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p&gt;
等一下，算子中的平方应该怎么解释？常数作用于一个变量应该怎么解释？根据算符的运算规则，我们得知：算符的平方，应该解释为算符作用于被作用量两次，而常数作用应解释为标量乘法。那么我们得到：
&lt;/p&gt;
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \left(r\psi + \left(1 + \nabla ^2\right)^2\psi \right) + \frac{\psi^4}{4}\\
&amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \nabla^2\psi + \frac{1}{2}\psi\nabla^2\nabla^2\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p&gt;
啊，看起来头好晕，怎么 Laplacian 也有个平方？我们更换符号：$\Delta = \nabla^2$，就有了：
&lt;/p&gt;
$$
\begin{align}
f &amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{align}
$$&lt;p&gt;
好了，这下我们搞清楚了 $\omega$ 到底是什么以及它对公式有何影响，现在我们对 $\psi$ 求的偏导应该就没问题了吧？&lt;/p&gt;
&lt;p&gt;等等，什么是 $\Delta\Delta\psi$ ？对 $\psi$ 求偏导的话要管它吗？就算不管这个东西，这个公式里没有熟悉的 $\nabla\psi$ 呀，那我们的能量密度对 $\nabla\psi$ 求偏导等于 0 ？这不太对吧？话说回来我们的总能量泛函到底依赖于什么变量？再等一下，依赖？对于一个泛函而言，我们只需要找到最符合要求的一个函数就好了呀？这个函数自然就可以通过对坐标求导得到自己的偏导数了，那偏导数就不应该是一个独立变量才对吧，我们对它做偏导数到底是为什么？&lt;/p&gt;
&lt;p&gt;完了，本来以为什么都知道，现在什么都不知道了。变分法，Euler-Lagrange 方程，这些都不应该是现成的吗？Laplacian，奇怪的 $\Delta\Delta\psi$，这些都不是能直接套到已有公式里的吧？&lt;/p&gt;
&lt;h2 id="死胡同从头开始吧"&gt;死胡同？从头开始吧！
&lt;/h2&gt;&lt;p&gt;其实 $\Delta\Delta\psi$ 或多或少能想到是怎么个形式，无非就是把 $\Delta$ 作用两次就行了，关键在于这个变量，以及 $\Delta \psi$ 怎么参与到这个泛函构造中的，并且它们应该怎么参与到泛函导数里面。而为了搞清楚这个问题，我们也许必须明白这个泛函的“自变量”都有哪些，或者说，依赖于哪些变量，并且要搞清楚变量函数本身和它对位置的求导之间到底是有着什么样的关系。&lt;/p&gt;
&lt;p&gt;问题很多，我们干脆从头开始，一步步拆解吧，就从&lt;em&gt;泛函是什么&lt;/em&gt;这个问题开始。&lt;/p&gt;
&lt;h3 id="泛函"&gt;泛函
&lt;/h3&gt;&lt;p&gt;我们讨论的泛函其实是一类特殊的映射，这个映射拥有定义域和陪域，其定义域为在某个空间上定义的全体函数组成的空间（比如，$\mathbb{R} \supseteq \Omega\to\mathbb{R}$ 的函数组成的空间，或者 $\mathbb{R}^3 \supseteq \Omega\to\mathbb{R}$ 的函数空间，根据我们的问题是几维的来确定这些函数的定义域），而泛函的陪域则是一个数域，对于能量而言我们就选择 $\mathbb{R}$ 好了。所以这个映射，从形式上来写，应该就是：&lt;/p&gt;
$$
F:\left\{ y \;\Big|\; y: \Omega \to \mathbb{R} \right\} \to \mathbb{R}.
$$&lt;p&gt;另外我们的泛函的另一个特殊之处在于，它常常可以写成这样一个积分的形式：&lt;/p&gt;
$$
F = \int_\Omega f\, \mathrm{d}\omega.
$$&lt;p&gt;我们常遇到的变分问题，也就是说在求什么样的函数 $\phi \in \left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 能够使得将之带入泛函 $F$ 时能让这个泛函取到最小值&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;。甚至我们遇到的问题更加得特殊，因为我们要求函数族 $\left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 满足这样的条件：在区域边界 $\partial \Omega$ 上这些函数族内的函数都必须相等，或者换句话说，就是我们的问题是固定边界问题。&lt;/p&gt;
&lt;p&gt;太棒了，但是上面这些叙述，对我们的问题有什么帮助呢？我们把目光聚焦到泛函积分形式中的这个 $f$ 上。它没这里有具体的表达式，只是说明了要对它做积分。它具有什么样的意义呢？&lt;/p&gt;
&lt;h3 id="被积函数泛函的核"&gt;被积函数（泛函的核）
&lt;/h3&gt;&lt;p&gt;我们这里指出：这个被积分的东西 $f$ 实际上是对泛函的要求。在部分文献中 $f$ 也称为泛函的核。$f$ 的具体表达形式，将会对最后得到的 $y$ 做出约束，使之满足泛函 $F$ 取到最小值的结果。那么，一个对 $y$ 的约束，要怎么表达它呢？或者说我们应该对 $y$ 做一些什么，来使之成为 $y$ 的约束呢？&lt;/p&gt;
&lt;p&gt;为了用 $f$ 来约束 $y$，我们考虑使用 $f$ 来描述 $y$ 的行为。$y$ 在什么情况下，会得到什么样子的结果，大概就是这样的方式去描述。而我们常常在描述 $y$ 的行为时，会考虑到它的导数的行为，将导数 $y'$ 和 $y$ 二者相互作用时得到的结果结合起来。最后考虑到我们描述 $y$ 时很难避免加入函数自变量 $x \in \Omega$，最后我们得到的 $f$ 就会变成这样的东西：它看起来像是一个关于 $x\in \Omega$，$y : \Omega \to \mathbb{R}$ 以及 $y' : \Omega \to \mathbb{R}^n$ 三个变量的函数（其中 $n$ 的取值取决于考虑的函数的定义域维数）。当存在更多高阶导数参与描述 $y$ 的行为时，这个函数 $f$ 所依赖的变量就更多了。在这个函数中，我们不考虑 $y$ 是和 $y'$ 或者更高阶的导数相关的，因为它们都独立地描述函数 $y$ 的行为。可以这样理解：$y'$ 对函数 $y$ 的约束作用是没法直接用 $y$ 自己或者 $x$ 自己单独去描述的，所以它的影响就应该是独立于 $y$ 和 $x$ 的。 这样一来，令 $f$ 对 $y$，$y'$ 等求偏导也是可以理解的了。另外，我们只关注对 $y$ 起实际约束作用的量，假如 $f$ 中不含有 $y'$，我们认为 $f$ 是不显含 $y'$ 的，此时并不是说 $y'$ 不存在了，而是它不参与到对 $y$ 的行为约束中。&lt;/p&gt;
&lt;p&gt;当我们想要求取得到的函数的定义域从一维上升到我们更常遇到的三维时，函数 $y$ 所依赖的变量也就更加复杂了，可能包括 $\nabla y$，$\nabla \cdot y$，$\nabla \cdot \nabla y$ 等等。和上面类似，我们依旧将这些处理为独立存在于 $f$ 中的变量。有了上面这些的铺垫，我们至少能让我们的问题变得更加清楚一些：问题中的能量形式，将其变量依赖状态完整地写出，应该是以下的形式（这里我们按照惯例将&lt;em&gt;双调和算子&lt;/em&gt; $\Delta\Delta$ 写成 $\Delta^2$ 的形式，它也可以写作 $\nabla^4$）：&lt;/p&gt;
$$
\begin{align}
F\left[\psi\right] &amp;= \int_V f \left(\psi,\Delta\psi,\Delta\Delta\psi\right) \mathrm{d}v\\ &amp;= \int_V r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4} \mathrm{d}v.
\end{align}
$$&lt;h3 id="再考察-euler-lagrange-方程"&gt;再考察 Euler-Lagrange 方程
&lt;/h3&gt;&lt;p&gt;然而上面的一切似乎只是澄清了一些基本事实，并没有对解决这个问题起到非常实质的帮助呀。别灰心，至少我们知道了：上面的 Euler-Lagrange 方程，应该是只适用于 $f(x,y,\nabla y)$的，而对于新的 $f$，我们需要自己想办法得到这样的方程。因此，我们必须深入到变分法的根本，去了解变分法到底是怎么推导出了上面我们用到的 Euler-Lagrange 方程的。为此，我们采用我们一开始认为非常轻易地获得的 Euler-Lagrange 方程所对应的泛函形式来作为例子，自己推导一下它对应的 Euler-Lagrange 方程。&lt;/p&gt;
&lt;p&gt;回忆我们面对的变分法的一般问题：在什么样子的函数 $y$ 下，我们构造出的泛函能够取最小值。我们的函数 $y$ 的定义域是固定的，所以我们要关心的是这个符合要求的函数在每一个点处的值应该是什么样的。不妨假设我们已经有了一个最佳的函数满足要求了，称这个函数为 $\varphi$。此时，由于这个函数已经是最好的，最满足需求的函数了，任何对这个函数某个值的改变，都会让我们的泛函不能取最小值。&lt;/p&gt;
&lt;p&gt;我们来试着把这个结论写成更形式化一些的表达：假设函数 $\varphi : \Omega \to \mathbb{R}$ 是满足泛函 $F$ 的最小值需要的函数，则此时任意函数 $y \neq \varphi$ 都会造成这样的结果：$F[y] - F[\varphi] = \delta F &gt; 0$ ，这里的 $\delta F$ 就是泛函 $F$ 的&lt;em&gt;变分&lt;/em&gt;。这里大于 0 是因为我们已经知道了 $F[\varphi]$ 是最小值。反过来讲，当 $\delta F = 0$ 的时候，就能说明此时的函数 $y$ 就是我们需要的函数 $\varphi$。&lt;/p&gt;
&lt;p&gt;这个表达是否让你感到一丝熟悉？我们先继续向下推进。&lt;/p&gt;
&lt;p&gt;可以看到，假如我们把这个不等式用我们之前熟悉的泛函的积分形式展开，并根据积分的线性性合并，得到的结果是：&lt;/p&gt;
$$
\delta F = \int_\Omega f(x,y, \nabla y) - f(x,\varphi,\nabla\varphi) \mathrm{d} \,\omega = \int_\Omega \delta f\, \mathrm{d}\omega.
$$&lt;p&gt;上面的第二个等号是我们把被积函数的差记为了这样对函数的全变分。这个积分不等式的被积分项里，变量 $x$ 没有什么变化，那我们干脆将 $f$ 在现在看作一个二元函数。我们把 $\varphi$ 改写为以 $y$ 为基础加上一个扰动的形式：$\varphi = y+\delta y$，那么我们可以模仿全微分那样，把这里对函数的全变分 $\delta f$ 做全微分式的处理，就可以根据它的两个变量的偏导来写出其全变分的表达式。带入上式，则有：&lt;/p&gt;
$$
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega = \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\delta\nabla y \right) \, \mathrm{d}\omega.
$$&lt;p&gt;这个形式已经是我们很熟悉的形式了，但是还有一些区别。这里我们指出，函数对向量求偏导得到的也是一个向量，所以这里需要用向量内积，其中的技术细节我们不多赘述，我们更关注的是：怎么把 $\delta \nabla y$ 写成别的形式，来进一步向我们的结果前进。注意到 $\nabla$ 是对坐标求导，而 $\delta$ 则是在保持定义域不发生改变的情况下，改变了函数的值。因此二者应该是相互独立的，也意味着两个算符是可以相交换的。再使用点乘的乘积律：$\nabla \cdot (f{\bf{}v}) = f\nabla\cdot{\bf v}+{\bf v}\cdot\nabla f$，这样一通操作，就得到：&lt;/p&gt;
$$
\begin{align}
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega &amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\nabla\delta y \right) \, \mathrm{d}\omega \\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y - \nabla \cdot \frac{\partial f}{\partial \nabla y}\delta y \right) \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega .
\end{align}
$$&lt;p&gt;而在式（13）中，最后的积分可以根据多元积分的 Green 公式，化成对区域 $\Omega$ 的边界 $\partial \Omega$ 积分。而此时，由于在边界上所有的函数的值都要相等，此时 $\delta y = 0$，这样最后一项积分就化为0了。我们写为下面的结果：&lt;/p&gt;
&lt;span id="modify"&gt;
$$
\begin{align}
\delta F &amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_{\partial\Omega} \left(\frac{\partial f}{\partial \nabla y}\delta y\right)\cdot\hat{n} \, \mathrm{d}A\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega.
\end{align}
$$&lt;/span&gt;
这样，我们就距离我们希望得到的形式，Euler-Lagrange 公式只差一步了。注意到这里使用的 $\delta y$ 是任意的，假如 $\delta F = 0$，从积分里的内容来看，只能是括号内的部分等于 0。
&lt;p&gt;我们可以看到，上面的过程，可以分为大致四个部分：得到全变分形式，将非目标变分以变分和微分的交换律改写为目标函数变分，消去多余项，由变分任意性得到被积函数内部等于 0。我们因此，可以根据我们已经熟悉的函数导数的概念，将公式（18）中的被积函数括号内这个关键部分定义为泛函的导数，即：
&lt;/p&gt;
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y},
$$&lt;p&gt;
当其为 0 时，
&lt;/p&gt;
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} = 0,
$$&lt;p&gt;
泛函即取到极值（在我们的情境下即为最小值）。这就是所谓的 Euler-Lagrange 方程。&lt;/p&gt;
&lt;h3 id="最后一步"&gt;最后一步
&lt;/h3&gt;&lt;p&gt;现在，我们对泛函的概念做了一些解释，并从头建立起了我们之前使用的 Euler-Lagrange 公式。这里我希望做一些补充说明。可以看到这里的泛函导数并不是直接的“某些东西的商然后做极限”，而是将某个对我们有用的部分定义为了泛函导数。对这个概念最佳的解释，就是它等于 0 时代表泛函的极值，通过解这个方程就能得到令泛函取得极值的极限函数。它不应被解释为变化率或者什么别的内容。&lt;/p&gt;
&lt;p&gt;另外，我们上面用到了“二元函数全微分”这样的类比。平心而论，我自己并不是特别能接受这种说法。另一个可行的解释是，将函数 $y$ 化为 $y = \varphi + \varepsilon\eta$，也就是说我们使用了一个任意函数 $\eta : \Omega \to \mathbb{R}$，让它乘上一个极小的量 $\varepsilon$，这样就相当于用 $\varepsilon\eta$ 形成了一个函数的扰动，即 $\delta y$。我们要求 $\eta$ 是一个任意的函数，而在任何计算过程中都保持 $\eta$ 不变。此时整个式子将会成为只关于 $\varepsilon$ 的一元函数了。对于一个一元函数，其极值点就会出现在导数等于 0 的位置。那么此时对 $\varepsilon$ 求偏导，也能得到和上面类似的结论，并且通过格林公式化简得到最后的结论。当然，这也只是另一种思路，仅供参考。&lt;/p&gt;
&lt;p&gt;最后要提出的是，上面的推导过程是和 $f$ 的表达式强相关的，尤其是其依赖的变量。然而当我们再考察其和变量之间的关系时，可以发现每个变量实际上对应到最后的 Euler-Lagrange 公式中都是相对独立的。比如，$x$ 这个部分没有在公式中出现，$y$ 的部分对应对 $y$ 求偏导，而 $\nabla y$ 的部分则对应着对 $\nabla y$ 求偏导后再对结果做散度。这个结果是可以预想到的：由于全微分公式，或者换成泛函的语境，全变分公式，的性质，是会出现这样的结果。那么我们也自然可以预想到，假如 $f$ 依赖的变量是别的变量，也应该有类似的结论才对。&lt;/p&gt;
&lt;p&gt;到这里，我们近乎完全搞通了我们最后想要解决问题的路径。我们已经得到了泛函具体的表达式，搞清楚了泛函的核（即那个被积函数 $f$）的参数表，得到了对泛函做变分法的具体思路。我们的下一步，或者最后一步，便是真的带进去算了。&lt;/p&gt;
&lt;h2 id="计算"&gt;计算！
&lt;/h2&gt;&lt;p&gt;为了读者的精神健康，我们隐藏当 $f$ 依赖情况为 $f(p,\psi,\Delta \psi,\Delta\Delta \psi)$ （其中 $p \in V$ 代表位置）时的 Euler-Lagrange 公式的推导，直接给出结果：&lt;/p&gt;
$$
\begin{equation}
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right)
\end{equation}
$$&lt;details&gt;
&lt;summary&gt;如果你愿意看推导过程的话：&lt;/summary&gt;
&lt;p&gt;不，你其实不想看，你只是好奇我到底有没有真的写这些推导过程。事实是：写了，下面就是。&lt;/p&gt;
&lt;p&gt;但是如果你真的想看这个部分，谢谢你，我的努力没有白费。&lt;/p&gt;
&lt;p&gt;我们先根据全变分，写出泛函的核函数变分后的结果：&lt;/p&gt;
$$
\begin{align*}
\delta F &amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \int_V \delta f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; =\int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v. \\
\end{align*}
$$&lt;p&gt;接下来我们分别考察被积分的每一项。其中第一项的对 $\psi$ 的变分 $\delta\psi$ 已经符合我们的要求了，第二项中的 $\delta \Delta \psi$ 和第三项中的 $\delta \Delta\Delta\psi$ 则需要我们处理为某个函数乘以 $\delta\psi$ 的形式，以便于最后的逻辑处理。&lt;/p&gt;
&lt;p&gt;根据变分与求导和交换的关系，我们有：&lt;/p&gt;
$$
\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi = \left(\frac{\partial f}{\partial \Delta\psi}\right)\Delta \delta \psi = f_1 \Delta\delta\psi;\\
\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi = \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right) \Delta\Delta\delta\psi = f_2\Delta\Delta\delta\psi,
$$&lt;p&gt;其中每行公式的第二个等号都是为了护眼做的处理，即将括号中的偏微分用记号表示。我们先看上面第一个式子，这是两个标量函数的乘积，其第二个因式展开应为:&lt;/p&gt;
$$
\Delta \delta \psi = \nabla \cdot \nabla \delta\psi,
$$&lt;p&gt;注意到散度存在恒等式：$\nabla \cdot (f\mathbf{v}) = f\nabla\cdot\mathbf{v} + \nabla f \cdot \mathbf{v}$，其中 $f$ 为标量函数或标量场， $v$ 为向量值函数或向量场，我们可以对上面的结果变换得到：&lt;/p&gt;
$$
\begin{align*}
f_1\nabla \cdot \nabla \delta\psi &amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla f_1\cdot \nabla\delta\psi \\
&amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla\cdot(\delta\psi\nabla f_1) + \delta \psi \nabla\cdot\nabla f_1.
\end{align*}
$$&lt;p&gt;上式对一个三维区域 $\Omega$ 的积分，根据散度定理，有：&lt;/p&gt;
$$
\begin{align*}
\int_V f_1 \nabla\cdot\nabla\delta\psi \,\mathrm{d}v &amp;= \int_V \nabla\cdot(f_1\nabla\delta\psi)\,\mathrm{d}v -\int_V \nabla\cdot(\delta\psi\nabla f_1) \,\mathrm{d}v+\int_V \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v \\
&amp;=\int_{\partial V} f_1\nabla\delta\psi\cdot\hat{n}\,\mathrm{d}s - \int_{\partial V} \delta\psi\nabla f_1\cdot\hat{n} \,\mathrm{d}s + \int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v\\
&amp;=\int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v.
\end{align*}
$$&lt;p&gt;上式第二个等号使用了散度定理，第三个等号则是考虑到在边界处 $\delta\psi = 0$，$\nabla\delta\psi = \mathbf{0}$。这样我们就得到了原变分中被积函数第二项的表达形式。我们现在考虑其中的第三项，即 $f_2\Delta\Delta\delta\psi$。我们先将其中的 $\Delta\delta\psi$ 看作函数标量函数 $\varphi$，则原式写为 $f_2\Delta\varphi$。此时，套用我们上面已经得到的结果，有：&lt;/p&gt;
$$
\begin{align*}
\int_V f_2 \Delta\Delta\delta\psi \,\mathrm{d}v &amp;= \int_V f_2 \Delta\varphi \,\mathrm{d}v\\
&amp;= \int_{\partial V} f_2\nabla\varphi\cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \varphi\nabla f_2\cdot\hat{n} \,\mathrm{d}s+\int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v \\
&amp;= \int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v = \int_V \varphi \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \Delta\delta\psi \Delta f_2 \,\mathrm{d}v = \int_V \nabla\cdot\nabla\delta\psi\, \Delta f_2 \,\mathrm{d}v\\
&amp;= \int_{\partial V} \Delta f_2\nabla\delta\psi \cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \delta\psi\,\nabla (\Delta f_2)\cdot\hat{n} \,\mathrm{d}s+\int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v,
\end{align*}
$$&lt;p&gt;其中所有的操作与前面是一样的，不断用恒等式拆开，然后由于在边界上的包含 $\delta\psi$ 的项全部归零，所有对 $V$ 的边界 $\partial V$ 的积分都会变成 0，最后就得到了我们想要的结果。我们把这些积分再合起来，将为了方便所做的记号带回，就有：&lt;/p&gt;
$$
\begin{align*}
\delta F &amp; = \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v \\
&amp;= \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \psi
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \psi \,\mathrm{d}v \\
&amp;= \int_V \left(\left(\frac{\partial f}{\partial \psi}\right)
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\right)\delta \psi \,\mathrm{d}v.
\end{align*}
$$&lt;p&gt;那么，由泛函导数的定义，我们就得到了 Euler-Lagrange 方程：
&lt;/p&gt;
$$
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right).
$$&lt;/details&gt;
&lt;p&gt;现在,我们来把式子带进去吧。为了方便，我们先把公式待带入的公式写在下面：&lt;/p&gt;
$$
\begin{align}
F[\psi] &amp;= \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \mathrm{d}v\\
&amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\omega (\nabla^2) &amp;= r + \left(1 + \nabla ^2\right)^2;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi.\\
\end{align}
$$&lt;p&gt;我们的目的也就是将公式（21）先带入公式（20）得到能量的具体表达形式，然后将得到的结果带入公式（18）来计算能量变分，最后得到公式（22）的显式表达。其中第一步已经完成了，能量密度的具体表达形式为：&lt;/p&gt;
$$
\begin{equation}
f = r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{equation}
$$&lt;p&gt;我们先对公式（23）计算需要的这些偏导数，得到：&lt;/p&gt;
$$
\begin{align}
\frac{\partial f}{\partial \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3;\\
\frac{\partial f}{\partial \Delta \psi} &amp;= \psi;\\
\frac{\partial f}{\partial \Delta\Delta \psi} &amp;=\frac{1}{2}\psi.
\end{align}
$$&lt;p&gt;现在把这些得到的结果，即公式（24-26）带入到我们得到的 Euler-Lagrange 方程（18）中。注意在前面加上对应的 Laplace 算子或者双调和算子。得到的结果为：&lt;/p&gt;
$$
\begin{align}
\frac{\delta F}{\delta \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3 + \Delta\psi+\frac{1}{2}\Delta\Delta\psi \\
&amp;=r\psi + \psi + 2\Delta\psi + \Delta\Delta\psi+\psi^3\\
&amp;=\left(r + \left(1 + 2\Delta + \Delta\Delta\right)\right)\psi+\psi^3\\
&amp;=\omega(\Delta)\psi + \psi^3.\\
\end{align}
$$&lt;p&gt;那么最后，把式（30）带回到式（22）中。此时我们尊重原文，把符号统一，将 $\Delta$ 重写回 $\nabla^2$，就有：&lt;/p&gt;
$$
\begin{equation}
\frac{\partial \psi}{\partial t} = \nabla^2 \left(\omega(\nabla^2)\psi + \psi^3\right) + \xi.
\end{equation}
$$&lt;p&gt;这就是我们一开始的目标，式（4）。&lt;/p&gt;
&lt;h2 id="后记"&gt;后记
&lt;/h2&gt;&lt;p&gt;其实这个问题一开始就很清楚：只要找到正确的 Euler-Lagrange 公式，带入无脑计算就行了。但是如何找到正确的 Euler-Lagrange 公式则是一个比较棘手的问题。本文的思路启发自老大中先生的《变分法基础》，翻开书，几乎所有的笔墨全都放在了如何去根据泛函的形式来推导出对应的 Euler-Lagrange 方程上。所幸，我们的这个方程形式非常简单，且答案几乎是现成的，只需要找到正确的位置后取用即可。&lt;/p&gt;
&lt;p&gt;那么这篇文章前面的部分有什么用呢？像跳梁小丑一样跳来跳去，最后发现从一开始就不对劲，转而从头开始推导整个公式。如果一开始就找到这个合适的公式，不就好了吗？也许能够找到这个合适的公式确实能立马解决眼前的问题，但是以后呢？如果遇到了一个形式又不太一样的泛函，此时应该怎么推导出其对应的 Euler-Lagrange 方程呢？而且从文章前半部分可以看到：我对变分法的理解，在推导出这个公式以前，是有问题的。我机械地认为就是带入那个人尽皆知的 Euler-Lagrange 方程，然后算算算就好了。旋即就遇到了第一个问题：怎么让 Laplacian 对梯度求导。是的，我当时并不怀疑是公式问题，而是考虑怎么让这个公式能算下去。在网上搜索一段时间之后，我貌似得到了结果，但总归不太满意，因为带入后得不到最后的公式。&lt;/p&gt;
&lt;p&gt;一段迷茫过后，我突然对变量之间的依赖情况产生了疑惑。网上搜寻的结果表明，不能单纯地看作相互关联的变量，或者说单纯的求导关系。最后我得到了上文中的解释，也许我在这部分的解释是错误的，但我用这个方法说服了自己。希望这个观点没有问题。顺带，我得到这个解释或多或少受到了热力学的启发：热力学中的偏导数必须标明哪些变量是固定不变的，这时因为热力学参数张成了一个高维空间，而体系的热力学状态则是这个空间上的一个超平面，热力学状态函数则是这个超平面上定义的场。因此，对热力学状态函数求偏导的时候必须固定求导方向，也就是固定某些变量不变。也许是这样的理解让我将泛函的核理解为了对函数的约束（我也不知道怎么联系上去的，所以说只可谓之&lt;em&gt;启发&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;然而即便如此，我依旧没法得到最后最关键的公式。此时只能从头开始一步步推导 Euler-Lagrange 公式了。所幸，我找到了老大中先生的这本书，读过一部分之后，遍跳着找到了我需要的答案。感谢这本书，让我少走了不知道多少弯路。&lt;/p&gt;
&lt;p&gt;最后，感谢您能阅读到这里，看这么久的流水账也挺辛苦的。希望这篇流水账一样的文章也能帮助正在阅读的你增进对 Euler-Lagrange 公式和变分法或者泛函导数的理解。&lt;/p&gt;
&lt;p&gt;那么，祝您生活愉快~&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;请容许我这里混淆最小值和极小值，以及最值和极值，因为我们默认需要这个泛函取到的是极小的部分，且这个极小值一定是全局的，即最小值。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item></channel></rss>