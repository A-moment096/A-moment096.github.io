<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Note on A Moment's Rest</title><link>https://a-moment096.github.io/tags/note/</link><description>Recent content in Note on A Moment's Rest</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 29 Jul 2025 09:04:35 +0000</lastBuildDate><atom:link href="https://a-moment096.github.io/tags/note/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 rsync 进行同步</title><link>https://a-moment096.github.io/p/%E4%BD%BF%E7%94%A8-rsync-%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 28 Jul 2025 12:43:39 +0800</pubDate><guid>https://a-moment096.github.io/p/%E4%BD%BF%E7%94%A8-rsync-%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E4%BD%BF%E7%94%A8-rsync-%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5/Pianist.jpg" alt="Featured image of post 使用 rsync 进行同步" />&lt;p>&lt;em>有点受不太了 &lt;code>scp&lt;/code> 和 &lt;code>sftp&lt;/code> 了，也许是食用姿势不对吧，总之我选择 &lt;code>rsync&lt;/code>！&lt;/em>&lt;/p>
&lt;p>&lt;em>图源找不到诶……从朋友那里薅过来的图，很漂亮就放在这里了。既然如此就分享一首钢琴曲吧。一首 &lt;strong>騎士王の誇り&lt;/strong> (骑士王的荣耀) 送给大家。&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=448119" theme="#2980b9" loop="never">&lt;/meting-js>
&lt;h2 id="为什么要选择-rsync-呢">为什么要选择 &lt;code>rsync&lt;/code> 呢？
&lt;/h2>&lt;p>有时候我们有多个远程电脑，或者是服务器，上面的文件内容我们希望下载到本地。我们通常有这么几个选择：使用一些功能成熟的，专用于 SSH 连接的终端模拟器，比如 MobaXTerm 这样的软件；或者我们可以使用 &lt;code>scp&lt;/code>，&lt;code>sftp&lt;/code> 这样的工具，但是界面有点简陋，特别是 &lt;code>sftp&lt;/code>，需要反复确认文件名是否输入错误。而且有时我们只需要下载不同的部分，不希望重复下载已经有了的部分。这时候，&lt;code>rsync&lt;/code> 作为 &lt;em>remote sync&lt;/em> 的工具，就到了发挥其作用的地方了。&lt;/p>
&lt;h2 id="使用方法">使用方法
&lt;/h2>&lt;h3 id="命令结构">命令结构
&lt;/h3>&lt;p>&lt;code>rsync&lt;/code> 命令使用方法是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="go">rsync --option1 --option2 /pass/files/from/this/ /path/files/to/here
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以大概就是遵循：&lt;code>命令，选项，从哪里来，到哪里去&lt;/code> 这样的规则。另外，既然 &lt;code>rsync&lt;/code> 是 &lt;em>remote sync&lt;/em> 的简称，自然这个命令也是可以被用于远程服务器之间的文件传输的。方法也很简单，就是给对应的文件路径添加上使用 &lt;code>ssh&lt;/code> 的用户名、服务器地址等信息。具体用法我们下面介绍。&lt;/p>
&lt;h3 id="注意路径分隔符-">注意路径分隔符 &lt;code>/&lt;/code>
&lt;/h3>&lt;p>首先，这里需要强调的是，请注意 &lt;code>从哪里来&lt;/code>，也就是发送端的这一部分，这里明显是一个文件夹，因为路径的最后有一个 &lt;code>/&lt;/code> 符号。也许有人会问：我知道它是文件夹，我能不要那个 &lt;code>/&lt;/code> 吗？比如使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="go">rsync --opt1 --opt2 /pass/files/from/this /path/files/to/here
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样的命令，来把文件夹传过去，可以吗？&lt;/p>
&lt;p>答案很有趣：是的，你可以传过去，但是也许不会以你预期的方式传过去。由于 &lt;code>rsync&lt;/code> 会默认传过去的位置是个文件夹，如果你不带上这个斜杠的话，&lt;code>rsync&lt;/code> 会认为你打算把 &lt;code>/pass/files/from/this&lt;/code> 这个文件夹 &lt;strong>放在目标位置的里面&lt;/strong>。如果你的确打算这么做，那没什么问题。比如你在本地有一个文件夹 &lt;code>$HOME/mydocuments&lt;/code>，你在远程的服务器的接收端上也有这么个文件夹，位置一模一样，那么就可以尝试&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">rsync -r $HOME/mydocuments me@remote:/home/me
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这会直接把 &lt;code>$HOME/mydocuments&lt;/code> 传到远程的 &lt;code>/home/me&lt;/code> 文件夹下，形成 &lt;code>/home/me/mydocuments&lt;/code> 这样的结构。&lt;/p>
&lt;p>那么假如你是想说，我要把 &lt;code>$HOME/mydocuments&lt;/code> &lt;strong>里面的内容&lt;/strong> 传到 &lt;code>/home/me/another/position&lt;/code> 的话，那你就需要带上这个斜杠了，因为 &lt;code>rsync&lt;/code> 就会聪明地帮你把文件夹里面的所有内容传到目标位置的那个文件夹里。也许也算是符合 “一切皆文件” 的思想了吧，如果你不带分隔符，就会以文件形式把这个 &lt;em>文件&lt;/em> 传到文件夹里；而如果带上路径分隔符，则说明你要传的是文件夹的内容。&lt;/p>
&lt;h3 id="远程链接">远程链接
&lt;/h3>&lt;p>作为一款远程同步软件，自然需要有办法告诉 &lt;code>rsync&lt;/code> 要把文件从哪里发到哪里。好消息是，&lt;code>rsync&lt;/code> 支持我们通过 SSH 传输文件，而方法也特别简单。只需要在文件路径前面添加上你的用户名和主机名就可以了。如果你设置了 SSH 的主机名，甚至可以更方便。&lt;/p>
&lt;p>这里举个很简单的例子，从本机传到本机，但是通过 SSH 进行。我们可以通过 &lt;code>ssh &amp;lt;user&amp;gt;@localhost&lt;/code> 来登录到本机的本地账户上，我的用户名是 &lt;code>amoment&lt;/code>，所以就会用 &lt;code>ssh amoment@localhost&lt;/code> 来登录到本机。那么我们就可以这样告诉 &lt;code>rsync&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="go">rsync -r /home/amoment/myfiles/ amoment@localhost:/home/amoment/somefolder
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来把我家目录下的 &lt;code>myfiles&lt;/code> 文件夹里的内容复制/同步到同在家目录下的 &lt;code>somefolder&lt;/code> 文件夹下。有了这个例子，你应该也明白怎么跨设备使用 &lt;code>rsync&lt;/code> 通过 SSH 进行连接与文件传输了吧。&lt;/p>
&lt;p>除了使用 SSH 协议以外，&lt;code>rsync&lt;/code> 还支持一些其他的协议，比如所谓的 RSH，或者 &lt;code>rsync&lt;/code> 自带的 &lt;code>rsync://&lt;/code> 协议。但是由于 SSH 的支持还是更加广泛，我们这里还是只介绍该方案。如果感兴趣的话，可以查阅 &lt;code>rsync&lt;/code> 的手册或者文档等资料。&lt;/p>
&lt;h3 id="一些重要的参数">一些重要的参数
&lt;/h3>&lt;p>下面列举一些重要的，可能会经常使用到的参数。我们按一个大致的类别做区分，方便查找。&lt;/p>
&lt;h4 id="文件操作">文件操作
&lt;/h4>&lt;ul>
&lt;li>&lt;code>-r --recursive&lt;/code>: 递归模式&lt;/li>
&lt;/ul>
&lt;p>它的意思是 &lt;em>recursive&lt;/em>，也就是递归地把所有内容都传过去。如果不加这个东西，会发生什么呢？好消息是你照样能完成传输，但是坏消息是，你 &lt;strong>只传过去了文件夹&lt;/strong>。也就是说，如果你不是只想在目标位置创建一个可能是新的文件夹的话，而是想把文件都传过去，请记得带上 &lt;code>-r&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-a -- archive&lt;/code>: 存档模式&lt;/li>
&lt;/ul>
&lt;p>你也可以选择不使用 &lt;code>-r&lt;/code> 而是使用 &lt;code>-a&lt;/code>，使用 &lt;code>-a&lt;/code> 会以存档方式传输文件，也就是说，文件夹内的所有东西都会 &lt;em>保持原样&lt;/em> 地传过去：不论是文件，文件夹，还是链接，设备描述符等，全都会原样传过去。&lt;code>-a&lt;/code> 实际上是一系列参数的总和。根据帮助文档所述，是 &lt;code>-rlptgoD&lt;/code>。还挺多的……&lt;/p>
&lt;ul>
&lt;li>&lt;code>--delete&lt;/code>: 允许删除不同步的内容&lt;/li>
&lt;/ul>
&lt;p>因为 &lt;code>rsync&lt;/code> 如其名所示，是 &lt;em>同步软件&lt;/em>，因此我们也许希望不是 “上传” 文件，而是 &lt;em>把本地文件结构同步到远程&lt;/em>。此时，我们需要用到 &lt;code>--delete&lt;/code> 这个参数，它给了 &lt;code>rsync&lt;/code> 删除目标文件夹内多余文件的权利，从而保证你确实是在 &lt;em>同步&lt;/em> 内容。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--exclude&lt;/code> &lt;code>--include&lt;/code>: 按模式进行排除/包含&lt;/li>
&lt;/ul>
&lt;p>这两个参数我们放在一起讲。如其名称所述，是用来告诉 &lt;code>rsync&lt;/code> 排除哪些文件或者包含哪些文件用的。如果你有些文件不想传/特意要传，请设置这两个参数。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--ignore-existing&lt;/code>: 跳过传输同名文件&lt;/li>
&lt;/ul>
&lt;p>加上这个参数会让 &lt;code>rsync&lt;/code> 检查接收端已有文件的名字，如果本地和接收端都有这么个文件（名称相同），则会跳过这个文件不进行传输。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-u --update&lt;/code>: 只传输更新的内容&lt;/li>
&lt;/ul>
&lt;p>这个参数意味着你是打算 &lt;em>更新&lt;/em> 文件们。那么，如果接收端的文件比发送端更新（还要新）呢？答案就是不会碰这些文件。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-z --compress&lt;/code>: 先压缩一下&lt;/li>
&lt;/ul>
&lt;p>这个参数会告诉 &lt;code>rsync&lt;/code> 传输前先帮你把要传的东西压缩一下。&lt;code>rsync&lt;/code> 会自己选择一个压缩方法，所以一般不用担心。&lt;/p>
&lt;h4 id="信息提供">信息提供
&lt;/h4>&lt;ul>
&lt;li>&lt;code>-n --dry-run&lt;/code>: 试运行&lt;/li>
&lt;/ul>
&lt;p>你要是担心传过去的内容不是你实际打算传的东西，你可以先让 &lt;code>rsync&lt;/code> 告诉你目前的命令会传些什么，且不真的开始工作，只需要加上 &lt;code>-n&lt;/code> 就可以。你可以把它理解为 &lt;em>no&lt;/em>，即便实际上它对应的长参数是 &lt;code>--dry-run&lt;/code>。拿不准会传些什么过去的时候，这个命令会很有用。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-v --verbose&lt;/code>: 更啰嗦一些&lt;/li>
&lt;/ul>
&lt;p>几乎所有（较复杂）的命令行程序都会内置这样一个命令，来把工作信息 “更啰嗦” 地显示出来。如果你需要额外的信息，请使用这个参数。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-P&lt;/code>: 进度条&lt;/li>
&lt;/ul>
&lt;p>就是让 &lt;code>rsync&lt;/code> 报告当前的传输进度。我很喜欢用。&lt;/p>
&lt;h4 id="涉及-rsync-本身--远程协作">涉及 &lt;code>rsync&lt;/code> 本身 / 远程协作
&lt;/h4>&lt;ul>
&lt;li>&lt;code>-e --rsh&lt;/code>: 指定传输协议&lt;/li>
&lt;/ul>
&lt;p>可能我们要传输的设备开放的 SSH 端口不在默认的 &lt;code>22&lt;/code> 而是一个自定义的端口。此时我们就需要 &lt;code>-e&lt;/code> 然后在后面带上一个字符串来表示使用的 shell 是哪个。比如我的远程接收端接口是 &lt;code>1145&lt;/code>，则我会使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="go">rsync -r -e &amp;#34;ssh -p 1145&amp;#34; /myfiles/ me@remote:/myfiles
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来让 &lt;code>rsync&lt;/code> 尝试使用 &lt;code>1145&lt;/code> 端口进行 SSH 通信与文件传输。&lt;/p>
&lt;ul>
&lt;li>&lt;code>--rsync-path&lt;/code>: &lt;code>rsync&lt;/code> 在哪？&lt;/li>
&lt;/ul>
&lt;p>有可能我们需要帮助本地的 &lt;code>rsync&lt;/code> 来寻找到另一个 &lt;code>rsync&lt;/code> 究竟在哪。此时我们就需要这个参数来发挥作用，在后面带上找到 &lt;code>rsync&lt;/code> 的方法：不论是 &lt;code>rsync&lt;/code> 的路径，还是别的方式，都可以。比如希望传输的设备有 &lt;code>rsync&lt;/code>，但是在 WSL 上。此时我们就可以&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="go">rsync -r --rsync-path &amp;#39;wsl rsync&amp;#39; me@remote:/myfiles/ /myfiles
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来让远程使用 WSL 上的 &lt;code>rsync&lt;/code> 为我进行工作。&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>我一开始使用 &lt;code>rsync&lt;/code> 的主要理由其实是为了在不同的设备之间同步我的歌曲库。由于我有一些歌曲通过移动硬盘已经移动了一部分，而还有一部分没有同步，在另一台电脑上我甚至新添加了一张专辑，所以感觉单纯地自己手动搜索要迁移的文件有点太累了。而此时，&lt;code>rsync&lt;/code> 用它 &lt;strong>增量同步&lt;/strong> 的特性吸引了我，我便使用这么个方式来把远程的歌曲同步到本地电脑上来。&lt;/p>
&lt;p>&lt;code>rsync&lt;/code> 还是挺好用的，它的语法可能没有那么智能，但是已经足以应付我遇到的问题了。印象中还有一些别的同步软件，比如朋友推荐的 &lt;code>Syncthing&lt;/code>，也许后面会尝试使用一下。&lt;/p>
&lt;p>另外不得不提的是我在准备该文章时查阅过的信息源。非常感谢！&lt;/p>
&lt;ul>
&lt;li>首先，ChatGPT 和 Deepseek，完全不了解的时候和这些 AI 问一下还是挺好用的；&lt;/li>
&lt;li>&lt;a class="link" href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories" target="_blank" rel="noopener"
>rsync tutorial&lt;/a>: 一个简单的 rsync walkthrough，帮了我很多；&lt;/li>
&lt;li>&lt;a class="link" href="https://www.geeksforgeeks.org/linux-unix/rsync-command-in-linux-with-examples/" target="_blank" rel="noopener"
>rsync command in Linux with Examples&lt;/a>: GeeksForGeeks 下的一个博客，内容很丰富。&lt;/li>
&lt;/ul>
&lt;p>最后，感谢您能看到这里，祝您身体健康，心情愉悦~&lt;/p></description></item><item><title>上一个命令是什么？</title><link>https://a-moment096.github.io/p/%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Sat, 26 Jul 2025 20:09:18 +0800</pubDate><guid>https://a-moment096.github.io/p/%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88/SEASIDE_SOLILOQUIES.png" alt="Featured image of post 上一个命令是什么？" />&lt;p>&lt;em>曾经总会好奇：怎么获取上一个命令呢？应该很简单才对吧？简单的搜索后，下面是我得到的结果，就记录一下吧&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 Orangestar 的专辑 &lt;strong>SEASIDE SOLILOQUIES&lt;/strong>, 好看又好听。所以这里贴曲就贴这个专辑的主打歌好了：一首 &lt;strong>Alice in 冷凍庫&lt;/strong>，希望你喜欢。&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=458231453" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="什么时候要用这个">什么时候要用这个？
&lt;/h2>&lt;p>有时候我们写了一长串命令，比如有很麻烦的路径之类的，这时候我们可能会希望用某个符号来自动地填上命令里的某些参数。一个最常见的例子，当我要安装某些软件包的时候，偶尔会忘记加上 &lt;code>sudo&lt;/code> 来以管理员权限运行。这时候把上面的命令复制一遍再补上 &lt;code>sudo&lt;/code> 实在是太慢了，而按下上箭头后在把光标挪到第一行，最后补上 &lt;code>sudo&lt;/code> 总是感觉很累，手的移动距离感觉好远。除此之外，有时输入的一长串命令/参数并运行之后，我需要接着上面的参数继续运行别的命令，此时要是用命令行历史的话，就又得用光标定位之后，再删掉没有用的东西，最后再填上要替换的内容。这实在是太慢了。&lt;/p>
&lt;p>好在这时候，我们还可以使用 &lt;code>zsh&lt;/code> 交互模式下的一个内置宏：使用 &lt;code>!&lt;/code>，感叹号，以及其对应的一些变体，来获取上个命令中的参数/整个命令等。下面就来介绍怎么使用吧。&lt;/p>
&lt;h2 id="我需要取整个命令">我需要取整个命令
&lt;/h2>&lt;h3 id="上个命令是什么">上个命令是什么？
&lt;/h3>&lt;p>我们可以用 &lt;code>!!&lt;/code>，或者 &lt;code>!-1&lt;/code>， 来获取 “上一个执行了的命令”。比如如下操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> hello bash world!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">hello bash world!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !! &lt;span class="c1"># !! 替换了上面整个执行了的命令，也就是替换了 &amp;#34;echo hello bash world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="nb">echo&lt;/span> hello bash world!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-1 &lt;span class="c1"># 同上,也是替换上面执行的命令，所以替换了 &amp;#34;echo echo hello bash world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="nb">echo&lt;/span> hello bash world!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="我要调用历史命令">我要调用历史命令
&lt;/h3>&lt;p>我们还可以用 &lt;code>!&amp;lt;num&amp;gt;&lt;/code> 来选择某个历史命令。我们可以先用 &lt;code>head&lt;/code> 来查看一下我们的命令历史里最早有一些什么：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">$ head ~/.zsh_history &lt;span class="c1"># 这里我的 zsh 命令历史存在这个文件里，可以用 head 查看前几个命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">: 12345:0&lt;span class="p">;&lt;/span>clear
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">: 12346:0&lt;span class="p">;&lt;/span>&lt;span class="nb">echo&lt;/span> hello
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">: 12347:0&lt;span class="p">;&lt;/span>ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="c1">## ... ... &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>随后我们可以使用 &lt;code>!1&lt;/code> 来选择历史命令中的第一个命令，这里的第一个命令就是 &lt;code>clear&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">$ !1 &lt;span class="c1"># 执行第一个历史命令，也就是 clear，会直接清空屏幕；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">$ !2 &lt;span class="c1"># 执行第二个历史命令，会打印 hello；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">hello
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">$ !3 &lt;span class="c1"># 执行第三个历史命令，会打印当前文件夹下的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">file1 file2 file3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="小结">小结
&lt;/h3>&lt;p>我们可以看到，后面跟着的数字实际上表示了“第几个命令”，而举一反三，&lt;code>!-1&lt;/code> 则代表的是“最后一个命令”，即上一个命令，那么 &lt;code>!-2&lt;/code> 就是倒数第二个命令。&lt;/p>
&lt;blockquote>
&lt;p>有了这两个命令，我们可以很方便地在忘记使用 &lt;code>sudo&lt;/code> 权限时，使用 &lt;code>sudo !!&lt;/code> 或者选择某个历史命令，来快速使用 &lt;code>sudo&lt;/code> 权限执行命令。&lt;/p>&lt;/blockquote>
&lt;h2 id="我需要取几个参数">我需要取几个参数
&lt;/h2>&lt;h3 id="我需要某个参数">我需要某个参数
&lt;/h3>&lt;p>我们可以使用 &lt;code>:&amp;lt;num&amp;gt;&lt;/code> 来选择第几个参数。它需要配合 &lt;code>!&lt;/code> 进行使用。参数从 1 开始，而 0 有特殊含义，代表命令。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> one two three
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">one two three
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-1:2 &lt;span class="c1"># 相当于 echo two&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">two
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !:0 &lt;span class="c1"># 上个命令使用了 echo，所以 0 代表 echo，这个命令相当于 echo echo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">&lt;span class="nb">echo&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当使用 &lt;code>:&lt;/code> 来进行参数选择时，如果是从上一个命令中选择则可以简写为 &lt;code>!:&amp;lt;num1&amp;gt;-&amp;lt;num2&amp;gt;&lt;/code>。&lt;/p>
&lt;h3 id="我需要这几个参数">我需要这几个参数
&lt;/h3>&lt;p>我们还能用 &lt;code>:&amp;lt;num1&amp;gt;-&amp;lt;num2&amp;gt;&lt;/code> 来范围式地选择命令的参数。比如，使用 &lt;code>!!:1-2&lt;/code> 就说明要取第一个和第二个参数。（注意这里是参数，不是空格分隔的字符串，也不包含第一个词（也就是命令））。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> one two three four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">one two three four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !!:1-2 &lt;span class="c1"># 相当于 echo one two &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">one two
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> one two three four &lt;span class="c1"># 这行用来重置最后一个命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">one two three four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !!:-3 &lt;span class="c1"># 没有 &amp;lt;num1&amp;gt; 则会自动替换为0，相当于 echo echo one two three&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="nb">echo&lt;/span> one two three
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-2:1-2 &lt;span class="c1"># 配合 !&amp;lt;num&amp;gt; 使用，相当于 echo one two &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">one two
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-3:1- &lt;span class="c1"># 没有 &amp;lt;num2&amp;gt; 则会匹配到除了最后一个参数外的参数，相当于 echo one two three&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">one two three
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-4:$ &lt;span class="c1"># 使用 $ 来获取最后一个参数，相当于 echo four&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-5:3-$ &lt;span class="c1"># 同样 $ 也支持范围选择，相当于 echo three four&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl">three four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !-6:* &lt;span class="c1"># 使用 * 来表示所有的参数，相当于 echo !-6:1-$，也就是 echo one two three four&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl">one two three four
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl">$ &lt;span class="nb">echo&lt;/span> !:* &lt;span class="c1"># !: 是在使用冒号时 !!: 或者 !-1: 的简写，相当于 echo one two three four&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl">one two three four
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果没有 &lt;code>&amp;lt;num1&amp;gt;&lt;/code>，则默认从 &lt;code>0&lt;/code> 开始，也就是会包含所有内容；如果没有 &lt;code>&amp;lt;num2&amp;gt;&lt;/code>，则默认停在最后一个参数前。可以使用 &lt;code>*&lt;/code> 来选择所有的参数，使用 &lt;code>$&lt;/code> 选择最后一个参数。&lt;/p>
&lt;h2 id="我要对字符串做处理">我要对字符串做处理
&lt;/h2>&lt;p>在冒号后使用一些字母来做相应的处理。假设有命令 &lt;code>ls /path/to/a/file.txt&lt;/code> 并且我们使用 &lt;code>echo !:1&lt;/code> 尝试调用这个 &lt;code>ls&lt;/code> 的命令，则下面的参数选择器可以做到：&lt;/p>
&lt;ul>
&lt;li>&lt;code>:p&lt;/code> (print) 只打印，不运行，或者说提供一个预览。ZSH 用户也许不需要担心这一点。&lt;/li>
&lt;li>&lt;code>:q&lt;/code> (quote) 对选中字段加上引号，结果为 &lt;code>'/path/to/a/file'&lt;/code>&lt;/li>
&lt;li>&lt;code>:r&lt;/code>（root）取文件的完整文件名，结果为 &lt;code>/path/to/a/file&lt;/code>&lt;/li>
&lt;li>&lt;code>:e&lt;/code>（extension）取文件的后缀名，结果为 &lt;code>txt&lt;/code>&lt;/li>
&lt;li>&lt;code>:h&lt;/code>（head）取文件路径的地址，结果为 &lt;code>/path/to/a/&lt;/code>&lt;/li>
&lt;li>&lt;code>:t&lt;/code>（tail）取文件的名称，结果为 &lt;code>file.txt&lt;/code>&lt;/li>
&lt;li>&lt;code>:s/to/has&lt;/code>（search）可以在参数中寻找&lt;em>第一个&lt;/em> &lt;code>to&lt;/code> 并替换为 &lt;code>has&lt;/code>，结果为 &lt;code>/path/has/a/file.txt&lt;/code>&lt;/li>
&lt;li>&lt;code>:gs/to/has&lt;/code>（global search）同上，但是全局查找替换。&lt;/li>
&lt;/ul>
&lt;h2 id="tldr">TL;DR
&lt;/h2>&lt;p>下面是一个表格简单描述这些用法&lt;/p>
&lt;h3 id="命令选择使用-">命令选择（使用 &lt;code>!&lt;/code>）
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>语法&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>!!&lt;/code>&lt;/td>
&lt;td>上一条命令&lt;/td>
&lt;td>&lt;code>sudo !!&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!-n&lt;/code>&lt;/td>
&lt;td>倒数第 n 条命令&lt;/td>
&lt;td>&lt;code>!-2&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!n&lt;/code>&lt;/td>
&lt;td>第 n 条历史命令&lt;/td>
&lt;td>&lt;code>!42&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!字符串&lt;/code>&lt;/td>
&lt;td>最近以该字符串开头的命令&lt;/td>
&lt;td>&lt;code>!ls&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!?字符串?&lt;/code>&lt;/td>
&lt;td>最近包含该字符串的命令&lt;/td>
&lt;td>&lt;code>!?foo?&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^旧^新&lt;/code>&lt;/td>
&lt;td>将上一条命令中第一个“旧”替换为“新”&lt;/td>
&lt;td>&lt;code>^cat^bat&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="参数选择-使用-">参数选择 （使用 &lt;code>:&lt;/code>）
&lt;/h3>&lt;p>下面的示例命令使用 &lt;code>echo file.txt&lt;/code> 来做演示。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>语法&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>!!:0&lt;/code>&lt;/td>
&lt;td>上一条命令的命令名&lt;/td>
&lt;td>&lt;code>!!:0&lt;/code> → &lt;code>echo&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:1&lt;/code>&lt;/td>
&lt;td>第一个参数&lt;/td>
&lt;td>&lt;code>!!:1&lt;/code> → &lt;code>file.txt&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:2&lt;/code>&lt;/td>
&lt;td>第二个参数&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:$&lt;/code>&lt;/td>
&lt;td>最后一个参数&lt;/td>
&lt;td>&lt;code>!!:$&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:*&lt;/code>&lt;/td>
&lt;td>所有参数（等同于 &lt;code>!!:1-$&lt;/code>）&lt;/td>
&lt;td>&lt;code>!!:*&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:1-3&lt;/code>&lt;/td>
&lt;td>第 1 到第 3 个参数&lt;/td>
&lt;td>&lt;code>!!:1-3&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!!:2-$&lt;/code>&lt;/td>
&lt;td>从第 2 个到最后一个参数&lt;/td>
&lt;td>&lt;code>!!:2-$&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!$&lt;/code>&lt;/td>
&lt;td>上一条命令的最后一个参数 (可以省略冒号)&lt;/td>
&lt;td>&lt;code>cat !$&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!*&lt;/code>&lt;/td>
&lt;td>上一条命令的所有参数（可以省略冒号）&lt;/td>
&lt;td>&lt;code>rm !*&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="参数修饰">参数修饰
&lt;/h3>&lt;p>下面的示例命令使用 &lt;code>echo /path/to/file.txt&lt;/code> 来做演示。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>修饰符&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>示例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>:p&lt;/code>&lt;/td>
&lt;td>只打印命令，不执行&lt;/td>
&lt;td>&lt;code>sudo !!:p&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:q&lt;/code>&lt;/td>
&lt;td>给参数加引号，避免空格或特殊字符问题&lt;/td>
&lt;td>&lt;code>echo !!:1:q&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:h&lt;/code>&lt;/td>
&lt;td>获取路径头部（类似 &lt;code>dirname&lt;/code>）&lt;/td>
&lt;td>&lt;code>echo !!:1:h&lt;/code> → &lt;code>/path/to&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:t&lt;/code>&lt;/td>
&lt;td>获取路径尾部（类似 &lt;code>basename&lt;/code>）&lt;/td>
&lt;td>&lt;code>echo !!:1:t&lt;/code> → &lt;code>file.txt&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:r&lt;/code>&lt;/td>
&lt;td>去掉文件扩展名（保留主名）&lt;/td>
&lt;td>&lt;code>echo !!:1:r&lt;/code> → &lt;code>file&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:e&lt;/code>&lt;/td>
&lt;td>获取文件扩展名&lt;/td>
&lt;td>&lt;code>echo !!:1:e&lt;/code> → &lt;code>txt&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:s/旧/新/&lt;/code>&lt;/td>
&lt;td>替换第一个出现的子串&lt;/td>
&lt;td>&lt;code>!!:1:s/foo/bar/&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>:gs/旧/新/&lt;/code>&lt;/td>
&lt;td>替换所有出现的子串&lt;/td>
&lt;td>&lt;code>!!:1:gs/foo/bar/&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>这里其实应该没有写完，不过就这些已经列出来的方法而言，我个人感觉是已经挺够用的了。毕竟，平时最常用的也就是 &lt;code>sudo !!&lt;/code> 来给 &lt;code>pamcan -Syu&lt;/code> 补上管理员权限而已，或者是在 &lt;code>ls -l /path/to/file&lt;/code> 确定文件/文件夹存在后用 &lt;code>vim&lt;/code> 或者 &lt;code>cd&lt;/code> 打开它罢了。&lt;/p>
&lt;p>还有一点要注意的是，&lt;code>bash&lt;/code> 默认是不会像 &lt;code>zsh&lt;/code> 一样先提供一个预览，让你看看会发生什么的，而是直接就运行命令了。所以也许在 &lt;code>bash&lt;/code> 中使用这个功能时需要额外注意，特别是涉及一些比较危险的动作，比如 &lt;code>rm&lt;/code> 这类命令。此时你可以尝试先用 &lt;code>:p&lt;/code> 来打印出来要运行的命令，没啥问题就可以运行了。印象中应该还有一个办法，来让 &lt;code>bash&lt;/code> 也先提供一个预览而非直接运行。不过，因为我用的是 &lt;code>zsh&lt;/code>，就不纠结这个问题了。也许以后我还会更新这篇文章呢？哈哈。&lt;/p>
&lt;p>那么，感谢你看到这里，祝您身心愉悦，身体健康~&lt;/p></description></item><item><title>C++ Vector 的内存布局</title><link>https://a-moment096.github.io/p/c-vector-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link><pubDate>Tue, 27 May 2025 09:53:29 +0800</pubDate><guid>https://a-moment096.github.io/p/c-vector-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid><description>&lt;img src="https://a-moment096.github.io/p/c-vector-%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/Bamboo_Reimu.jpg" alt="Featured image of post C++ Vector 的内存布局" />&lt;p>&lt;em>探索一下 C++ 的容器 &lt;code>vector&lt;/code> 的内存布局，也算是解答我自己的一些疑虑咯&lt;/em>&lt;/p>
&lt;p>&lt;em>头图是从网上搜的，尝试寻找出处，未果。很可惜。选曲尝试选择了一首听着比较清淡的曲子 &lt;strong>泪苔&lt;/strong>，感觉比较符合头图清新淡雅的神社氛围。希望你喜欢。&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=26537200" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="先介绍一下-vector-的基本情况咯">先介绍一下 &lt;code>vector&lt;/code> 的基本情况咯
&lt;/h2>&lt;p>&lt;code>vector&lt;/code> 是由 C++ 标准库提供的一个容器模板类。这里不打算仔细介绍什么是容器，模板，什么是类，我们直接指出：&lt;code>vector&lt;/code> 的作用就是一个更好用的数组。“类”是说明它自己带了一些好用的函数，称为“方法”，“模板”就是说它需要接受一个类型作为参数才能成为一个完整的类型，就像数组必须说明是什么东西的数组一样。最后“容器”就是说它是一类经过了特殊优化的模板类，和别的容器一起共用着一些方法与成员，且有一类公共的算法可以用在它们上面。&lt;/p>
&lt;p>和传统的数组相比，&lt;code>vector&lt;/code>有这样的几个特点：首先它符合 &lt;em>RAII&lt;/em> (Resource Allocation Is Initialization) 的要求，即自动管理内存，离开作用域时自动销毁，而传统的数组则不是很满足 &lt;em>RAII&lt;/em> 的条件；其次就是 &lt;code>vector&lt;/code> 是动态大小的，在使用时不需要在编译期就了解这个东西的大小，程序会根据需求自动分配内存。虽然后者在 C 中也能实现，比如指针+ &lt;code>malloc&lt;/code> 或者指针+ &lt;code>new&lt;/code> 的组合，然而这样的组合需要直接面对自己创建的裸指针 (Raw Pointer)，一个不小心就很容易造成内存泄漏，所以使用时要特别注意。最后就是，相比起数组这样较基础的数据类型，使用 &lt;code>vector&lt;/code> 的内建函数（方法）可以避免自己造一些轮子，会比较方便。&lt;/p>
&lt;p>即便 &lt;code>vector&lt;/code> 看起来这么好，其实还是有人会担心 &lt;code>vector&lt;/code> 会引入额外的运行开销。特别是，有人可能会怀疑：我使用数组或者指针+&lt;code>malloc&lt;/code>或者指针+&lt;code>new&lt;/code> 得到的内存空间我是明确知道时连续的，那 &lt;code>vector&lt;/code> 呢？它经过这样的包装之后，还拥有连续内存空间吗？这篇文章就是打算探讨这个问题。&lt;/p>
&lt;h2 id="vector-为什么可能会比较低效">&lt;code>vector&lt;/code> 为什么“可能”会比较低效？
&lt;/h2>&lt;p>我们这里不打算介绍什么复杂的内容，比如什么 allocator 或者内存调度机制。我们只对“指针+&lt;code>malloc&lt;/code>”、“指针+new”方法以及&lt;code>vector&lt;/code>方法是怎么获取可用内存空间的方法进行简单说明。&lt;/p>
&lt;p>不过在进入具体的内存分配过程介绍之前，我们希望能先介绍几个概念：&lt;/p>
&lt;h3 id="堆与栈">堆与栈
&lt;/h3>&lt;p>我们写好的程序在运行时，需要同系统进行交互，借由多种系统调用完成任务。而在程序运行的过程中需要的内存空间则也是由系统进行分配的。一般我们将系统分配的内存空间划分为两块，一块叫&lt;em>堆&lt;/em>，而另一块儿叫&lt;em>栈&lt;/em>。请注意这里的堆栈并不能直接对应数据结构，请仅将其看作内存空间的称呼。&lt;/p>
&lt;p>程序运行时，系统会将调用的函数一个一个压入调用栈中，栈空间内实行先进后出（也是栈这一称呼的来源），连带着函数需要的变量也是一样压入栈内的。然而，栈实际上相对比较小，如果在栈内存放了过多的资源导致栈内空间不足，程序则会出现所谓的栈溢出 (Stack Overflow)。不过好消息是，系统并不会傻傻地将任何东西都放在宝贵的栈空间内，在存储大量内容时，可以把这些内容存储在堆中。&lt;/p>
&lt;p>堆和栈都是由系统负责内存分配的，区别在于，栈是严格执行先进后出的，且空间有限，只负责函数调用等，资源会被自动回收；而堆则不同，堆相比栈而言会比较大，里面的资源不需要什么先进后出，然而在程序不再用到里面存储的资源时，系统也不会自动回收它们，取用这些内存资源的方式也是需要通过指针进行读取或写入的。所以相比栈空间，堆空间的运用更需要一些技巧，如果使用比较传统的方式的话。有句话很好地形容了堆：垃圾堆。如果能很好地管理这里的内容，那样就会很好用，否则就会让系统东留一块儿垃圾西留一块儿垃圾，最后变成垃圾堆。所以C/C++编程的一大技巧就是使用好堆上的空间。&lt;/p>
&lt;p>那么，我们应该如何，按照上面所述的方法，进行堆上的内存管理呢？&lt;/p>
&lt;h3 id="malloc-的内存分配方法">&lt;code>malloc&lt;/code> 的内存分配方法
&lt;/h3>&lt;p>传统的指针+&lt;code>malloc&lt;/code>方法大概是这样工作的：首先声明一个指针，它不指向什么具体的内存地址（空指针），然后再通过 &lt;code>malloc&lt;/code> 中传入的参数来决定从这个指针开始要给它多大的连续空间（一个内存段），最后让这个指针指向这个内存段的头部，从而完成内存分配。这样的方法最大的特点是它不需要编译时就确定好需要多大的内存，而是通过 &lt;code>malloc&lt;/code> “动态地” 分配一段内存，然后交给这个指针进行管理。在 C 语言写的程序中，基本都是这么进行运行期间的内存分配的。&lt;/p>
&lt;p>这样的内存分配方法，在 C 语言兴起的时候，是非常伟大的。然而这个方法存在着很多的问题：首先就是指针操作的复杂性。使用 &lt;code>malloc&lt;/code> 时必须留意管理内存资源的指针。在内存不再被使用时必须调用 &lt;code>free&lt;/code> 函数来释放资源，且在 &lt;code>free&lt;/code> 之后就不能再次调用这个资源来。很多程序运行崩溃，都是由指针造成的，或者是忘记删除已经不需要的资源，或者是引用了空指针或者悬垂指针。另外就是使用 &lt;code>malloc&lt;/code> 分配的内存实际上也没有那么动态：如果你声明了 100 字节的内存，那就一定而且只有 100 字节的连续内存可以用：如果你实际上用不到 100 字节，那多余的空间会被浪费，不过这样还好；而当你用了超过 100 个字节的数据，却尝试将它们放在 100 个字节的内存段中时，多出来的部分会直接被截断，也就是说多出来的部分就消失了。最后，很致命的一点是，&lt;code>malloc&lt;/code> 是一个很不智能的函数。它没有类型（返回 &lt;code>void*&lt;/code>）,不调用构造函数，且必须要手动计算好分配的字节数，然后传给它。这实在是一个坏消息。而即便你注意了资源的声明与使用，使用裸指针管理资源的过程也比较繁琐：你需要使用一些诸如 &lt;code>memcpy&lt;/code> 这样的函数来管理内存，这些函数操作非常精细，它会要求操作的字节数量。有机会在程序运行的时候分配内存，这很好，但也许会显得有点太麻烦了。&lt;/p>
&lt;p>所以，我更愿意称使用 &lt;code>malloc&lt;/code> 进行内存管理更适合 “高级用户”。一般而言，除非有很明确的需求，否则不会考虑使用老式的 &lt;code>malloc&lt;/code> 进行内存分配，特别是在我们讨论的 C++ 语境下。那么 &lt;code>new&lt;/code> 又如何呢？&lt;/p>
&lt;h3 id="new-的内存分配方法">&lt;code>new&lt;/code> 的内存分配方法
&lt;/h3>&lt;p>相比于 &lt;code>malloc&lt;/code>，&lt;code>new&lt;/code> 更加智能，更加符合C++的思路。它会自动调用构造函数，不需要手动计算内存量（编译器会帮你计算好），且它是强类型的，它分配的内存空间会有一个明确的类型，而不是 &lt;code>void*&lt;/code> 这样模棱两可的东西。然而，这里的“智能”，也只有这种程度了。究其原因，还是因为使用裸指针的原因。由于使用指针，就必须在不再使用资源时手动 &lt;code>delete&lt;/code> 掉它（&lt;code>malloc&lt;/code> 使用 &lt;code>free&lt;/code> 释放，&lt;code>new&lt;/code> 使用 &lt;code>delete&lt;/code> 释放）。仅此一点就使 &lt;code>new&lt;/code> 也不是一个特别理想的方法。它解决了一些 &lt;code>malloc&lt;/code> 的痛点，但是没有解决使用裸指针带来的最根本的问题。&lt;/p>
&lt;p>也许有朋友会讲：你提到的是裸指针，而我记得 C++ 标准 在 C++11 时引入了智能指针。它是符合 &lt;em>RAII&lt;/em> 规则的裸指针的包装，也就是说在不使用时可以自动销毁来释放资源。为什么不使用智能指针解决这些问题呢？&lt;/p>
&lt;p>没错，智能指针的引入确实能有效改善这个问题，如果需要使用指针进行操作时，换用智能指针确实是一种很好的方法。但是我们只是希望拿一块内存存储数组那样的东西，使用智能指针也许有点太重量级了。也许有人中意智能指针以及使用指针方式来进行内存管理，不过这里就不多介绍智能指针了。那既然 &lt;code>malloc&lt;/code> 和 &lt;code>new&lt;/code> 都不是非常令人满意的答案，&lt;code>vector&lt;/code> 就能解决这些问题吗？&lt;/p>
&lt;h3 id="vector-的内存分配方法">&lt;code>vector&lt;/code> 的内存分配方法
&lt;/h3>&lt;p>我们首先给出肯定的回复：Yes, &lt;code>vector&lt;/code> 是 &lt;strong>“我需要一块我不知道内存大小的连续内存段”&lt;/strong> 的非常好的解决方案。实际上也许 &lt;code>vector&lt;/code> 会比想象中的更好用。&lt;code>vector&lt;/code> 首先是符合 &lt;em>RAII&lt;/em> 的，这使得我们不需要特别关注声明的资源：这些资源在离开其作用域时就自动被销毁了。不用再担心内存泄漏，也不用担心空指针之类。另外 &lt;code>vector&lt;/code> 虽然实际上是将资源放在堆上的，对 &lt;code>vector&lt;/code> 的操作实际上就像是在栈上操作它一样，对它的操作要比指针操作之类要直观的多。最后，使用 &lt;code>vector&lt;/code> 不用担心空间不足：当 &lt;code>vector&lt;/code> 内的空间不足以容纳新的东西时，&lt;code>vector&lt;/code> 会自动增加其容量，来容纳这些新的东西。这个操作在编程侧是近乎无感的：你可以直接把 &lt;code>vector&lt;/code> 当做一个无限容量的容器，你要做的事情就是往里装就 OK 了。使用 &lt;code>vector&lt;/code> 是很符合直觉的，给代码作者的心智负担也比较小。毕竟，封装地这么好，你只管往里 push 就好了，不用操心什么多余的问题，&lt;code>vector&lt;/code> 会帮你处理好的。&lt;/p>
&lt;p>也许有人会担心：&lt;code>vector&lt;/code> 就一点问题都没有？很可惜， &lt;code>vector&lt;/code> 也是需要正确使用的，否则就是会很低效。这一点主要体现在 &lt;code>vector&lt;/code> 的自动扩容上。&lt;code>vector&lt;/code> 的扩容机制是这样的：如果容量不够，就在当前容量上乘2（或1.5，取决于具体实现）来容纳新东西。乍一听没什么问题，而实际上扩容是一个很复杂也很慢的过程。我们下面会更深入地聊聊这个问题。另外，&lt;code>vector&lt;/code> 的内存真的是连续的吗？可以通过什么方法来看到其内存布局吗？我们后面也会尝试使用程序来把内存地址打印到屏幕上，看看是个什么样子。最后，当你很明确自己需要的就是固定长度的内存区域时，&lt;code>vector&lt;/code> 自动增长内存空间的做法可能就不合适了。这时你也许会更想使用数组的现代包装 &lt;code>std::array&lt;/code>，而非 &lt;code>vector&lt;/code>。&lt;/p>
&lt;p>最后，&lt;code>vector&lt;/code> 实际上也提供了和 C 的裸指针相容的对象，通过调用 &lt;code>vector::data()&lt;/code> 方法即可获得 &lt;code>vector&lt;/code> 内存段对应的裸指针。这样一来，需要精细操作或者与老 API 做兼容时也很方便。&lt;/p>
&lt;h3 id="连续的内存空间很重要吗">连续的内存空间很重要吗？
&lt;/h3>&lt;p>上面我们一直强调“连续的内存空间”，也许有人会好奇，连续的内存空间很重要吗？答案是肯定的：连续的内存空间可以有效提高内存寻址速度，从而提高访问和读写的速度。事实上，有连续内存空间，自然也就有非连续的内存空间。如果一个内存段是连续的，那么就意味着从内存段头部开始，需要取用第5个元素就只需要令头指针向右（或者某个方向，取决于你）偏移4个元素，就可以取到这个元素了。典型的拥有连续内存结构的数据结构有传统的数组，以及我们这里介绍的 &lt;code>vector&lt;/code>。而非连续内存结构的数据结构里，非常有代表性的一个就是链表。使用链表上的第5个元素需要先从头节点向后寻找第一个节点，找到之后再跳转到第二个，不断进行这样的跳转直到找到第五个元素。使用链表的好处是链表可以极大程度利用内存空间，因为不受&lt;em>连续的大段内存空间&lt;/em>的条件约束，代价便是寻址速度相比数组或 &lt;code>vector&lt;/code> 会慢很多。&lt;/p>
&lt;p>另一个角度讲，&lt;code>vector&lt;/code> 可能会低效的原因也在于此。由于 &lt;code>vector&lt;/code> 需要保证内存是连续的，当它遇到内存不足时，便需要做下面的事：&lt;/p>
&lt;ol>
&lt;li>在内存中寻找一块新的地址，这个地址有一段连续的足够大的内存来存放老数据以及即将到来的新数据；&lt;/li>
&lt;li>把老数据复制到新的地址下；&lt;/li>
&lt;li>把新数据添加到老数据的后面。&lt;/li>
&lt;/ol>
&lt;p>这个过程最耗时的部分是第三步。设想这样一个情况，操作系统在给程序分配内存时分配地非常零散，且希望最最高效地利用内存，以至于内存空间内部只有长度为 1, 2, 4, 8, 16, 32 这6段长度的内存，它们的地址相隔甚远，且你拥有的一个 &lt;code>vector&lt;/code> 目前只保存了长度为1的数据（也就被系统分配到长度为1的地址下）。现在你打算向里面补充新数据，比如，你要往里面添加31个新数据，但是这个过程中需要做一些特别的判断，以至于编译器不能帮你做优化，直接分配给你32位长度的内存。&lt;/p>
&lt;p>现在，在你向后补充第一个元素时，&lt;code>vector&lt;/code> 会尝试寻找长度大于2的一个内存空间，它找到了第三块内存（长度为4）；你又向后补充了一个元素，此时 &lt;code>vector&lt;/code> 发现内存不够，但是直接扩张大小也可以，此时就不需要寻址，直接声明后面的两位内存被使用即可；你又打算向后补充三位数据。这时 &lt;code>vector&lt;/code> 发现内存又不够了，它寻址到第四块内存（长度为8），然后把第三块内存中的数据一个个复制到第四块内存中，然后再把新的三位数据补充到后面。&lt;/p>
&lt;p>发现问题了吗？&lt;code>vector&lt;/code> 的机制让编译器不太愿意把本就很大的内存空间直接交给 &lt;code>vector&lt;/code>。当你要往 &lt;code>vector&lt;/code> 里填充大量数据时，让它这样自己一点点增长长度的做法会非常耗时。好消息是，我们可以通过 &lt;code>vector::reserve&lt;/code> 提前告诉 &lt;code>vector&lt;/code> 我们需要大概多少的内存，以便编译器一开始就找好一个够大的地方。而且这样的机制也算是强有力地说明了 &lt;code>vector&lt;/code> 具有连续内存结构。&lt;/p>
&lt;h2 id="在看看内存结构">在？看看内存结构
&lt;/h2>&lt;p>下面我们就来尝试用代码打印出 &lt;code>vector&lt;/code> 里元素的内存地址吧。我们向一个 &lt;code>vector&lt;/code> 中填充5个元素，每次填入时检查 &lt;code>vector&lt;/code> 的状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="c1">// We use &amp;#34;push_back&amp;#34; push an element to the back of a vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Added: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;, Size: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;, Capacity: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;, Address of first element: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Check contiguity
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Contiguous memory check:&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size_t&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Address of v[&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;] = &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>得到的结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">Added: 0, Size: 1, Capacity: 1, Address of first element: 0x56041b4592b0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">Added: 1, Size: 2, Capacity: 2, Address of first element: 0x56041b4596e0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">Added: 2, Size: 3, Capacity: 4, Address of first element: 0x56041b4592b0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">Added: 3, Size: 4, Capacity: 4, Address of first element: 0x56041b4592b0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">Added: 4, Size: 5, Capacity: 8, Address of first element: 0x56041b459700
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">Contiguous memory check:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">Address of v[0] = 0x56041b459700
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">Address of v[1] = 0x56041b459704
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">Address of v[2] = 0x56041b459708
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">Address of v[3] = 0x56041b45970c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">Address of v[4] = 0x56041b459710
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，在添加元素时，&lt;code>vector&lt;/code> 的 &lt;code>size&lt;/code> 指示 &lt;code>vector&lt;/code> 有多少的元素，而 &lt;code>capacity&lt;/code> 指示了 &lt;code>vector&lt;/code> 还有多少的空间。当空间不足时，&lt;code>vector&lt;/code> 的空间会扩大一倍来容纳新的元素，同时头元素的位置也会发生变化。而在元素填入结束后，通过检查地址可以发现这些元素在地址上是连续的（一个 &lt;code>int&lt;/code> 的大小是4，注意到使用了16进制所以 &lt;code>8&lt;/code> 后面是 &lt;code>c&lt;/code> 也就是 12，&lt;code>c&lt;/code> 后面就进一位因为达到了16）。&lt;/p>
&lt;p>这是一个很简单的小例子，但是用来说明 &lt;code>vector&lt;/code> 的内存结构应该已经足够。&lt;/p>
&lt;h2 id="做个-benchmark-看看">做个 Benchmark 看看
&lt;/h2>&lt;p>也许一个简单的 Benchmark 可以展示一下 &lt;code>vector&lt;/code> 和传统的数组相比效率如何。下面我们初始化一个 &lt;code>vector&lt;/code> 和一个数组，它们有同样的大小，并且执行累加操作，最后记录累加的用时。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;ctime&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10000000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SIZE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">SIZE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Benchmark vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">clock_t&lt;/span> &lt;span class="n">start_vec&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">sum_vec&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">SIZE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl"> &lt;span class="n">sum_vec&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="n">clock_t&lt;/span> &lt;span class="n">end_vec&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Benchmark array
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">clock_t&lt;/span> &lt;span class="n">start_arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">sum_arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">SIZE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl"> &lt;span class="n">sum_arr&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl"> &lt;span class="n">clock_t&lt;/span> &lt;span class="n">end_arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Vector sum: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">sum_vec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl"> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;, Time: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">end_vec&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start_vec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; ticks&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Array sum: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">sum_arr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl"> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;, Time: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">end_arr&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start_arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; ticks&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">33&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Don&amp;#39;t forget to delete[] the array!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">34&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">35&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">36&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们先不开启优化并尝试运行几次，看看结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&amp;gt; g++ test.cpp -o &lt;span class="nb">test&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">21530&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">16693&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&amp;gt; ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">21059&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">16560&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&amp;gt; ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">20729&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">15812&lt;/span> ticks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们再开启 &lt;code>O3&lt;/code> 优化然后看看结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&amp;gt; g++ test.cpp -o &lt;span class="nb">test&lt;/span> -O3 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">2684&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">2122&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&amp;gt; ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">4091&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">3686&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&amp;gt; ./test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl">Vector sum: 10000000, Time: &lt;span class="m">3205&lt;/span> ticks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">Array sum: 10000000, Time: &lt;span class="m">2813&lt;/span> ticks
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看来不开启优化的时候，两个方法的差距还是比较明显的，而当开启优化之后，两种方法的差距并不大。然而，使用 &lt;code>vector&lt;/code> 最大的优势在于心智负担小，不用担心奇怪的内存问题，而且如果使用 &lt;code>vector::at&lt;/code> 方法还能自动进行边界检查，在遇到越界问题时会抛出异常，避免程序以奇怪的，错误的方式运行。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>希望这篇小短文能帮助你了解 &lt;code>vector&lt;/code> 的特点，或者打消你对 &lt;code>vector&lt;/code> 性能的顾虑。&lt;code>vector&lt;/code> 是用来说明 C++ &lt;strong>Zero-overhead principle&lt;/strong>（零成本抽象原则）的一个很好的例子。&lt;code>vector&lt;/code> 提供了一个动态数组的抽象，它会以最低成本来实现这个东西的特性，避免引入过多额外的性能开销，让调用者可以放心使用，不必担忧性能问题。对零成本抽象感兴趣可以查看 &lt;a class="link" href="https://en.cppreference.com/w/cpp/language/Zero-overhead_principle" target="_blank" rel="noopener"
>CppReference的介绍&lt;/a>，里面介绍了这一原则的具体情况。&lt;/p>
&lt;p>当然，每次使用新的特性，总是会引入一点点的开销。或许你会考虑，辛苦一下自己，让程序能再跑快点。这本身没什么问题，但是要指出的是，警惕提前优化。如果 &lt;code>vector&lt;/code> 并不是制约程序运行效率的关键部分（也就是所谓的&lt;em>性能瓶颈&lt;/em>），那么就先不要管它。当程序遇到了这个瓶颈，且只能通过优化数据结构才能提高性能时，再考虑把 &lt;code>vector&lt;/code> 修改为别的容器或者数据类型，这样做也许会更实际一些。&lt;/p>
&lt;p>当然，如果这个小短文有什么问题，请直接指出来。本人也不是科班出身，写这篇笔记纯粹是记录一下学习过程。欢迎交流讨论。欢迎大佬拷打，动作轻一些就更好了。&lt;/p>
&lt;p>那么最后，一如既往，祝您身心健康。&lt;/p></description></item><item><title>蛇年，Snake Lemma！</title><link>https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/</link><pubDate>Thu, 27 Feb 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/Post%20Shelter-Inaba%20Kumori.png" alt="Featured image of post 蛇年，Snake Lemma！" />&lt;p>&lt;em>看了好多证明蛇引理的视频，我也来试试~ 蛇年到了，重在参与嘛&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://twitter.com/NKNK_NGRMS" target="_blank" rel="noopener"
>ぬくぬくにぎりめし&lt;/a> 太太， 为 &lt;a class="link" href="https://space.bilibili.com/26040194" target="_blank" rel="noopener"
>稲葉曇&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1jS4y1y7Yf/" target="_blank" rel="noopener"
>ポストシェルター&lt;/a> (Post Shelter)的曲绘。支持正版，就只有30秒试听了（）&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=1921984877" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="写在最前">写在最前
&lt;/h2>&lt;p>本命年到啦~！作为一个代数爱好者（自称，其实是名词党），最近在B站看到了很多的关于怎么证明蛇引理（Snake Lemma）的视频，比如&lt;a class="link" href="https://www.bilibili.com/video/BV1FZFNezE6D" target="_blank" rel="noopener"
>这个视频&lt;/a>。以前在自学代数的时候也遇到过这么个引理，但是看到这个部分的时候已经人快晕了（大概就是看完这个之后就抛弃了那本书吧，&lt;em>Algebra: Chapter 0&lt;/em>），所以几乎等于没学过。这次看到这么多关于蛇引理的视频，自然是学习一下，这里也做一个记录吧。在本文中你将看到：&lt;/p>
&lt;ul>
&lt;li>你在说些什么？&lt;/li>
&lt;li>这么简单的前置竟然也要？&lt;/li>
&lt;li>你这里跳步了吧？&lt;/li>
&lt;li>就算我证的不好，我证的很搞笑也不行吗？&lt;/li>
&lt;/ul>
&lt;p>之类的高血压时刻。为了您的身心健康，如果你打算认真了解蛇引理的话，我还是不建议你深究这篇文章。当然，如果你是找乐子的话，我希望这篇文章能带给大家笑容。这篇文章的面向读者应该对最基础的代数有了解，比如集合啊，函数啊之类的，如果会线性代数就更好了，别的东西会中途提到，毕竟是名词党写的文章，当然起点会很低的吧（笑）。话不多说，开始吧。&lt;/p>
$$
\gdef\Ker{\operatorname{Ker}}
\gdef\Coker{\operatorname{Coker}}
\gdef\Img{\operatorname{Im}}
$$&lt;h2 id="简单介绍">简单（？）介绍
&lt;/h2>&lt;p>蛇引理究竟是什么呢？这是一个代数学定理，简单来讲，它做的事情和很多代数学定理一样：从已有的两个东西来创造出新的东西。比如，如果我们有一个集合以及集合上的等价类/等价关系，我们就可以构建出来一个商集；给定一个群以及它的正规子群，我们就可以构建出商群；把两个空间 $\mathbb{R}$ 叉乘起来（笛卡尔积），我们就得到了 $\mathbb{R}^2$。&lt;/p>
&lt;p>那么蛇引理是针对什么样的代数对象呢？这里就要尝试引入我们的第一个概念：正合列 (Exact Sequence)&lt;/p>
&lt;h3 id="正合列但是先别急">正合列，但是先别急
&lt;/h3>&lt;p>正合列，同调代数中的重要对象，是由链复型添以特殊的条件而产生的。链复型又是什么？链复型是一系列的交换群或者模通过同态连接起来，且相邻两个同态的复合为0。&lt;/p>
&lt;p>也许你要说：天哪你在说什么鬼东西，这都是啥啥啥呀。既然我们假定读者只拥有最基础的代数知识，我们就从最基础的开始介绍吧。名词党最喜欢的名词介绍环节，启动！&lt;/p>
&lt;h4 id="群交换群">群，交换群
&lt;/h4>&lt;p>上面说链复型是由交换群或者模带上同态构成的，为了简单，我们就不介绍模 (Module) 了，专注于交换群。&lt;/p>
&lt;details>&lt;summary>但是模是什么？我要看口牙！&lt;/summary>如果有人讲模之类的话，可以认为就是一个差一点的线性空间，它就差在标量不再是数域中的元素了，而是环 (Ring) ，一种乘法可能没有逆元的神奇代数结构，里面的元素。这里指出，环想要变成域（有的地方管域叫体，英文都是 Field）的话只需要让环满足交换律，并且它的每个非 0 元素都有乘法逆元就好了。&lt;/details>
&lt;p>那么交换群，或者从头来讲，群，又是什么呢？有人会讲：群就是对称！有对称，就有群！挺好的，但是对称这种几何元素偏偏要符号化成群元素，这一步我倒是走了蛮久的。我们速通嘛，就说简单一点，尽可能地不丧失严谨性吧。群 (Group)，最为代数学中几乎是最基础的代数结构，和其余的许许多多数不清的代数结构类似，遵循这样的特点：&lt;/p>
&lt;ol>
&lt;li>从集合而来。它的 “底下” 一定是一个集合。这样我们就可以讨论这个代数对象中的元素了。&lt;/li>
&lt;li>它的内部有一个或者多个 “运算”。我们可以想象我们早已熟悉的乘法。既然是运算，我们对这么个东西有这样的要求：
&lt;ol>
&lt;li>首先运算是两个元素同时参与的。相乘的总是（起码）两个数。注意不一定非得是不一样的数哦。&lt;/li>
&lt;li>两个元素经过运算之后应该得到一个元素。两个数相乘之后给出的也是一个数字。&lt;/li>
&lt;li>这点不太明显，但是我们的运算总是应该从这个集合来，到这个集合里去。比如 $1\times 1\neq\mathrm{苹果}$。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>这样就可以有一个（很基础的一些）代数结构啦。而我们的群，也正是这样的一个代数结构。不过它还有这样的特点：&lt;/p>
&lt;ol>
&lt;li>群的运算必须要是可以结合的。这意味着如果 $abc \neq (ab)c \neq a(bc)$，那它就不是群。（天啊真的有这样的神经结构吗）&lt;/li>
&lt;li>群的运算&lt;strong>不需要&lt;/strong>是交换的。其实不交换的东西很常见，例如我们要先穿袜子再穿鞋，这肯定和光脚穿鞋后再套个袜子是不一样的啦。学过线性代数的朋友应该更有体会：矩阵乘法是不交换的。&lt;/li>
&lt;li>群得有单位元。何谓单位元？这不是元素吗？这里的单位元是和运算强相关的，说的就是群里的任何元素和这个单位元做运算之后一定得到的是它们自己。&lt;/li>
&lt;li>群中元素都得有逆元。没错，这里逆元的概念也是和运算相关的。所谓 “逆”，就是要把一个元素 “逆转” 回单位元。可以想象单位元就是某个出发的位置，每个元素都代表着某个让你移动的方式。而某个元素对应的逆元，就像你移动之后让你移动回原点的移动方式。能走出去，也得能走回来。就是这样。&lt;/li>
&lt;/ol>
&lt;p>其实上面的这些内容，经过一些整理的话就可以变成比较严格的群的定义了。然而严格定义谁都能查，这里也就偷个懒啦~ 这里指的指出的是，群上的运算我们一般就叫它乘法。而且在代数的语境下，很多运算我们都叫它乘法！所以在讨论代数结构中的乘法时要注意上下文哦~&lt;/p>
&lt;details>&lt;summary>所以群的对称意义究竟在哪？&lt;/summary>
&lt;p>我们讲，集合中的元素位置其实是无所谓的，比如集合 $\{1,2\}$ 和集合 $\{2,1\}$ 是一模一样的。那么，群的对称的意义，就在于群中的元素有两重含义：集合内的一个小不点，以及代表了如何操作这个集合的一个符号。&lt;/p>
&lt;p>我们提到过，群的运算是需要满足上面一大堆条件的。这些条件指向了这样的一个神奇的结果：两个群中的元素相乘，我们可以有意识地将其中一个元素作为操作方式，将另一个元素看作群中茫茫多（或者很少，也许）元素中的某个元素。而这样的运算结果又是群中的某一个元素。&lt;/p>
&lt;p>然后我们再想象这样一副图景：桌子上有一副扑克牌，每一张都分开放，放的很整齐。现在你尝试把这些扑克牌重新排列，这个排列方式取决于你开始重排前看到的第一张牌。在重新排列时，你肯定需要一张一张地取，取到之后会根据你看到的第一张牌来思考应该把它放在哪里，最后你就把它放在了对应的位置。在重复54遍 “取-看-放” 的过程之后，你会惊奇地发现：天哪，竟然又得到了一副扑克牌（？）&lt;/p>
&lt;p>你可能觉得这个发现很无聊，但是这就是对称：在某种操作下又回到自身了。你也许会说：不！位置变了！但是还记得吗？集合中元素位置是无关紧要的。我们这里其实就是在讲群对自身的作用。那么群可以对别的集合进行作用吗？当然！只要某个作用方式满足群的条件，也就是说如果你先做了一个操作，又做了另一个操作（这样就操作两次了，对应群中的两个元素相乘）这俩操作实际上也是你可取操作的一种（群中元素运算后依旧在群里），以及别的条条框框，那么实际上你就是在对这个集合进行着群作用。&lt;/p>
&lt;p>群中蕴含的对称，不在于群自己，而在于它能操作的对象。笨笨的我花了好久才明白这个道理 QAQ。&lt;/p>
&lt;/details>
&lt;hr>
&lt;p>太棒了！群是什么，已经狠狠地理解了！那么交换群？诶！交换群一定是运算能满足交换律了吧！&lt;/p>
&lt;p>是的，答案就是这么简单，且无聊。交换群 (Commutative Group，又称阿贝尔群 Abelian group，为了纪念伟大的挪威代数学家阿贝尔)，就是能交换 (Commutativity) 的群 (Group)。你也许会对交换群感到失望，但是代数岂是如此无聊之物！？这一切的原因，其实是：我们还没有引入同态 (Homomorphism)。&lt;/p>
&lt;details>&lt;summary>交换群和普通群还是有区别的吧？&lt;/summary>
&lt;p>当给一个普通的群赋予交换性时，它身上所多出来的性质远不止交换性这一条。交换性赋予群的不止表面看起来的两个元素可以交换，更重要的是，给交换群内的结构更加严格的限制。比如后面会提到的，交换群的子群全都是正规子群，因此对于任何一个交换群的子群，都可以用来被模除掉而形成一个子群。&lt;/p>
&lt;p>交换群太特殊了，以至于人们给它划定了一个特别的范畴：阿贝尔范畴（Abelian Category）。事实上，交换群甚至子集就是一个模（也就是我们在介绍蛇引理时一开始所提到的那个代数结构）。然而我们这里不计划过多地介绍交换群有多么特别，而是将目光放在交换群上面所定义的运算。更具体地说，是交换群上面定义的运算的符号，以及相关的记号。&lt;/p>
&lt;p>我们前面提到，群里定义的运算被称为 “乘法”。这是个很有趣的名字：为什么我们叫它乘法？我们熟悉的乘法，比如在 $\mathbb{R}$ 上的乘法，也就是实数乘法，或者在线性代数里我们知道的矩阵乘法，和这里的 “群乘法” 之间有什么样的关系呢？我们指出：实数在作为集合的条件下，赋予我们已经熟悉的乘法后，得到的就是一个群；而线性代数中的矩阵乘法，在将所有的 $n\times{n}$ 方阵看作一个集合时，赋予矩阵乘法后也能形成一个群。&lt;/p>
&lt;p>然而实数乘法和矩阵乘法是有区别的：实数乘法满足交换律，而一般的矩阵乘法并不满足交换律。因此，实数乘法实际上构成了交换群。不过由此我们也可以看到，无论是否满足交换律，我们经常给这样满足若干条件的运算起一个 “乘法” 的名字。这也是群运算一般被称为 “乘法” 的原因。&lt;/p>
&lt;p>但是，不论是实数，还是矩阵，甚至所整数集合、向量等等，它们都有这样的一个运算，我们更加熟悉，且常常称之为 “加法”。这些运算和乘法相比有什么样的特点呢？它们中的一些，在不谈所谓 “交换律” 时，其实和乘法是类似的。然而，在考虑矩阵的加法和乘法时，区别立马就显现了出来：&lt;em>矩阵的加法是满足交换律的，而乘法不满足交换律&lt;/em>。那么我们就这样规定：一般群（或者不满足交换律的群）的运算就称为乘法，而交换群上的运算则称为加法。从记号上来看，我们这里做一个小表格，方便更直接的对比。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">项目&lt;/th>
&lt;th style="text-align: center">一般群&lt;/th>
&lt;th style="text-align: center">交换群&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">运算&lt;/td>
&lt;td style="text-align: center">乘法&lt;/td>
&lt;td style="text-align: center">加法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">记号&lt;/td>
&lt;td style="text-align: center">ab&lt;/td>
&lt;td style="text-align: center">a+b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">左陪集&lt;/td>
&lt;td style="text-align: center">aH&lt;/td>
&lt;td style="text-align: center">a+H&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">单位元&lt;/td>
&lt;td style="text-align: center">1&lt;/td>
&lt;td style="text-align: center">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">交换律&lt;/td>
&lt;td style="text-align: center">不满足&lt;/td>
&lt;td style="text-align: center">满足&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这里要提出的是，上面的区别在不考虑交换性的情况下，仅仅是记号的区别。事实上，如果你愿意，完全也可以使用乘法记号，不过这就需要在文中特别标注出来就是了。&lt;/p>
&lt;p>最后，这里引出这样一个观点：抽象代数，如研究群、环、域、模的代数结构性质的这些内容，在理解这些代数结构的过程中，最好的例子有两个：一是整数极其衍生结构；二是线性空间以及其上面的矩阵。当然，只是私货而已，如果有什么问题还请见谅。&lt;/p>
&lt;/details>
&lt;h4 id="同态同构等价关系">同态，同构，等价关系
&lt;/h4>&lt;p>首先，代数中［Homo-］的词头其实很常见（？）。这是代表着两个东西之间一定有什么相同的地方。而同态，正是指出了两个代数结构之间相同之处的东西。请注意这里用到的是 &lt;em>代数结构&lt;/em> 而非 &lt;em>群&lt;/em> 或者 &lt;em>交换群&lt;/em>。同态广泛地存在于代数学中，到处都是同态。那么同态是什么呢？其实你早就见过了。对于 &lt;em>集合&lt;/em> 这个最基础的代数结构而言，同态就是 &lt;em>函数&lt;/em>，或者说 &lt;em>映射&lt;/em>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。既然函数是对于集合而言特殊的同态，那么对于群而言，特殊的同态是什么呢？很可惜，没有一个特别的名字，或者大家就直接叫群同态了。然而群同态确实是有其特殊之处的。我们稍后再细讲这种特殊点在哪，以及何来的“同”一字。&lt;/p>
&lt;p>回忆我们很熟悉的集合上的函数，它有这样的特点：&lt;/p>
&lt;ol>
&lt;li>函数必须要有定义域，它是一个 &lt;em>集合&lt;/em>，且这个集合里的每个元素都能被函数处理（作用）。不能说有个定义域的元素不能被函数吃掉，那就礼崩乐坏了。函数是不会剩饭的。&lt;/li>
&lt;li>函数必须要有陪域。他也是一个 &lt;em>集合&lt;/em>。请注意这里不是说不是值域，而是陪域。值域是函数能吐出来的东西组成的集合，而陪域则是函数吐出来的东西一定会存在的集合。所以，很自然的，会有一些陪域上的元素不会有任何定义域上的元素去对应。&lt;/li>
&lt;li>定义域中的每个元素 &lt;em>能且只能&lt;/em> 对应陪域上的一个元素，而陪域上的元素可以有0个，1个或者很多个定义域上的元素对应。这就像投篮，球可以投不中，可以一个球一个框，也可以很多球进一个大框里，但是不能一个球同时进两个框。&lt;/li>
&lt;li>判断两个函数是否相等（没错，函数作为数学对象是可以判断是否与另一个相等的）的铁则是：定义域相同，陪域相同，定义域上的每个元素通过两个函数作用后得到的结果总是一样的。也就是说，要检测函数的三个要素都是一样的。表达式也许会骗人，但 &lt;em>函数的定义&lt;/em> 永远是诚实的。&lt;/li>
&lt;/ol>
&lt;p>天啊我怎么又讲了一遍函数是什么？原因是：函数，作为同态的一个例子，自然就包括了同态的许多特点。然而同态还有一个重要的特性，也是被冠以 “同” 字的原因：同态必须保持结构！我们没有在集合中看到这样的特点，是因为集合里什么结构都没有。也许有人说：集合里的元素都是有名字的呀？什么 1 啊 2 啊的，这不就有结构那样的东西了嘛。这里要明确的是：集合里这些看似特殊的元素，它们的特殊性全都源自于我们为了能区分它们所给的，甚至就是为了能数清楚这些元素，不至于把它们搞混。So，集合真的很单纯，它上面的结构都是后面赋予的。当然，你也可以说 “没有结构” 也是一种结构，因为 &lt;em>函数不会把集合变成别的什么不是集合的东西&lt;/em>，保持了 “没有结构” 的特点（结构）。&lt;/p>
&lt;p>哦，好，但是说了一圈，到底怎么保持结构？群同态到底是什么样的？观察上面函数的特点，我们提炼一下：&lt;/p>
&lt;blockquote>
&lt;p>同态要有来有去，且来去都是同一类东西，不能来去之后东西不一样了。这说明 &lt;em>同态不会给对象添加或删去任何结构&lt;/em>。&lt;/p>&lt;/blockquote>
&lt;p>就是说，群同态只能连接两个群。或者，&lt;em>一个群上如果作用了一个群同态，那么它就必须给出一个群&lt;/em>。这点对于其他所有的代数结构都是一样的。&lt;/p>
&lt;p>还是一头雾水？是不是觉得随便哪个集合上的函数都能在集合变身成函数后也跟着变成同态？没关系，就群同态而言，我们其实可以写出群同态需要满足的特点（多亏了运算的存在）。&lt;/p>
&lt;blockquote>
&lt;p>设有两个群 $G$ 和 $H$，它们之间有个从 $G$ 到 $H$ 的群同态 $\varphi$。我们记群 $G$ 的运算为 $\times_G$，记群 $H$ 的运算为 $\times_H$，群 $G$ 中有俩元素 $g_1$ 和 $g_2$。这样一来，由于 $\varphi$ 是群同态，有：&lt;/p>
$$\varphi(g_1 \times_G g_2) = \varphi(g_1) \times_H \varphi(g_2)$$&lt;/blockquote>
&lt;p>而且它有一个很神奇且重要的特点：群同态只能把一个群的单位元映射到另一个群的单位元。这点乍看很神奇甚至不可思议，但是经过简单的证明就可以得到这样的结论了。这也是为了保持群的结构而对群同态做出的一个很强的限制。这也说明了，代数结构越是复杂，同态的限制就会越大。&lt;/p>
&lt;p>最后我们讲一种特殊的同态（或者态射，我们这里不区分两者，后面在范畴部分会做出说明），它需要有一个态射作为基础。我们设有这样的一个态射 $f:\\,A\to B$，且在 $A$ 中有一个保持原有 $A$ 结构的子结构 $A'$，在集合层次上则为包含关系。此时我们就可以定义所谓的 &lt;em>限制&lt;/em> （Restrict），就是把定义域从 $A$ 换到了其子结构 $A'$ 上而已。它的记号为：$f|:\\, A'\to B$。&lt;/p>
&lt;hr>
&lt;p>我们接下来介绍同构 (Isomorphism)。它在集合函数中的对应就是所谓的一一对应函数了。回忆所谓的单射和满射，单射说一个萝卜一个坑，满射说值域就是陪域。而同时满足这两个条件的话，这个函数就是一一对应的函数啦。我们立刻使用一些新词来讲这些事情，因为函数（映射）是集合间的同态嘛。&lt;/p>
&lt;p>同态中有单态 (Monomorphism)，也有满态 (Epimorphism)。而同时满足这两点的，即为所谓的同构了。它们的要求和集合函数是一模一样的。然而还有别的定义方法，使用态射的逆（啊没错它们都是态射但是这就留到范畴论再说吧）即可定义同态的单或满。回忆之前学过的逆函数这一存在，一个函数的逆函数再作用到函数的话就会变成恒同映射（把一个元素映射到它自己）。这是一种双边逆，更常见的情况则是一个态射只有左逆或者只有右逆。&lt;em>我们称有左逆的态射为单态，有右逆的态射为满态，有双边逆的则为同构&lt;/em>。这个我们不证，有兴趣可以挑一些例子看看。请把重点放在 “能不能找到原来的元素” 以及 “如果能找到原来的元素，那么一定会如何”，并注意函数的复合是从右到左的。&lt;/p>
&lt;p>这里顺带提出原像（Inverse image）的概念。原像是和某一个陪域中的元素，以及一个态射相关的。它本身是一个集合，记录了所经过该态射后能得到该陪域中元素的所有定义域中的元素。它的记号以及形式化的表达是：若存在一态射 $f\vcentcolon\space A\to B$ 以及 $b\in B$，则 $b$ 在 $f$ 下的原像记为 $f^{-1}$，定义为：&lt;/p>
$$
f^{-1}\vcentcolon=\left\{\space a \space \vert\space\forall a \in A, f(a) = b\space\right\}.
$$&lt;p>那么这样一来，单态则是所有陪域上元素的原像只能是空的或者只能有一个元素的态射，而满态则是所有陪域上的元素都有非空原像的态射。利用这个概念，同构还可以定义为所有陪域上元素的原像有且只有唯一一个元素的态射。&lt;/p>
&lt;p>同构从字面意思来理解，是 “保持结构” 的映射。可是之前还说同态是保持结构的映射，这两个区别在哪里？事实上，同构比同态要求高多了。同构要求的是 “构造完全相同”，而同态则只要求 “是同一类东西，不会多结构，也不会丢结构”，却可以修改这个结构。比如，同态可以让一个大群变成一个小群，搞得里面的每个元素以前有更丰富的运算结果，结果到了小群里好多元素被捏在一起了，这些丰富的结果也就没了。而同构会很严格地将一个群变成另一个大小一模一样的群，它们结构的丰富程度或者精细程度是一模一样的。在只关心群这个整体以及它怎么与其他群发生转变，完全不关心群内部元素有什么特别之处时，我们可以说，&lt;em>同构的两个群，它们在同构意义下可以被视作是相同的&lt;/em>。顺带一提，集合的同构就是映射到元素个数相同（集合的势相等）的另一个集合。这也是个大坑，感兴趣可以搜 Schröder–Bernstein 定理或者伯恩斯坦定理。&lt;/p>
&lt;p>对于群而言，群的同态会把群的一个或几个元素捏在一起形成新群的一个元素。同态是创造新群的一个重要方式。但是假如我们考虑 &lt;em>把几个元素捏在一起形成一个新的元素&lt;/em> 实际上意味着 &lt;em>对原来的群中的元素进行分类&lt;/em>，那我们就会形成很有趣的结构，商群 (Quotient Group)。我们不会深入这部分，但是这个思想是极其重要的，因此我们需要介绍另一个概念：等价关系与等价类。&lt;/p>
&lt;hr>
&lt;p>小学数学，甚至幼儿园数学，经常会遇到这样的题目：把一堆苹果分成若干份，每份有几个苹果；把苹果平均分成若干份，最后剩下几个苹果。这样的题目是为了让孩子熟悉除法，而我们这里则要指出，这就是除法，或者所谓的 “商” 所代表的含义。而我们在分苹果时所做的事情，就是在对苹果分类。&lt;/p>
&lt;p>我们要如何进行分类呢？特别是对一堆苹果而言，分成堆时我们做了什么？也许我们有某个标准，也许就是简单的 “我乐意”，但分成堆的过程中每个苹果最终都有属于自己的一堆。假如我们要分成三堆，那么我们完全有理由将三堆起不同的名字，比如：科比，牢大，曼巴。这样一来，每个苹果就都有了一个属性，一个标签。而苹果之间有什么关系吗？有的。我们观察同一堆的苹果，如牢大这堆，会发现这样的（显而易见）的特点：&lt;/p>
&lt;ol>
&lt;li>一个属于牢大的苹果，那么他就属于牢大（？）&lt;/li>
&lt;li>如果一个苹果在牢大里，另一个苹果也在牢大里，那么它们俩就都在牢大里，不论进入牢大这堆的顺序&lt;/li>
&lt;li>如果苹果A和苹果B都在牢大里，苹果B和苹果C也在牢大里，那么苹果A和苹果C就一定在牢大这里。&lt;/li>
&lt;/ol>
&lt;p>不论分类手法如何，不管分类标准怎么样，上面这三条总是成立的。而在分好之后，对任何人都可以只宣称这堆苹果属于哪一堆，不用管它具体怎么样了。有人问这个苹果是哪个，都可以回答这个苹果是从科比或者牢大或者曼巴这堆里取出来的。&lt;/p>
&lt;p>还是一头雾水？上面的例子是想说明这样的一件事：只要你选了，那就会形成一个标准，这个标准内的每个成员都会接受这样的束缚，而这个约束是有 &lt;em>自反性&lt;/em>，&lt;em>反身性&lt;/em> 和 &lt;em>传递性&lt;/em>的。这些性质就刻画了一个 “关系”，称为 &lt;em>等价关系&lt;/em>。我们刚刚用分好的类来说明这类关系一定存在，而反过来讲，根据这样的关系，也一定能进行这样的分类。最后分出来的 “每一堆”，我们就称为等价类。&lt;/p>
&lt;p>分类是代数学中另一个极为重要的话题。有一些出色，重要且惊艳的研究正是建立在这样的分类问题上的，比如传说中的 &lt;em>有限单群分类&lt;/em>，洋洋洒洒几千字的论文将整个单群分类问题整的明明白白。分类如此重要的原因还在于帮助我们创造新的代数结构，也就是所谓的 &lt;em>商&lt;/em>。比如使用同态对群进行划分则会涉及著名的 &lt;em>群同构基本定理&lt;/em>，描述了用同态下的等价关系创造出的商群有什么样的信息。&lt;/p>
&lt;p>我们这里先不深入介绍商群，因为它将涉及到子群 (Subgroup)，陪集 (Coset)，正规子群 (Normal subgroup) 等概念，太啰唆了。这里只指出商群的记号为 $G/H$，其中 $G$ 和 $H$ 都是群，且 $H$ 是 $G$ 的正规子群。这个商群的元素是这样的：每个元素都是一个集合，这个集合内是群 $G$ 中的元素，并且这些群 $G$ 中的元素都相互等价，而这个等价关系则由群 $H$ 这样确定：元素 $a$ 和 $b$ 等价由 $a^{-1}b \in H$ 决定。换句话说，我们根据群 $H$ 制定了元素的分类标准，把分好类后的每个 “元素堆” 作为商群中的每个元素。能分多少堆，商群就有多少个元素。&lt;/p>
&lt;p>要注意的是由于等价关系，商群中每个元素（也就是 $G$ 中元素的集合）里都可以选出唯一的一个 $G$ 中元素来代表。那么既然如此，我们就使用在代表元的头顶加个尖尖的东西来代表这个集合了。比如有一个等价类 $A$ 中有一个元素 $a$，此时我们就可以用这个元素 $a$ 来代表这个等价类 $A$：$\hat{a} = A$。这个记号还是比较重要的，所以这里提前介绍一下。&lt;/p>
&lt;p>太棒啦！感觉智慧满大脑了~ 但是这么多前置了，和蛇引理有关系吗？还有多少前置需要呢？答案令人振奋呀：还有一节就好了！我们已经明白了同态是什么样的，交换群又是啥，商群里的元素怎么确定，有什么样的特点。我们只需要再看一看最后两个和同态有千丝万缕联系，作为 “群同构基本定理” 中的 C 位的两个特殊的代数对象，核 (Kernel) 与像 (Image)，就可以开始一窥蛇引理的神秘了~。&lt;/p>
&lt;h4 id="核与像">核与像
&lt;/h4>&lt;p>核的概念其实很简单，它高度依赖于同态，本身是一个特殊的集合（我们先看它单纯的集合结构）。它是同态的定义域上所有能被对应到陪域的 &lt;em>零元素&lt;/em> 的元素，记号为 $\Ker$。假设有某个同态 $\phi$，那么在这个同态下的核就记为 $\Ker\phi$。这里的零元素应该是代数结构中普遍存在的单位元，而称为零元素的主要原因是因为对我们即将研究的许多代数结构而言，它们上面的结构实际上是交换的。交换的运算我们会叫它们 &lt;em>加法&lt;/em>。而我们熟悉的加法的单位元就是 $0$。&lt;/p>
&lt;p>我们上面只说了核底下依赖的集合是怎样选取的，然而由于同态的性质，核上经常都会有额外的代数结构。这一点很容易确定：对群而言，单位元自己本身就是一个平凡群，其上的唯一运算就是单位元和单位元进行运算之后得到单位元自己。那么既然单位元是一个群，由同态的要求，我们马上就可以得知，群同态的核很自然地就拥有群结构。不但如此，我们在此不加说明地断言：群同态的核总是群的定义域的一个正规子群！而有了正规子群，我们马上就可以讨论定义域的群商去这个同态的核所得到的商群了。事实上，群同构基本定理中就和同态的核关系非常密切，且经常使用核来构造商群。&lt;/p>
&lt;p>对于核而言，我们还想提到这三点：首先核一定是依赖于某个同态的，没有同态是没有办法讨论核的。从它的记号就可以看出，我们选择使用 $\Ker$ 记录同态的符号而非其定义域，然而也请切记核作为集合而言一定是定义域的子集。&lt;/p>
&lt;p>其次想要提到的是核在 &lt;em>同调代数&lt;/em> （也许也不是？）中的意义：核衡量了同态的性质，告诉了我们一个同态距离单态究竟有多远。这是由于这样的定理：&lt;em>核中的元素只有一个（也就是单位元）当且仅当同态是单态&lt;/em>。那么如果核越大，同态距离单态就越远了；核越小，同态就越像单态。&lt;/p>
&lt;p>最后一点也许会复杂一些，我们想提到的是：群同态的核由于一定是正规子群，而正规子群又一定能够被商掉。考虑我们上面提过的构造商结构的过程：被商的集合/结构是作为一个选择方式出现，而这个选择方式就是这个结构中的所有元素都被视为同一个元素。我们进行这样的猜测：这样用核来构造的商群中的元素，每个元素都是一个集合，而这些集合与核是相似的：它们都有同样的大小。幸运的是这样的猜测是成立的。最后也不卖关子了：商群中的元素就是正规子群的陪集，而每个陪集的大小都是相等的。所谓的陪集就是把群里面的子群用某个元素乘一下（移动一下）。这里说 “集” 有两个层面，一是我们不计划赋予它别的结构，他们就作为集合存在于商群；二是我们没法赋予群结构，除了最平凡的那个正规子群。更一般的陪集是没有办法满足单位元要求以及逆元要求的。&lt;/p>
&lt;p>核真的很重要，所以我们聊了许多。不过这主要是由于核与商群之间重要的联系。有了这样的铺垫，我们理解像将会更迅速：像也是一个子群，但不是更特殊的正规子群。&lt;/p>
&lt;hr>
&lt;p>像我们早就熟悉了，就集合层面而言，就是值域 “更代数”的一个名字。而同样由于同态的存在，像也一定是一个群。但是不同于核，像并不总是正规子群。这真是一个悲伤的故事，我们不能再愉快地构造商群了。也许你之前幻想着，既然核可以衡量同态与单态的距离，是不是像也可以衡量同态与满态的距离呢？因为很显然可以看到，像越大越可能是满态，像与陪域相同那就是满态了。然而很可惜，我们不用这种方式。&lt;/p>
&lt;p>但是我们有三个好消息：第一条是，虽然像不是个正规子群，但是我们依旧可以用像构造商结构！第二条则是，虽然像不能衡量同态的信息，但是它构造的商结构可以！我们还给它一个特别的名字：余核 (Cokernel)。第三条则是，我们其实要研究的是交换群，而对交换群而言，所有的子群都是正规子群的！这样一来，前面讲的商结构也就可以是商群啦。&lt;/p>
&lt;details>&lt;summary>子群，商群，陪集，商结构，到底是怎么回事？&lt;/summary>
&lt;p>在讲商群时，终究还是无法避免陪集的概念。陪集和商群之间到底是什么样的关系？陪集之间又有什么样的联系？陪集到底是什么样子的东西？&lt;em>商&lt;/em> 究竟是什么？我们讲了这么久的子群，正规子群，它们到底都是啥？这里我们斗胆写一写吧。&lt;/p>
&lt;p>先看看子群吧，其实子群的概念很简单：一个群的子群，实际上就是子集加上原群的运算。这样一来，子群的单位元一定就是原群的单位元，而子群的运算就是原群的运算了。这个还是相对比较简单的一个概念，麻烦的是所谓的正规子群。而为了讨论正规子群，必须要讨论所谓的陪集。我们把陪集往后放一放，先讲商群中的元素们：陪集。&lt;/p>
&lt;p>我们已经提到，商群就是对群按照其正规子群的需求进行分类从而得到的一个更小的群。这个更小的群里面是一个个的陪集，我们讲陪集中的元素都是相互等价的，因此，这个更小的群里的元素虽然都是集合，但是完全可以从每个集合中取一个元素来代表这个集合（由于等价关系），这个元素就被称为代表元。所以你可能会见到商群中的元素是用一个个原群中的元素带上标记构成的。但是还请记住，商群中的元素始终都是集合，也就是陪集。&lt;/p>
&lt;p>我们再谈谈陪集。陪集是这样一个集合：它必须依赖一个群里的元素，以及这个群的一个子群。我们记较大的群为 $G$，它的子群为 $H$。那么我们取 $G$ 中的一个元素 $g$ 之后，再和子群 $H$结合一下，就得到了所谓的陪集了。具体是这样的：&lt;/p>
&lt;ol>
&lt;li>还是先提醒：$H$ 是住在 $G$ 里面的，它们拥有一模一样的运算，所以 $G$ 中的元素是完全可以与 $H$ 中的元素运算的。&lt;/li>
&lt;li>我们从群 $G$ 中取出一个元素 $g$。这个元素是任意的，只要在 $G$ 里就好。然后还要把 $H$ 中的元素一个一个地取出来，准备进行运算。我们要取出所有 $H$ 中的元素，不遗漏不重复。&lt;/li>
&lt;li>用 $g$ 和 $H$ 中的元素依次进行运算。在做运算时，我们先把 $g$ 放在 $H$ 中元素的左边。最后得到的结果放在一个篮子里（或者框里，也可以）。&lt;/li>
&lt;li>最后检查这个框子，我们给它贴上标签：$gH$。这个框就是我们想要的陪集，准确地说是 $H$ 在 $G$ 中元素 $g$ 作用下的 &lt;em>左&lt;/em> 陪集。&lt;/li>
&lt;/ol>
&lt;p>自此，我们便成功得到了一个左陪集。如果在进行运算时将 $g$ 放在 $H$ 的右边，则称之为右陪集，记号也变为 $Hg$。注意到陪集中的元素一定是在 $G$ 中的元素，我们自然好奇：陪集内元素有什么样的特点呢？我们回顾上面的内容：陪集内元素相互等价，等价关系为 $a^{-1}b \in H$。我们来看看是怎么回事。我们更多地关注左陪集，右陪集是类似的思路。&lt;/p>
&lt;blockquote>
&lt;p>证明：$a^{-1}b \in H$ 当且仅当 a 与 b 等价，亦即 $aH = bH$。&lt;/p>
&lt;p>首先，$a$ 与 $b$ 都一定属于各自的陪集，因为 $H$ 是一个群，群里有单位元，则陪集 $aH$ 中肯定有 $a$，$bH$ 中也肯定有 $b$。&lt;/p>
&lt;p>既然 $a^{-1}b \in H$，那肯定就有一个元素 $h$ 就是 $a^{-1}b$。由于乘法逆元的性质，我们给两边左乘 $a$，就有了 $b = ah$。回忆 $H$ 在 $a$ 的左陪集的定义，这就说明了：$b$ 也是 $aH$ 中的元素。&lt;/p>
&lt;p>此时我们想到，既然 $H$ 是一个群，$h$ 在 $H$ 里了，那 $h^{-1}$ 也肯定在里面。我们就给 $b=ah$ 的右边同时乘以 $h^{-1}$，就有得到了：$a=bh^{-1}$。这同时也说明了 $a$ 也是 $bH$ 中的元素。这样一来，我们就证明了 $aH = bH$，因为我们的 $a$, $b$ 是任意选择的 $G$ 中元素，这样的任意性保证了不会选取特殊的点。&lt;/p>
&lt;p>其次，当 $aH = bH$ 时，有这样的情况：$a$ 与 $b$ 相等，则结论自然；若是 $a$ 与 $b$ 不相等，这时由于群乘法的封闭性，一定要有一个 $h$ 满足这样的关系：$ah = b$。现在我们视线移向群 $G$ 后，便可以同时左乘 $a^{-1}$，这时就得到了我们想要的结论。至此，我们证明了这样的选择方式确实是构成了一个等价关系。&lt;/p>&lt;/blockquote>
&lt;p>最后我们关注陪集间的关系：左陪集是不一定等于右陪集的。这点如果能恒成立的话，那么这个群 $H$ 就一定是一个正规子群。另外，群 $H$ 的所有左陪集都有同样的大小。这一点的理由是：左乘群 $g$ 中的元素这个动作总是可逆的，再左乘回 $g^{-1}$ 就可以了。这样一来，左乘 $g$ 就实际形成了一个集合间的双射，也就是所谓的同构。它保证了元素个数相同。也正因如此，用左乘 $a$ 定义的 $H \to aH$ 就保证了 $H$ 与 $aH$ 的元素个数相同了。由于 $g$ 是任意选取的，所以任意的左陪集都有相同个数的元素了。这个结论对右陪集而言也是显而易见的。&lt;/p>
&lt;p>另外我们提一下记号的问题。对于使用乘法记号的群而言，由于我们的子群本身就是一个群，所以一定有一个单位元。而根据左陪集的形态，我们就知道了：每个左陪集中一定有一个元素，这个元素就是子群 $H$ 的单位元乘上我们左陪集所左乘的元素。简单来说，如果有一个左陪集 $gH$，那么这个左陪集里面就一定有一个元素 $g 1_H$。而既然左陪集中每个元素之间都是等价的，我们很自然地就可以使用这个元素来代表这个左陪集。至于记号，我们上面已经介绍了：$\hat{g}$ 就可以代表 $gH$。诶？那假如我用单位元去左乘以这个子群，得到的就是？没错，就是子群本身形成的陪集。而这个特殊的陪集在我们下面定义的商群乘法下自然就是我们需要的单位元了。&lt;/p>
&lt;p>我们定义正规子群为左陪集等于右陪集的子群。在这个定义下，很明显就可以看出，满足交换律的交换群里没有不正规的子群了，因为很轻易地就得到了左陪集等于右陪集，只需要把交换律下放到陪集内元素的计算过程中即可得到。那么对于交换群/阿贝尔群而言，陪集的记号是什么样的呢？我们很轻易就可以类比出来：既然乘法记号的群是用一个元素左乘子群得到左陪集，那么加法记号的群就用一个元素加上一个子群得到这个子群的陪集即可。同样，我们可以使用这个加上去的元素来代表这个陪集，方法也是在上面戴个小帽子。&lt;/p>
&lt;p>有了正规子群，我们就可以愉快地进行商群的构造了。然而，为什么必须是正规子群呢？不能商去一般的子群吗？答案藏在商群运算的合理性中&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>为了尝试从普通的子群构造商群，我们取子群的左陪集们然后就可以形成一个集合了。这个集合内的每个元素都是子群的左陪集。现在我们希望给这个集合上面添加运算。由于左陪集的元素是形如 $gH$ 这样的，所以我们自然希望 $g_1H \cdot g_2H = (g_1g_2)H$，也就是可以直接借用我们在群 $G$ 或 $H$ 中已经有的乘法了。这样定义的乘法满足了群运算的所有性质。然而，定义这个乘法不能靠我们一厢情愿，我们得检查定义的是否合理，即设 $a, a' ,b$ 是满足了 $aH = a' H$ 的任意的 $G$ 中的元素，我们要有 $(aH)(bH) = (ab)H = (a'b)H = (a'H)(bH)$。&lt;/p>
&lt;p>根据陪集定义，我们取任意的 $h_1$, $h_2$ 以及由它们决定的某个 $h_3$，则有 $ah_1bh_2 = a'bh_3$。由于 $aH=a'H$，根据之前的论述，我们指导一定有某个 $h_4$ 满足 $a = a'h_4$。我们带入前面式子，有 $a'h_4h_1bh_2 = a'bh_3$。根据群乘法可逆的条件，有 $h_4h_1bh_2 = bh_3$，我们再把 $h_2$ 的逆乘到等式右边，根据 $H$ 中乘法封闭性，就有：$h_5b=bh_6$。由于我们的 $h_1$，$h_2$ 是任意的，$a$，$b$ 也是任意的，所以 $h_3$ 和 $h_4$ 也不受额外条件的束缚，进而 $h_5$ 与 $h_6$。再回忆我们的左陪集和右陪集的定义，因此我们可以认为：为了满足我们的乘法条件，则必须要有 $Hb = bH$，这正说明了 $H$ 必须是正规的。至此，你应该已经发现：为满足运算的合理性，子群 $H$ 必须是正规子群。&lt;/p>
&lt;p>我们也可以这样理解。取 $G$ 中的任意两个元素 $g_1$与 $g_2$，再取 $H$ 中任意的两个元素 $h_1$ 与 $h_2$，我们要保证 $g_1h_1g_2h_2 = g_1g_2h_3$，其中 $h_3$ 可以是某个由计算过程得到的一个 $H$ 中的元素。要想把 $g_2$ 往左挪过去和 $g_1$ 凑成一对儿的形式，我们必须要让 $g_2$ 和 $h_1$ 存在某种形式的 “交换律”，这样的交换律必须保证 $g_2$ 还是 $g_2$，$h_1$ 则必须还是 $H$ 中的元素。但是，很可惜，这样的 “交换律” 只能存在于真的交换群，或者最低限度的办法：让左陪集等于右陪集，也就是正规子群中。否则这两点无法保证。&lt;/p>
&lt;p>上面这个说明，也是为了指出证明定义合理的重要性。这一点在代数中是十分重要的。而在讨论完陪集和正规子群的重要性后，我们最后要讨论的是：&lt;em>商&lt;/em> 到底是什么。&lt;/p>
&lt;p>我们其实已经指出过，商就是所谓的分类。小学学到的 “分堆问题” 就已经是对 &lt;em>商&lt;/em> 这个字非常好的诠释了。至于为什么用了 “商” 这个字…… 首先，我不知道；其次，也许可以问商鞅？（什么地狱笑话）&lt;/p>
&lt;p>商结构远不止存在于群或者集合中。商结构几乎存在于任何代数对象里。我们可以对拓扑空间做商结构，就像是把纸/空间缝起来/黏起来一样，这样我们就可以得到各种有趣的拓扑空间，比如甜甜圈（环面）、克莱因瓶、莫比乌斯环带等；我们可以把整数轴折叠起来，这样可以得到一个有限群（还很有可能是循环群）；我们还可以把 $\mathbb{R}$ 上多项式空间（就是所有以实数作系数的多项式组成的线性空间）商去多项式 $x^2+1$，这样得到的就是我们熟悉的复空间（复述域）。这里我们提出一种理解商空间的方法：把空间的某些点/线/面或者什么东西黏起来。这个 “黏起来” 的动作，实际上就是把某些点看作同一个点，而这样就等于定义了一个等价关系：黏起来后到同一个点的原空间内的点就在同一个等价类里面。&lt;/p>
&lt;p>此时你可以看到，如果你有一种分类方法，并且你可以用什么办法把代数对象里的元素放到不同的几堆儿里，那你就已经可以生成一个商结构了。它最最最最最起码也是一个商集，而要是你分类方法足够好，你得到的商结构就会更好。我们最后提一下商结构的记号，一般有两类表示方法：一是商去一个等价关系，二是商去用这个等价关系生成的等价类。这两种记号一般都是代表着同一个含义的。利用这个等价关系对原代数结构进行划分会得到若干等价类，其中的一个就是商去等价类记号中的那个等价类。&lt;/p>
&lt;p>So，这就是对这么几个代数学结构的解释了。希望你不要因为这些文字而感到眩晕的同时，得到一些对这些代数结构直观的解释。我们回到主线吧。&lt;/p>
&lt;/details>
&lt;h3 id="正合列以及一点点点点范畴论">正合列，以及一点点点点范畴论
&lt;/h3>&lt;p>现在我们已经清楚了什么是交换群，什么是同态，什么是核，像，商群以及余核。是时候看看我们想要研究的结构了：正合列，以及对应的图。下面就是我们要研究的对象，也是一个图的例子：两个整合列所组成的图。&lt;/p>
&lt;figure>
&lt;img src="image/Commute_Diag.svg" style="width:60%">
&lt;figcaption>两个整合列，通过整合列间的同态链接&lt;/figcaption>
&lt;/figure>
你可以在图中看到两个虚箭头，这两个虚箭头我们先把它们看成实线的，也就是实际存在的。后面证明蛇引理的时候这两个箭头是可以不存在的（当然也就没有连接着的0了）。
&lt;h4 id="链复型">链复型
&lt;/h4>&lt;p>我们先来说说正合列（Exact Sequence）。上图中的正合列有两个，分别是 $0\to A \to B\to C\to 0$ 以及 $0\to A' \to B'\to C'\to 0$。它们中的 $0$, $A$ 等我们称之为 &lt;em>点&lt;/em>，实际上是一个个交换群（一般是模，我们这里取交换群即可），而每个箭头都代表着一个同态。这些同态有着特殊的要求，如果这些同态只是一般的同态，那它们就什么都不是。为了使之成为整个列，我们需要先得到所谓的链复型（Chain Complex，上下文明确时可能直接叫复型 Complex）。&lt;/p>
&lt;p>链复型要求使用同态将一系列的数学对象连接起来，通常这些数学对象以及对应同态还会有一定的顺序，且同态之间的复合还要满足特殊的要求。具体而言，链复型要求这样的序列：&lt;/p>
$$\cdots\xrightarrow{d_{i+2}} M_{i+1}\xrightarrow{d_{i+1}} M_i \xrightarrow{d_i} M_{i-1} \xrightarrow{d_{i-1}} \cdots$$&lt;p>满足条件：$d_{i+1}\circ d_{i} = 0$ 对于所有的 $i$ 都成立。这样的链复型可以被记作 $(M_\bullet,d_\bullet)$。这样的定义蕴含了下面的信息：&lt;/p>
&lt;ol>
&lt;li>交换群的序号从高到低，同态序号也从高到低&lt;/li>
&lt;li>对于所有的同态而言，左侧的同态复合上右侧同态得到的是零同态，也就是把所有的元素映射到单位元上（对于交换群，单位元就是0）&lt;/li>
&lt;li>由上面一条，如果左侧同态复合右侧同态得到了恒通映射，就说明左侧的同态必须把元素映射到右侧同态的核里面。若不然，则无法达成两次复合后为零同态。&lt;/li>
&lt;/ol>
&lt;p>链复型的结构要求每个点都是同一种结构（交换群），且某个点里的任何一个元素沿着链复型移动两次后一定会映射到单位元（后面称零元）上。这样的代数结构是为了方便我们讨论所谓的 &lt;em>同调&lt;/em>，也正因如此，链复型是同调代数中最基础也最重要的代数结构之一。&lt;/p>
&lt;h4 id="同调群正合正合列">同调群，正合，正合列
&lt;/h4>&lt;p>上面提到，正合列是在链复型商加条件得到的，而这个所谓的条件就是 &lt;em>正合&lt;/em> 条件。而为了讨论正合，我们还要引入同调群的概念。有了同调群，正合就非常好判断了。&lt;/p>
&lt;p>我们还是用上面的链复型来举例，所谓的同调群是指这样的商结构：&lt;/p>
$$H_n(M_\bullet) \vcentcolon= \Ker d_n/\Img d_{n+1},$$&lt;p>即一个同态的核与上一个同态的像之间的商群。当链复型的某个点处（即某一个 $n$）的同调群是平凡群（即只有一个元素的群，记作 $0$）时，我们称这个点上是 &lt;em>正合的&lt;/em>。而如果每个点都是正合的，我们就叫这个链复型为正合列。表达正合关系也可以不借助同调群，因为同调群等于平凡群就相当于说&lt;/p>
$$\Ker d_n = \Img{d_{n+1}},$$&lt;p>从这个角度来看也许更好理解正合是什么样的关系。仅从集合的角度来讲，链复型的要求就是在说 $\Img d_{n+1}$ 必须在 $\Ker d_n$ 的里面，它们之间可能有缝隙：$\Img d_{n+1} \subseteq \Ker d_n $；而正合则表示，这两个集合之间是没有缝隙的。这也许也是&lt;strong>正&lt;/strong>合这个字的来源吧。&lt;/p>
&lt;p>最后我们指出，我们上面的那个图片里所给出的两个正合列更为特殊，因为很短，所以叫它 &lt;em>短正合列&lt;/em>。不难看到，由 $0$ 出发的态射是单态，到 $0$ 结束的态射则是满的。而又根据正合的条件，可以得到 $f$ 必须是单态（不然 $\Ker f \neq 0$），$g$ 则必须是满态（否则 $\Img g \neq 0$。&lt;/p>
&lt;h4 id="图与交换图">图与交换图
&lt;/h4>&lt;p>学代数的时候会遇到许许多多用箭头代表的态射，而我们也常常需要将态射复合起来形成新的态射。有时我们又会发现，一个态射可以通过两种甚至多种不同的态射复合方式得到。单靠语言经常会感到乏力，自然而然地，我们想到用图（Diagram）来绘制出这样的想法，把一些态射按照对应的数学对象连接起来。上面链复型或者正合列的表示实际上已经是一副图了，但是这个图还是比较简单的。而当我们发现一个态射可以通过不同的态射复合方式得到时，我们就可以把它们画出来，这样的图我们称是交换的，这种图我们叫做交换图（Commutative Diagram）。&lt;/p>
&lt;p>以上面的用两个短正合列组成的那个图举例，如果有 $\beta\circ f = f'\circ\alpha$ 以及 $\gamma\circ g = g'\circ\beta$，那么它就是一个交换图。我们后面把态射复合时中间的圆圈 $\circ$ 省略掉。&lt;/p>
&lt;h4 id="一点点的范畴论">一点点的范畴论
&lt;/h4>&lt;p>我们最后简单地提一嘴范畴论吧。范畴论是从拓扑那里来的，是根据不同的几何结构间精巧的关系而诞生的描述这种关系的语言，但是后来逐渐被大家发现，好像很多数学结构之间也是可以构建出类似关系的。自此，便有数学家开始建立范畴论，用以正式地，形式化地描述不同数学结构它们内部的或之间的关系。&lt;/p>
&lt;p>我们举一些简单的例子，来看看什么是一个 &lt;em>范畴&lt;/em>（Category）。一个很简单的例子就是 &lt;em>所有&lt;/em> 的集合以及集合之间的 &lt;em>所有&lt;/em> 函数们所构成的范畴 $\mathsf{Set}$ 了（具体某个范畴的记号一般使用无衬线体，根据情况省略部分字母），另一个例子则是所有群以及所有的群之间的同态所构成的范畴 $\mathsf{Grp}$。可以看到很多都是 “所有的数学对象以及它们之间所有的同态构成的范畴” 这样的形式。这样的范畴还是比较基础且常见的，且根据这样的形式，我们可以很自然地总结出别的一些范畴，比如 $\mathbb{R}$ 上的所有线性空间以及所有的线性映射构成的范畴 $\mathsf{Vect_\mathbb{R}}$，所有的环以及其同态构成的映射构成的范畴 $\mathsf{Rng}$，等等等等&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>范畴之间是可以相互联系起来的，这种联系我们也可以像箭头一样写出来，称为函子（Functor）。而函子之间也可以做出联系，称为所谓自然变换（Nature Transformation）。不过好消息是，我们不需要关注这些内容，而只需要关注某一个具体范畴（具体来讲，就是阿贝尔群范畴 $\mathsf{Ab}$）的内部即可。&lt;/p>
&lt;p>范畴的作用除了给出不同类型的数学对象之间有什么样的联系之外，也给我们提供了一个讨论问题的舞台。我们可以直接讲我们在某个范畴中研究什么样的问题，此时范畴本身就给出了我们要研究内容的重要信息。另外，范畴论给了我们一些用以描述数学对象关系的语言，它们通常可以一针见血地指出数学对象间是什么样的关系，当然也因为过于抽象且过于具有总结性而被戏称为 “抽象废话”。&lt;/p>
&lt;p>最后，借助范畴论中的一些内容，比如交换图，我们可以方便地描述数学对象之间的关系。&lt;/p>
&lt;details>&lt;summary>所以什么是范畴呢？&lt;/summary>
我们这里引入范畴的原因其实非常地单纯：希望能引入所谓的交换图这一概念。虽然它本身的引入其实用不太上范畴，但是也许是出于我的私心吧，感觉这里引入范畴也能更好地规范我们研究问题的范围。
&lt;p>那么什么是范畴呢？范畴其实就是一系列对象以及它们之间态射所构成的集合体。我们这里引用著名代数学教材，李文威老师的《代数学方法》中对于范畴的定义。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>范畴的定义&lt;/strong>：&lt;/p>
&lt;p>一个范畴 $\mathcal{C}$ 是指以下的资料：&lt;/p>
&lt;ol>
&lt;li>一个集合 $\mathrm{Ob}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong>对象&lt;/strong>；&lt;/li>
&lt;li>另一个集合 $\mathrm{Mor}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong>态射&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>另外，对上面两个集合之间有这样的要求：&lt;/p>
&lt;ul>
&lt;li>两集合间有一对映射： $s\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$ 和 $t\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$，它们分别指出了态射的&lt;strong>来源&lt;/strong>与&lt;strong>目标&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>对于态射而言，有这样的要求：&lt;/p>
&lt;ul>
&lt;li>针对某两个对象 $X,Y\in\mathrm{Ob}(\mathcal{C})$，我们可以从上面这一对映射中得到这两个对象之间的所有态射的集合：$\mathrm{Hom}_\mathcal{C}(X,Y)\vcentcolon=\space s^{-1}(X)\cap t^{-1}(Y)$。在明确所指范畴的情况下可简记为 $\mathrm{Hom}(X,Y)$。这样的集合也被称为 $\mathrm{Hom-}$ 集；&lt;/li>
&lt;li>对于任意的一个对象 $X$，一定存在一个态射 $\mathrm{id}_ {X} \in \mathrm{Hom}_{\mathcal{C}}(X,X),$ 这个态射被称为 $X$ 到自身的恒等态射；&lt;/li>
&lt;li>给定任意的三个对象 $X,Y,Z\in\mathrm{Ob}(\mathcal{C})$，有这样在其 $\mathrm{Hom-}$ 集之间的映射，称为&lt;strong>合成映射&lt;/strong>，定义为：
$$\begin{align*}
\circ\vcentcolon\space\mathrm{Hom}_\mathcal{C}(Y,Z) \times \mathrm{Hom}_\mathcal{C}(X,Y)&amp;\to \mathrm{Hom}_\mathcal{C}(X,Z)\\
(f,g)&amp;\mapsto f\circ g\\
\end{align*}$$
且当不至于混淆时可以省略中间的 $\circ$，将 $f\circ g$ 简记为 $fg$。&lt;/li>
&lt;/ul>
&lt;p>最后，对上面的合成映射而言，有这样的两个要求：&lt;/p>
&lt;ol>
&lt;li>结合律：对于任意的态射 $h,g,f\in\mathrm{Mor}(\mathcal{C})$，如果映射的合成 $f(gh)$ 和 $(fg)h$ 都有定义，那么 $$f(gh) = (fg)h.$$&lt;/li>
&lt;li>对于任意的态射 $f\in\mathrm{Hom}_\mathcal{C}(X,Y)$，其与恒等映射之间的复合满足关系：
$$f\circ\mathrm{id}_X = f = \mathrm{id}_Y\circ f.$$&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;p>那么以上，就是范畴的比较正式的定义。可以看到它还是有依赖一些集合论的内容的，但这只依赖于对象集合和态射集合之间的映射，以及在 $\mathrm{Hom-}$ 集之间的映射，并不涉及某个具体的代数结构，特别是没有涉及到在集合上添加运算得到的代数结构。我们一般称这样有集合作为 “基底” 的范畴为 &lt;em>具体范畴&lt;/em>。另外，由于范畴的定义非常灵活，实际上可以定义出非常抽象的范畴，比如以态射作为对象的范畴。&lt;/p>
&lt;p>最后要指出的是，范畴最关键的应该是态射，而不是范畴内的对象。范畴论以研究对象间的态射来研究范畴的行为。从范畴的定义中也可以看到，众多的要求都是对态射提出的，而非对对象。在使用或研究范畴时，应注意这一点。&lt;/p>
&lt;/details>
&lt;h3 id="所以蛇引理到底讲了什么">所以，蛇引理到底讲了什么
&lt;/h3>&lt;p>终于，我们把为了描述蛇引理讲了什么而需要的一些基础内容介绍完了。可以看到，蛇引理还是需要比较多的前置的。下面就是这个所谓的蛇引理了。我们介绍的是建立在两个短正合列所构成的交换图上的简单版本的蛇引理。具体内容如下：&lt;/p>
&lt;blockquote>
&lt;p>蛇引理：&lt;/p>
&lt;p>设有如下图所给出的交换图：&lt;/p>
&lt;figure>
&lt;img src="image/Commute_Diag.svg" style="width:60%">
&lt;/figure>
其中第一行和第二行均为正合列，每个点均为阿贝尔群（交换群）。由这样的两个正合列，我们可以构造出下面的正合列：
&lt;figure>
&lt;img src="image/Snake.svg" style="width:90%">
&lt;/figure>
且当交换图中的虚线箭头成立时，对应的虚线箭头也成立。&lt;/blockquote>
&lt;p>这条引理由于构造出的正合列需要像蛇一样从交换图的左上角开始出发一路拐到右下角而得名。真是恰当的名字。由于我们已经知道所谓的余核，所以上面的正合列实际上还可以写成这样更加对称的形式：&lt;/p>
&lt;figure>
&lt;img src="image/Snake_Coker.svg" style="width:90%">
&lt;/figure>
&lt;!-- $$
0\dashrightarrow \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma \dashrightarrow 0
$$ -->
&lt;details>&lt;summary>对称？对称在哪？&lt;/summary>
我们常常讲 “对称”，对称常常能带来强烈的美感。然而，对称到底是什么？
&lt;p>我们从小就知道轴对称，稍晚会学到中心对称，旋转对称等等。然而这些对称始终没有一个综合的描述方法，它甚至不像是数学的内容，反而更像是美术的内容。然而，有了群，我们就可以描述这样的对称性了：对称，就是使用一个群对其进行作用后仍然能回到自身的性质。对称就蕴含于群内部。&lt;/p>
&lt;p>然而我们这里打算提到的对称，并不是和群相关的，而是和交换图相关的。从交换图上可以看到，如果把底下的链条用余核来代替，那么这个图就是非常对称的：上面是核构成的链条，下面是余核构成的链条；左下角是一个单态，而右上角则是一个满态。然而我们肯定不能单纯满足于这样的只从图上看到的对称，我们想问这样的问题：余核，它和核的定义区别如此之大，为什么会这么自然地存在于这个图内？它们俩之间究竟有什么样的关系，让最后的这个交换图呈现了这样的形状？或者问得更简单一些：余核，什么是 &lt;em>余&lt;/em>？它好像是剩余的意思，但是从英文上来看又完全看不出这样的关系。&lt;em>余&lt;/em> 到底是什么？&lt;/p>
&lt;p>我们做一点剧透：因为范畴和交换图，即因为核与余核之间定义的对称性。可能会有人有这样的疑问：核与余核之间的定义的对称性？从形式上来看完全没有任何的对称性呀？我们指出：在范畴论的语言下，两者完全可以使用 &lt;em>泛性质&lt;/em> 进行定义。我们后面会提到所谓的泛性质是什么。&lt;/p>
&lt;p>我们观察核的定义：核是对一个同态定义的。比如有这样的（群）同态：$\varphi \vcentcolon G\to H$，那么这个同态 $\varphi$ 的核就是一些群 $G$ 中的元素所组成的集合，这些集合在同态 $\varphi$ 的作用下会映射到群 $H$ 的单位元处。或者我们采用原像的写法，$\Ker \varphi = \varphi^{-1} (1_H)$。&lt;/p>
&lt;p>那么我们应该怎么把他改写成使用范畴定义的东西呢？我们抓住范畴论的核心思想：使用态射来研究对象。作为一个同态的核，它在映射之后一定会到单位元上；作为一个群，它一定是同态的定义域的子群。我们可否用这个性质来做文章？答案是肯定的：我们就如此定义，但通过范畴论的语言来描述这个过程。&lt;/p>
&lt;p>我们定义态射 $\varphi \vcentcolon G\to H$ 的核是这样的一个群范畴 $\mathsf{Grp}$ 中的一个对象 $\Ker \varphi$，这个对象到同态 $\varphi$ 的定义域 $G$ 之间存在一个包含同态&lt;/p>
$$\begin{align*}
\iota \vcentcolon \Ker \varphi &amp;\hookrightarrow G\\
g &amp;\mapsto g
\end{align*}$$&lt;p>（我们这里使用带钩箭头标明它是一个单态）；此外，这个对象满足这样的性质：对于任意的同态 $\alpha\vcentcolon X\to G$，只要满足条件&lt;/p>
$$\varphi\circ\alpha = 0,$$&lt;p>（此处 $0$ 代表零映射，或者叫平凡映射（Trivial Map），即将所有的元素都映射到单位元 $1_H$ 上），那么同态 $\alpha$ 即可被唯一地分解，即对某个 $\alpha$ 而言，存在唯一的一个同态 $\overline{\alpha}\vcentcolon X\to \Ker \varphi$，满足 $\alpha = \iota\circ\overline{\alpha}$。将这些性质使用交换图来描述的话，就是说下面的这个交换图成立：&lt;/p>
&lt;figure>
&lt;img src="image/Kernel.svg" style="width:40%">
&lt;figcaption> 核的定义 &lt;/figcaption>
&lt;/figure>
&lt;p>换句话来说，对于任意满足条件 $\varphi\circ\alpha = 0$ 的态射 $\alpha \vcentcolon X \to G$，它们都一定可以被分解成两个映射，且这个分解方式是固定的：先有一个唯一的映射 $\overline{\alpha}$ 将 $X$ 映射到一个群上，然后再从这个群出发，保持原样地通过包含映射 $\iota$ 映射到原态射的陪域 $G$ 中。而这样的固定且特殊的元素，就是我们要找的映射 $\varphi$ 的核，也就是 $\Ker \varphi$。&lt;/p>
&lt;p>我们观察这样的定义，它实际上确实定义出了我们熟悉的核，只不过是用了更加范畴论的形式，并没有研究元素内部是如何映射的，而是使用了 &lt;em>平凡映射&lt;/em> 来包含所有我们需要的信息，再通过唯一分解的方式来确定它的地位。它只是换了一种更加 fancy 的说法而已。&lt;/p>
&lt;p>而接下来，我们就要仿照这样的形式，来定义余核。我们先来观察已有的余核定义，它被定义为同态的陪域模除掉同态的像得到的结构。为此，我们需要先来看看商的泛性质。我们依旧在群范畴内讨论这个问题，但是它很容易就可以推广到其他的结构中。&lt;/p>
&lt;p>从商的构造过程来看，构造商结构时需要取一个等价关系，然后根据这个等价关系进行划分，最后将所有的等价类放在一起，每个等价类作为一个商结构中的一个元素，这就是取商的过程。如果要在范畴论中讨论这个问题，那么就需要从与商相关的态射出发考虑这个问题。首先我们看取商的过程。&lt;/p>
&lt;p>鉴于上面的过程的统一性，我们将这个过程化为一个态射，称之为商映射 (Quotient Map)，记作 $\pi$。当明确左或右陪的元素时，也可以在这个记号的左下标处记下该元素，如从整数群构造 n 阶循环群的过程，其商映射就可以记为 $\pi_n\vcentcolon\mathbb{Z}\to\mathbb{Z} /n\mathbb{Z}$。有了这样的记号，我们的讨论也会更加便利。&lt;/p>
&lt;p>既然从态射角度出发，我们想观察：假如从群 $G$ 到群 $G'$ 有一个同态 $\varphi$，而群 $H$ 是 $G$ 中的正规子群（因此可以被模掉）且 $H\subseteq \Ker \varphi$（为了保证商群依旧能映射到 $G'$ 上）。那么，这个同态 $\varphi$ 与 $G$ 模 $H$ 得到的子群 $G/H$ 之间有什么样的联系呢？我们有这样的定理，同样，可以用交换图来表示：如果有上述条件存在，那么则存在一个唯一的映射 $\overline{\varphi}$，使得 $\varphi = \overline{\varphi} \circ \pi$，即下面的图交换：&lt;/p>
&lt;figure>
&lt;img src="image/Quotient.svg" style="width:40%">
&lt;figcaption> 商的泛性质 &lt;/figcaption>
&lt;/figure>
&lt;p>怎么理解这个图的交换性呢？当我们把 $G$ 映射到 $G'$ 时，由于该映射的核的限制，必须有和核的元素个数一样多的元素被映射到同一个 $G'$ 中的元素里（考虑我们定义的核，以及商映射的特点）；当将 $G$ 商映射到 $G/H$ 上面时，由于 $\Ker \varphi$ 的元素比 $H$ 中的元素数量要多（上面的子集关系），此时从 $G$ 到$G'$ 的同态 $\varphi$ 对其定义域 $G$ 的 “收缩力度” 是一定不如商映射 $\pi$ 的。因此，我们一定可以从商映射得到的 $G/H$ 中再做一次映射，从 $G/H$ 重映回 $G'$，使得 $\varphi$ 最后被表示为 $\overline{\varphi}$ 与 $\pi$ 的复合。也就是说，$\varphi$ 被分解为了两步：首先，通过正规子群进行分类，由于我们取的正规子群比核小，所以商群内的每个元素必定被映射到同一个元素内;在进行这样的分类后，再进行一次映射，把分好的等价类按照其中元素原有的根据 $\varphi$ 的映射方式来将这些等价类映射到对应的 $G'$ 中的元素里。由于拉格朗日定理，子群的关系保证了这样分类得到的等价类个数一定是整除态射 $\varphi$ 的像的，这也就保证了这个同态是良好定义的，并不会出现一个等价类映射到两个 $G'$ 中元素，或者映射到同一 $G'$ 中元素的等价类数目不同这样的情况。&lt;/p>
&lt;p>在理解上面定理的含义后，我们指出：实际上我们可以借助商的这一泛性质来定义商结构和商映射，即：设 $G$ 是一个群，其有一正规子群 $H$，则通过如下两个泛性质即可定义商群 G/H 与商映射 $\pi$：&lt;/p>
&lt;ol>
&lt;li>存在一个群 $G/H$ 和一个群同态 $\pi\vcentcolon G\to G/H$，满足 $\Ker \pi = H$；&lt;/li>
&lt;li>对任意的群 $G'$ 与 群同态 $\varphi\vcentcolon G\to G'$，如果 $H \subseteq \Ker \varphi$，则存在一个唯一的群同态 $\overline{\varphi} \vcentcolon G/H \to G'$，使得上面的交换图成立。&lt;/li>
&lt;/ol>
&lt;p>也许你有疑问：我们不是在看余核是怎么回事吗？你怎么扯到商结构和商映射用泛性质的定义了？正是由于有了商结构的泛性质，我们才能更好地定义我们已经知道的余核。&lt;/p>
&lt;p>这里也不继续卖关子了，为了定义余核，我们需要做的事情只有三件：一，将上面核的泛性质图里的所有箭头转向；二，把 $\Ker \varphi$ 换成 $\Coker \varphi$，把带钩箭头换成双箭头（代表满态），再把包含映射记号 $\iota$ 换为商映射记号 $\pi$；最后，我们再仿照核的定义，来讲所谓的余核是什么的时候，需要将群改为阿贝尔群（交换群）。我们先把表示它泛性质的图画出来；为了方便对照，我们把核对应的泛性质图用另一种形式画出并附上（两种交换图是完全等价的）：&lt;/p>
&lt;div style="display: flex">
&lt;figure style="float: left; flex: 50%">
&lt;img src="image/Coker.svg" style="width:80%">
&lt;figcaption> 余核 &lt;/figcaption>
&lt;/figure>
&lt;figure style="float: left; flex: 50%">
&lt;img src="image/Ker.svg" style="width:80%">
&lt;figcaption> 核 &lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>相信到了这一步，你一定会相信所谓的 “对称” 绝非空穴来风。所谓的余核，说得简单点，就是把核的泛性质里的所有箭头都反转后定义出来的东西而已；甚至于对于范畴论而言，所谓的 “余” 就是将某个对象的泛性质里箭头全部反转后出现的对偶。一个著名的范畴论笑话是这么讲的：&lt;/p>
&lt;p>&lt;em>A mathematician is a device for turning coffee into theorems, and a comathematician is a device for turning cotheorems into ffee.&lt;/em>&lt;/p>
&lt;p>我们再来看看余核的泛性质。很容易就可以看到余核的交换图的右侧出现了我们熟悉的身影：商结构和商映射的泛性质。通过这个小块我们得以了解到，$\Coker \varphi$ 应该具有某种商结构，需要用 $H$ 商去它的一个正规子群。那么它具体应该商去谁呢？注意到两点：&lt;/p>
&lt;p>第一点是，商结构的特点决定了它要商掉的那个正规子群本身是可以作为陪集存在于商群中的。举个简单快速的例子，$A/B$ 这个商群里 $B$ 本身就是一个陪集，是用 $A$ 中单位元 $1_A$ 去陪 $B$ 得到；而这个特殊的陪集，由于用来左陪的元素是 $A$ 中单位元，它在商群 $A/B$ 中一定也是担任单位元的责任；&lt;/p>
&lt;p>另一个点则来自于 $G\to X$ 必须是平凡映射这一要求。我们根据余核的泛性质，可以轻松地取这样的 $\beta$，让它就等于 $\pi$，这样一来 $\overline{\beta}$ 就变成了恒等映射，$X$ 也就变成了我们研究的 $\Coker \varphi$。那么，从群 $G$ 出发，在映射到 $\Coker \varphi$ 时必须到它的单位元上，那么从商映射的特点看，所有的 $G$ 中的元素都必须在经过 $\varphi$ 映射后出现到 $\Coker\varphi$ 商去的那个正规子群里。而满足这样条件的东西只有一个，即 $\Img \varphi$，且还有一个要求，就是 $\Img \varphi$ 必须是正规的，这就要求 $H$ 是交换群，进而要求整个泛性质中的群都得是交换群。&lt;/p>
&lt;p>如此，我们又成功地从余核的泛性质的定义里拿到了我们熟悉的，用商群定义的那个余核。这也进一步指明了核与余核在范畴论意义下的对偶关系。然而，对于核以及余核而言，它们的定义还可以更加 fancy 一些：我们可以使用极限和余极限来定义核与余核，这里就不过多展开了，毕竟这篇文章不是讲范畴论的，而是为了证明蛇引理的来着（）&lt;/p>
&lt;/details>
&lt;h2 id="准备证明吧">准备证明吧
&lt;/h2>&lt;p>我们的手牌已经集齐了，现在等待着我们的就是要证明这个引理。这个引理涉及到的阿贝尔群很多，同态也很多。我们需要一步一步地朝着目标前进，否则这个大个家伙是没办法一次搞定的。&lt;/p>
&lt;h3 id="证明思路">证明思路
&lt;/h3>&lt;p>从最后的结果来看，我们有这样的几个问题是需要验证的：&lt;/p>
&lt;ol>
&lt;li>$f|$ 的定义是否合理&lt;/li>
&lt;li>$g|$ 的定义是否合理&lt;/li>
&lt;li>$\hat{f'}$ 如何定义，是否良定&lt;/li>
&lt;li>$\hat{g'}$ 如何定义，是否良定&lt;/li>
&lt;li>$\delta$ 如何定义，是否良定&lt;/li>
&lt;li>每个点处是否正合&lt;/li>
&lt;li>若原交换图虚线箭头成立，得到的正合列是否对应虚线箭头也成立&lt;/li>
&lt;/ol>
&lt;p>我们不计划纠结于为什么核与余核在这里出现的如此频繁，只将之作为待证明的结论；也就是说，我们不考虑为什么选择了这样的构造，只考虑证明这个构造为什么是正确的。另外，我们可以发现第1点与第2点是很相似的，同样第3点与第4点也是很相似的。&lt;/p>
&lt;p>在正式开始进行验证之前，我们做一些符号上的约定，以免待会儿晕符号。如果是 $A$，$B$，$C$ 中的元素，我们就用对应的小写字母代表；如果是 $A'$，$B'$，$C'$ 中的元素，我们就在对应小写字母的上面也对应地加上这个 $\prime$。如果需要从同一个群中取两个元素，为了区分它们，我们会再在右上角添加上 $*$ 来表示。如果是经过了同态/映射的作用，在需要时会加上其属于的群以做提示，而不再用 $\prime$ 或者别的字母做记号，除非这样的记号是必须的。&lt;/p>
&lt;p>好了，我们开始正式的证明过程吧。&lt;/p>
&lt;h3 id="验证-f-的定义然后-g">验证 $f|$ 的定义，然后 $g|$
&lt;/h3>&lt;p>我们第一个要验证的是 $f|$ 的定义，或者说仔细考虑怎么样去定义它。从图上可以看到，这个同态是 $f$ 在 $\Ker \alpha$ 上的限制，对它的定义的验证则是要验证 $f|$ 是否真的能把 $\Ker \alpha$ 映射入 $\Ker \beta$ 中，即验证 $\Img f| \subseteq \Ker \beta$。&lt;/p>
&lt;p>为了验证这件事，我们只需要任意取 $\Ker \alpha$ 中的元素，如果这些点在 $f|$ 的映射下都属于 $\Ker \beta$，就可以验证这样的包含关系了（这也是子集的定义）。既然如此，我们取 $\Ker \alpha$ 中的一个元素 $a$，根据核的性质，既然 $a$ 在 $\alpha$ 的核内，我们知道 $\alpha (a) = 0 \in A'$，再根据同态的性质，群同态只能将单位元/零元映射到单位元/零元上，我们知道 $f' \alpha (a) = 0 \in B'$。由于交换图的性质，我们有：$\beta f (a) = f' \alpha (a) = 0$。请注意 $\beta (f(a)) = 0$ 就意味着 $f(a)$ 这一点位于 $\Ker \beta$，即 $f(a) \in \Ker \beta$，而这恰恰就是我们要证明的：任意一个 $\Ker \alpha$ 中的元素 $a$ 在经过 $f|$ 映射之后，都位于 $\Ker \beta$ 中。&lt;/p>
&lt;p>这里有一个点需要指出：为什么我们明明要验证的同态是 $f|$，最后却直接使用了 $f$ 的性质？这是因为：$f|$ 除了更改了定义域的范围之外，所有的信息都得以保留。由于我们任取的 $a$ 满足 $a\in\Ker \alpha \subseteq A$，所以 $f|$ 对在 $\Ker\alpha$ 中语境下的 $a$ 所产生的影响，和 $f$ 对 $A$ 中语境下的 $a$ 产生的影响是一模一样的。这保证了我们可以放心大胆地使用 $f$ 的性质。&lt;/p>
&lt;p>最后我们指出，这里的验证过程没有借助图表交换以及核的性质以外的任何要素，因此这套证明也可以直接照搬到下一个交换块，也就是关于 $g|$ 的定义的验证问题上。这里就不啰嗦了。&lt;/p>
&lt;h3 id="验证-hatf-的定义顺带-hatg">验证 $\hat{f'}$ 的定义，顺带 $\hat{g'}$
&lt;/h3>&lt;p>接下来要验证的就是 $\hat{f'}$ 的定义了。我们要验证的东西其实和上面类似，也是 $\Img \hat{f'} \subseteq \Coker \beta$。然而我们现在还不知道 $\hat{f'}$ 具体是怎样的，只知道它的定义域是 $\Coker \alpha$。所以我们先来看看 $\Coker \alpha$ 里都有什么，再看看 $\hat{f'}$ 是一个什么样的同态，最后来考虑验证上面所要求的定义。&lt;/p>
&lt;h4 id="operatornamecoker-alpha-里是什么样的">$\operatorname{Coker} \alpha$ 里是什么样的
&lt;/h4>&lt;p>由于 $\Coker \alpha = A' / \Img \alpha$，其中的每个元素都应该是 $\Img \alpha$ 这种形式的陪集。&lt;/p>
&lt;p>我们先考察一般的阿贝尔群（交换群）里某个同态的余核是什么样的。对于一般的阿贝尔群 $A$ 以及其上的某个同态 $f\vcentcolon\\,A\to B$ 而言，这里的等价关系是这样定义的：若 $a,a^* \in A$ 且 $a - a^* \in \Img f$，则认为 $a \sim a^* $，即 $a$ 与 $a^* $ 等价。这里的减号应该与 $a^* $ 一起理解为 $a^* $ 的逆元。这就形同 $a^{-1}a^* $ 在一般的乘法群中判定元素是否等价时一样。&lt;/p>
&lt;p>与此同时，其他的等价类（陪集），按照加法记号，也应该可以写作这样的形式：$a+\Img \alpha$。（假如你没有点开哪些小箭头的话）我们使用代表元的记号来记录这个陪集，即 $\hat{a} = a+\Img \alpha$。我们在余核中定义的运算，则是借助余核所在的群的运算所定义的：直接将代表元按照原群中的运算进行，最后给它带上帽子（找到对应的等价类）。写成符号形式则是：假设有同态 $f: A\to B$，则这个同态的余核为 $\Coker f = A/\Img f \subseteq A$，再设余核这个群中有两个元素 $\hat{a}$ 与 $\hat{a^* }$，则余核中的运算为：$\hat{a}+_\mathrm{Coker}\hat{a^* } = \widehat{a+_A a^* }$。&lt;/p>
&lt;p>现在一切都明了了。对于我们所要研究的问题而言，$\Coker \alpha$ 中的元素，就是一个个等价类，这些等价类用原群的元素作为代表元进行标记，如 $\hat{0}$, $\hat{a'}$ 这样。而其运算直接继承自群 $A'$，具体而言，只需要将用来与子群作用的元素相运算，最后再作用回子群即可。&lt;/p>
&lt;h4 id="hatf-是什么样的">$\hat{f'}$ 是什么样的
&lt;/h4>&lt;p>从交换图上可以看到，$\hat{f'}$ 是从 $\Coker \alpha$ 到 $\Coker \beta$ 上的。而在 $\Coker \alpha$ 中的元素则是众多的以代表元所代表的等价类。那么，在使用 $\hat{f'}$ 作用到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$ 后，得到的则应该是位于 $\Coker \beta$ 中的一个元素，这个元素应该是形如 $b'+\Img \beta$ 这样的等价类，自然也可以被表示为 $\hat{b'}$。这就是我们需要验证的同态，$\hat{f'}$，具体在做的事。&lt;/p>
&lt;p>让我们写的更加明确一些：我们要定义的 $\hat{f'}$ 应该是这样的：&lt;/p>
$$\begin{align*}
\hat{f'}\vcentcolon\space \Coker \alpha &amp; \to \Coker \beta \\
a' + \Img \alpha &amp; \mapsto b' + \Img \beta,
\end{align*}$$&lt;p>其中 $a'\in A'$ 与 $b' \in B'$ 之间的关系有：$f'(a') = b'$。&lt;/p>
&lt;p>那么就有值得注意的一些问题。两个元素等价时，它们自然属于同一个等价类，但这两个元素本身是可以不同的。假如两个不同但等价的元素在进入等价类后再被商群间的同态所映射，应该会得到一个目标群上的等价类。另外，自然，我们也要验证这个同态的像确实在陪域内。我们开始验证吧。&lt;/p>
&lt;h4 id="开始验证">开始验证
&lt;/h4>&lt;p>我们取 $\Coker \alpha$ 中的一个元素 $\hat{a}$，这个元素是一个等价类，等价关系由 $a' - a'^* \in \Img \alpha \hArr a' \sim a'^* $ 给出。此时我们就取这个等价类中的这两个元素 $a',\\, a'^* \in A'$。那么，此时这两个元素在经过 $f'$ 作用后得到的就是 $f' (a')$ 以及 $f'(a'^* )$。这两个 $B'$ 中的元素应该依旧会被映射到同一个等价类中，也就是两个元素等价。判断两元素等价的条件则类似于前面的判断条件：$f' (a') - f'(a'^* ) \in \Img \beta$。我们可以看到：由于 $f'$ 是一个同态，同态是保运算的，则 $f' (a') - f'(a'^* ) = f'(a' - a'^* )$。注意到 $a' - a'^* \in \Img \alpha$，由像的性质，我们就一定可以找到一个存在于 $A$ 中的一个元素 $a$，使得 $\alpha(a) = a' - a'^* $。&lt;/p>
&lt;p>我们理一下思路：我们先选取了两个在 $A'$ 中等价的元素；这两个元素的差，根据等价类划分的规则，必须是属于 $\alpha$ 的像的，那么就一定有一个对应的 $A$ 中的元素 $a$ 在 $\alpha$ 的作用下等于这两个 $A'$ 中元素的差。那么这时，我们就可以使用图表交换的性质了：$f'(\alpha(a)) = \beta(f(a))$。请注意这个地方：右侧显示 $\beta(f(a))$ 是属于 $\beta$ 的像的：$\beta(f(a)) \in \Img \beta$。这就说明了 $f'(\alpha(a)) = f'(a' - a'^* ) \in \Img \beta$。这样，我们就得到了我们所需要的：任取两个 $A'$ 中的等价元素，它们最终被映入了 $B'$ 的等价类，因为 $f' (a') - f'(a'^* ) \in \Img \beta$。&lt;/p>
&lt;p>那么这样我们就可以进一步进入到对 $\hat{f'}$ 的验证：如果 $a'\in A'$ 且 $a'^* \in A'$ 且二者等价，就有 $a' + \Img \alpha = a'^* + \Img \alpha$。我们希望这两个应该相等的等价类在经过 $\hat{f'}$ 的映射后得到的是同一个 $\Coker \beta$ 中的元素。那我们就直接进行运算：&lt;/p>
$$\begin{align*}
\hat{f'}(a' + \Img \alpha) &amp;= f'(a') + \Img \beta\\
&amp;= f' (a'^* +a'-a'^* ) + \Img \beta\\
&amp;= f' (a'^* ) + f'(a'-a'^* ) + \Img \beta \\
&amp;= f' (a'^* )+ \Img \beta\\
&amp;= \hat{f'}(a'^* + \Img \alpha).
\end{align*}$$&lt;p>我们来解释一下上面的运算过程。第一步是使用了我们上面对函数做出的定义；第二步就是单纯地进行了个加减，不过这里的加减能成立必须利用交换群的性质；第三步则是利用了 $f'$ 作为阿贝尔群同态的定义；第四步则要应用到我们刚刚得到的结论： $f' (a') - f'(a'^* ) \in \Img \beta$；第五步则就是单纯运算回以 $\hat{f'}$ 表达的形式，完成我们的证明。&lt;/p>
&lt;p>自此，我们证明了：两个任意的 $A'$ 中元素，当它们等价时，会且总是会被 $\hat{f'}$ 映射到同一个 $\Img \beta$ 中的元素。这句话还可以换个说法：我们定义的这个同态，是不依赖于等价类代表元的选取的（我们选了两个代表元，结果一样）；或者简单一些：这个同态是良定的。&lt;/p>
&lt;p>我们完全可以按照相似的逻辑处理 $\hat{g'}$。这得益于我们上面的定义以及验证没有用到除了交换图提供的信息外的任何额外附加信息。所以我们就不特别定义并验证这个 $\hat{g'}$ 了，直接借用这里的定义以及验证方法即可。&lt;/p>
&lt;details>&lt;summary>如何验证一个同态是良定的&lt;/summary>
&lt;p>在代数学中，我们常常会尝试给某个数学对象附上一个同态，或者给两个数学对象之间定义同态。然而，这样的过程并不总是顺利的：可能我们定义的东西到实际验证时是有问题的。就我个人的观点而言，这些问题包括但不限于：&lt;/p>
&lt;ul>
&lt;li>定义域上同一个元素被映射到了不同的陪域中的元素（违反映射的定义）；&lt;/li>
&lt;li>不保持对象间的结构（不保运算，不保连续等）；&lt;/li>
&lt;li>定义域不对，超出或小于定义域；&lt;/li>
&lt;li>超过了陪域的范围，&lt;/li>
&lt;/ul>
&lt;p>等等。而我们所说的验证一个同态是良定的，实际上就是在尝试验证上面的这些问题都不会出现。一般而言，后两个问题都不太容易出现，一般的验证过程都是在验证前两个问题是否存在。&lt;/p>
&lt;p>我们先看第一个，这个的验证方法非常地朴实无华，即通过验证两个定义域上相等的元素，它们在经过同态作用之后是否依旧相等。如果是保持相等的，则证明一个元素不会被映射到两个不同的元素上，从而完成第一个问题的验证。这里要提到的是，对于商群这样，元素是陪集这样集合的情况，还有必要验证一个陪集内的元素是否能被从商群出发的同态映射到定义域上的同一个元素中。不过这一点也可以归结为对第二个问题的验证，即同态是否能够保持对象间的结构。&lt;/p>
&lt;p>针对商群这样的结构，如果一个陪集内的元素被映射到了不同的定义域上的元素，那么就证明这样的映射并不能保持商群的元素，即陪集，内部所有元素等价的条件。除了这样的结构性质外，另一个常见的结构即定义好的代数运算，或者说是同态区别于函数的性质。我们也可以说，先对元素做运算再通过同态映射，其结果应该等同于先做完同态的映射，再在陪域内进行运算。这也许可以被称为同态和运算之间的 “交换性”。&lt;/p>
&lt;p>虽然第三和第四个问题一般不会出现，但是在从零开始构造一个同态时，对它们的验证依旧是有必要的。特别是第四条，即对于陪域的验证，我们要求同态的像必须是陪域的子集，否则这个映射就不是良定义的。从上面的一系列验证过程中，我们也能够看到对于这一条件的验证。&lt;/p>
&lt;/details>
&lt;h3 id="delta-的定义与验证">$\delta$ 的定义与验证
&lt;/h3>&lt;p>这个 $\delta$ 的定义算是证明蛇引理过程中的一个难点吧，这也是蛇引理的关键一步，也是 “蛇” 这个字的由来吧。我们应该如何从一个核映射到余核呢？从交换图上来看，是需要从 $C$ 中的子集映射到 $A'$ 上的等价类的。这应该如何是好呢？&lt;/p>
&lt;h4 id="delta-应该是什么样的">$\delta$ 应该是什么样的
&lt;/h4>&lt;p>好消息是：我们对同态 $g$ 以及 $f'$ 是有一些说法的：$g$ 一定是满态，而 $f'$ 则一定是单态。这是根据这两个正合列的性质，或者说是正合列中 $C$ 点与 $A'$ 点的性质而得到的。我们前面也有提到这个结论，这里简单说明一下：由于 $C$ 映射到平凡群的同态一定是一个满态，这个满态的核就一定是 $C$ 本身；由于正合的要求，$g$ 的像就必须是 $C$ 了，也就是 $g$ 是满的；由于 $0$ 到 $A'$ 作为同态必须也只能映射到 $A'$ 中的单位元，所以这个映射的像就只能是那个单位元自己形成的平凡群；由于正合列的性质，$f'$ 的核则只能是这个平凡群，也就是说它是一个单态。&lt;/p>
&lt;p>这两个信息对于 $\delta$ 的构造是必须的，否则我们没有一个很好的从 $C$ 一路走回 $A'$ 的方法。当然，有了上面的提示，我们很自然想到，这个 $\delta$ 的构造应该是什么样的。它会从 $C$ 出发，从 $g$ 反着走到 $B$ 点，在经过 $\beta$ 的映射之后，再通过 $f'$ 反过来到 $A'$ 上。我们来更细致地考察这个映射构造过程的每一步吧。&lt;/p>
&lt;h4 id="delta-的具体构造">$\delta$ 的具体构造
&lt;/h4>&lt;p>我们的 $\delta$ 是从 $\Ker \gamma$ 开始的，自然我们就取 $C$ 中的子集 $\Ker \gamma$ 里的一个元素 $c$。得益于满态的性质，我们一定是可以在 $B$ 中找到某个元素 $b$，使得 $g(b) = c$ 的。&lt;/p>
&lt;p>注意到我们对 $c$ 的选取，这个 $c$ 是在 $\Ker \gamma$ 内的，所以就会有： $\gamma(g(b)) = 0$。再根据图的交换性，我们就有了 $g'(\beta(b)) = \gamma(g(b)) = 0$，也就是说 $\beta(b) \in \Ker g'$。&lt;/p>
&lt;p>这时我们要根据正合列的性质来继续向 $A'$ 推进。由于正合性，我们有 $\Img f' = \Ker g'$，因此 $\beta(b) \in \Img f'$，而既然 $\beta(b)$ 出现在了 $f'$ 的像中，就一定会有一个 $A'$ 中的元素，我们记作 $a'$，一定会在 $f'$ 映射后到我们之前拿到的 $\beta(b)$ 上。&lt;/p>
&lt;p>最后，由于 $f'$ 是单态，上面说的那个 $a'$ 在此时是唯一确定的。而这个唯一确定的元素在 $A'$ 对应的商群 $\Coker \alpha$ 中自然也是属于唯一的一个等价类的。&lt;/p>
&lt;p>我们现在回溯一下这个过程：我们取了 $\Ker \gamma$ 中的一个元素 $c$，它一定对应了某个 $B$ 中的 $b$。但要注意的是，因为仅有 $g$ 是满态的要求，这个 $b$ 可能不唯一。接着我们从这个 $b$ 自然地得到了 $\beta(b)$，而它则有 $A'$ 中存在且唯一的对应元素 $a'$。这个元素，很自然地，在 $\Coker \alpha$ 中就有了唯一的等价类。总结下来就是：每个 $\Ker \gamma$ 中的元素经过我们上面的映射过程，都是可以得到 $\Coker \alpha$ 中的等价类的。&lt;/p>
&lt;p>然而这给了我们一个亟待解决的问题：这个映射链最后是需要组合成一个同态 $\delta\vcentcolon\\,\Ker \gamma \to \Coker \gamma$ 的，而作为一个同态，每个定义域上的元素能且只能对应到陪域上的唯一一个元素。然而从我们刚刚的映射链过程来看，由于 $c$ 在 $B$ 中对应的元素个数是不确定的，虽然每个 $b$ 中元素都能对应到唯一的 $A'$ 中的等价类，但可能所有满足 $g(b) = c$ 的 $b$ 所能对应的 $A'$ 的等价类是不一样的。用更形式化的语言来讲，我们现在要解决，或者要证明的问题就是：&lt;/p>
&lt;blockquote>
&lt;p>设存在两个 $B$ 中的元素 $b,\\,b^* $，满足 $g(b) = g(b^* )$，求证这两个元素在经过映射链 $\beta$ 与 $f'$ 的反向作用（我们以后就记这个反向作用为 $(f')^{-1}$ 了，这个记号是合理的，我们后面会提到） 后得到的元素在 $A'$ 中是等价的，其中等价关系由 $a' - a'^* \in \Img \alpha$ 给出。&lt;/p>&lt;/blockquote>
&lt;p>如果这个命题得到了验证，那么就说明这条路走得通，一个唯一的 $\Ker \gamma$ 中的 $c$，不论它在 $B$ 中对应有多少个元素，最后都会在 $A'$ 里对应到同一个等价类里，也就是在 $\Coker \alpha = A'/\Img \alpha$ 中有唯一的一个元素与之对应。这样就验证了 $\delta$ 的定义。&lt;/p>
&lt;h4 id="delta-构造的验证">$\delta$ 构造的验证
&lt;/h4>&lt;p>我们开始上面这个命题的证明吧。这里需要注意的第一个问题，同时也是指明了我们应该朝着哪个方向前进的信息，是：我们最后要得到的内容是和 $\Img \alpha$ 有关的。为此，我们一定是要用到 $\alpha$ 这个映射的相关信息的，而这也不可避免地涉及到 $A$ 这个群。因此，我们得想办法先把 $g(b) = g(b^* )$ 这个信息反映到 $A$ 这个群内。&lt;/p>
&lt;p>好消息是，通过同态的性质，我们很容易就可以得到：$g(b-b^* ) = 0$，也就是说 $b-b^* \in \Ker g$。我们故技重施，得到 $b-b^* \in \Img f$，这让我们可以讨论已有的 $g(b)$，$g(b^* )$ 与 $A$ 中的元素的关系，即我们一定可以找到至少一个 $A$ 中的元素 $a$，使得 $f(a) = b-b^* $。&lt;/p>
&lt;p>我们通过图的交换性可以得知，$\beta f (a) = \beta (b-b^* ) = f'\alpha(a)$。这时我们需要用到关于单态的一个性质。这个性质我们之前也提过，甚至这是关于单态的定义：&lt;em>具有左逆的态射为单态&lt;/em>。如此一来，我们给第二个等号的左右两边同时作用上 $f'$ 的左逆。注意到左逆的定义，我们就有了：&lt;/p>
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} f'\alpha(a) = \alpha(a)$$&lt;p>回忆我们之前所提到的，$(f')^{-1}$ 由于 $f'$ 是单态，所以能唯一地确定 $B'$ 中元素在 $A'$ 中所对应的元素；$\beta$ 本身就是一个良定的同态，因此，以上这些就说明了这样一个事实：$(f')^{-1} \beta$ 是一个良定的从 $B$ 到 $A'$ 的同态，且 $(f')^{-1} \beta (b-b^* )$ 作为 $A'$ 的元素，它同时也是位于 $\Img \alpha$ 的。&lt;/p>
&lt;p>那么此时我们再使用 $(f')^{-1} \beta$ 作为同态的性质，有：&lt;/p>
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} \beta (b)-(f')^{-1} \beta(b^* ) \in \Img \alpha$$&lt;p>至此，我们对上面进行总结：设有两个 $B$ 中的元素 $b$ 与 $b^* $，它们满足 $g(b) = g(b^* )$，则我们可以在 $A'$ 中找到这样对应的两个元素 $(f')^{-1} \beta (b)$ 和 $(f')^{-1} \beta (b^* )$，使得这两个元素在我们已经定义好的等价关系下是等价的。&lt;/p>
&lt;p>如此，我们的这个命题得证。进而，我们就成功地构造出了良定的 $\delta$：&lt;/p>
$$
\begin{align*}
\delta\vcentcolon\space\Ker\gamma&amp;\to\Coker\alpha\\
c&amp;\mapsto (f')^{-1} \beta (b) + \Img\alpha,
\end{align*}
$$&lt;p>其中，$c \in \Ker \gamma$ 且 $c = g(b)$。&lt;/p>
&lt;h4 id="一些旁注">一些旁注
&lt;/h4>&lt;p>我们可以看到，为了构造 $\delta$，我们必须利用 $g$ 的满态性质以及 $f'$ 的单态性质，还需要利用交换图右侧部分的交换性。而在验证其定义的过程中，我们同样必须利用 $g$ 的满态性质以及 $f'$ 的单态性质（这里 $g$ 的满态性是直接作为命题的前置条件而存在的），然后还需要利用交换图左侧部分的交换性。$\delta$ 的构造充分利用了我们已有的所有条件，因此算是这个引理证明比较困难的一部分，同时也是关键的部分。而关于前面 $f|$，$\hat{f'}$ 的构造与验证过程中，都只用到了图的交换性，并没有利用 $g$ 是满态以及 $f'$ 是单态的条件。&lt;/p>
&lt;p>我们再来关注 $\delta$ 的构造过程。我们从 $\Ker \gamma$ 中选择了任意的元素 $c$，它在 $g$ 的诸多原像 $b$ 们由于交换图的交换性质，在经过 $\beta$ 的映射到达 $B'$ 后都是位于 $\Img f'$ 上的。由于都在 $\Img f'$ 上，讨论 $(f')^{-1}$ 自然也是有意义的。&lt;/p>
&lt;p>另外我们结合后面对该定义的验证过程，可以看到这个元素 $c$ 是怎么一步步抵达 $\Coker \alpha$ 的：这个元素 $c$ 在 $B$ 中的原像可能包含一个或者多个元素，这些元素经过 $\beta$ 映射后都存在于 $\Img f'$ 中，这个过程里可能有些元素映射到了 $B'$ 里的同一个元素上，也有可能并不是这样，不过这里没有关系。接着它们在单射 $(f')^{-1}$ 的影响下，各不相同地映射到 $A'$ 上，最后分类到同一个等价类中（纯符号地讲，其实就是加上了 $\Img \alpha$）。&lt;/p>
&lt;p>验证过程说明了，只要都是在 $c\in\Ker\gamma$ 的原像里，注定都是会被分到同一个 $\Coker\alpha$ 的等价类里面的。然而，这个分类过程其实是在最后，在得到 $(f')^{-1}\beta(b)$ 后才完成的。好在，由于左侧块的交换性，在从 $c$ 找 $B$ 中原像的过程中，所有符合条件的 $b$ 之间的等价关系（指最终分类到同一 $\Coker \alpha$ 的元素中）早已被确定好了。&lt;/p>
&lt;p>这里再重申一下单态和满态的性质。单态意味着若陪域中的元素的原像要么非空，要么则只有一个元素，同时单态拥有唯一的左逆；满态则意味着陪域中的所有元素的原像都不是空集。我们利用满态原像的性质得出，$\Ker \gamma$ 中的元素一定可以在 $B$ 中找到对应元素，而又通过单态的性质得出，在已知 $\beta(b)$ 存在于 $f'^* $ 的条件下，$A'$ 中有且只有唯一一个元素与之对应，且通过给 $\beta (b-b^* )$ 作用左逆得出它存在于 $\alpha$ 的像内。&lt;/p>
&lt;h3 id="operatornameker-beta-处正合性的证明">$\operatorname{Ker} \beta$ 处正合性的证明
&lt;/h3>&lt;p>前面我们证明了我们要验证的点的 1-5，借此我们成功地将这些核呀余核呀之类的连起来了。然而，要成为正合列，它需要在中间的每个点上都是正合的。现在已经到手的链条是这样的：&lt;/p>
$$\Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma $$&lt;p>这条链条的中间一共有 $\Ker\beta$，$\Ker\gamma$，$\Coker\alpha$，$\Coker\beta$ 四个点，我们需要分别验证它们两边的态射在它们自身处都是正合的。鉴于 $\delta$ 所连接的 $\Ker\gamma$，$\Coker\alpha$ 处的正合性会比较复杂（由于 $\delta$ 比较复杂），我们先验证 $\Ker \beta$ 处的正合性，再验证 $\Coker \beta$ 的，最后到剩下的两个。&lt;/p>
&lt;p>为了验证正合性，我们需要验证：$\Img f| = \Ker g|$。由于链条上的都是态射，这个等号只需要集合意义上的成立即可在阿贝尔群意义上同样成立，而证明两个集合相等最常用的方法之一便是验证相互包含：$\Img f| \subseteq \Ker g|$ 且 $\Img f| \supseteq \Ker g|$，而为了实现这样的目的，我们会从待验证命题中较小的集合中取点，证明它一定在较大的那个集合中，即可验证这样的子集关系了。&lt;/p>
&lt;p>在我们开始之前，我们把 $\Ker \beta$ 所在短链条写出来，方便后面观察：&lt;/p>
$$ \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma $$&lt;p>那我们就开始吧，先从 $\Img f| \subseteq \Ker g|$ 开始。&lt;/p>
&lt;h4 id="证明-operatornameim-f-subseteq-operatornameker-g">证明 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$
&lt;/h4>&lt;p>我们就取 $\Img f|$ 中的一个元素 $b$，根据像的性质，一定有一个 $a\in \Ker\alpha$ 满足 $f|(a) = b$。而 $f|(a)$ 实际上就是 $f$ 在 $\Ker \alpha$ 上的一个限制，所以也就有 $f(a) = b$；同时，我们取 $g|(b) = c$，由于 $g|$ 也是 $g$ 在 $\Ker\beta$ 上的限制，所以 $g|(b) = g|(f(a)) = g(b) = g(f(a)) = c$。此时，我们考虑原正合列：&lt;/p>
$$A\xrightarrow{f} B \xrightarrow{g} C,$$&lt;p>
我们得到：$f(g(a)) = 0$。由此就得到了 $c = 0$。由于这个结论不依赖于 $b$ 的选取方式，我们就以这种方式得到了 $g|(b) = c = 0$ 恒成立，进而 $b \in \Ker g|$。而这，正说明了这样一件事：如果一个 $\Ker \beta$ 中的元素 $b$ 在 $\Img f|$ 里，那么它就一定在 $\Ker g|$ 中。这就证明了 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$。&lt;/p>
&lt;p>这个命题的得证完全依赖与原正合列的性质，且通过证明该命题，我们得知上面的短链条已经是一个链复型了。下面我们需要证明的就是另一个方向的包含性，也就是：&lt;/p>
&lt;h4 id="证明-operatornameim-f-supseteq-operatornameker-g">证明 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$
&lt;/h4>&lt;p>我们故伎重施，取 $\Ker g|$ 中的一个元素，也叫它 $b$ 好了。既然它在 $g|$ 的核中，那么就有 $g|(b) = 0$，我们此时把 $b$ 放到 $B$ 集合中，此时 $g|(b) = g(b) =0$，说明 $b\in\Ker g$。而根据原链条的正合性，我们有 $\Ker g = \Img f$，因此 $b\in\Img f$。&lt;/p>
&lt;p>然而到此依然不能证明 $b\in\Img f|$，因为 $\Img f|$ 是 $\Img f$ 的子集，无法从一个元素位于更大的集合中来判定它一定在更小的集合里。我们需要更多的信息。然而既然 $b\in\Img f$，我们就可以找到 $A$ 中的一个元素 $a$，使得 $f(a) = b$。又因为根据 $b$ 的取法，它在 $g|$ 的定义域 $\Ker \beta$ 上，一定就有 $\beta(b) = \beta(f(a)) = 0$。此时，我们根据交换图的性质，可以得到 $f'(\alpha(a)) = \beta(f(a)) = 0$。&lt;/p>
&lt;p>这样的结果有什么用处呢？回忆 $f'$ 的性质，它是一个单态，因此就一定有左逆 $(f')^{-1}$。我们给上式的左右两边同时左乘（左作用）上 $(f')^{-1}$，就得到：$(f')^{-1}f'(\alpha(a)) = (f')^{-1}(0) = 0 = \alpha(a)$。观察最后一个等号，这又说明了 $a \in \Ker \alpha$。&lt;/p>
&lt;p>我们整理一下当前得到的信息，我们有 $\Ker g|$ 中的一个元素 $b$，它在 $A$ 中有一个对应的元素 $a$，我们又得到了这个元素 $a\in\Ker\alpha$。请注意 $f|$ 的定义域正是 $\Ker\alpha$。这就说明了：$b$ 在 $A$ 中对应的元素一定也在 $\Ker\alpha$ 里，也就是 $b\in\Img f|$。同样，由于 $b$ 的选取不依赖于任何的额外条件，我们就证明了 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$。至此，联合上一小节的结论，我们得出结论：该短链在 $\Ker\beta$ 处正合。&lt;/p>
&lt;h4 id="一点注解">一点注解
&lt;/h4>&lt;p>可以看到，前半部分的证明非常简单，直接借助原正合列性质即可，这样直接就证明了这个链条是一个链复型；而后面为了证明正合性的部分则需要使用到 $f'$ 是单态的条件。也许我们在证明 $\Coker \beta$ 处的正合性时，也会遇到这样的特点？我们直接开始吧。&lt;/p>
&lt;h3 id="operatornamecoker-beta-处正合性的证明">$\operatorname{Coker} \beta$ 处正合性的证明
&lt;/h3>&lt;p>和上面一样，我们证明这样的正合性，会以对应映射的像与核相互包含为切入点进行。这次我们还是先证明这个短链：&lt;/p>
$$
\Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta \xrightarrow{\hat{g'}} \Coker \gamma
$$&lt;p>是一个链复型（$\Img \hat{f'} \subseteq \Ker \hat{g'}$），再证明在中间的 $\Coker \beta$ 处是正合的（$\Img \hat{f'} \supseteq \Ker \hat{g'}$）。&lt;/p>
&lt;h4 id="证明-operatornameim-hatf-subseteq-operatornameker-hatg">证明 $\operatorname{Im} \hat{f'} \subseteq \operatorname{Ker} \hat{g'}$
&lt;/h4>&lt;p>照旧我们选择 $\Img \hat{f'}$ 中的一个元素，由于 $\Img \hat{f'} \subseteq \Coker \beta$，这个元素将会是等价类 $\hat{b'} = b' + \Img \beta$。我们想要证明，在前面这个条件下的任何 $\hat{b'}$ 都会被 $\hat{g'}$ 映射到 $\hat{0} \in \Coker \gamma$ 上。既然 $\hat{b'}\in\Img\hat{f'}$，我们就可以取到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$，使得 $\hat{f'}(\hat{a'}) = \hat{b'}$。&lt;/p>
&lt;p>此时，请回忆我们是如何定义 $\hat{f'}$ 的：我们直接借助了原有的同态 $f'$，使得具有了这样的性质：&lt;/p>
$$\hat{f'}(\hat{a'}) = \hat{f'}(a'+\Img \alpha) = f'(a') + \Img \beta = b'+\Img \beta = \hat{b'} = \widehat{f'(a)}.$$&lt;p>带着这条性质，我们观察到：若是对 $\hat{b'}$ 作用上 $\hat{g'}$，就有：&lt;/p>
$$\hat{g'}(\hat{b'}) = \hat{g'}(\hat{f'}(\hat{a'})) = \hat{g'}(\widehat{f'(a')}) = \widehat{g'(f'(a'))} = \hat{0},$$&lt;p>其中，第一个等式是我们一开始取到的 $\hat{f'}(\hat{a'}) = \hat{b'}$，第二个等式是利用了我们上面给出的 $\hat{f'}$ 的性质，而第三个等式则是同样，再次利用 $\hat{g'}$ 它与 $\hat{f'}$ 同样的性质（因为定义是类似的）。最后，第四个等式则利用了原正合列的性质，有 $g'(f'(a')) = 0$。由此，我们再一次地，像上面证明 $\Ker \beta$ 处正合的第一部分一样，证明了 $\Coker \beta$ 处正合的第一部分：无论 $\hat{b}$ 如何取，只要它位于 $\Img \hat{f'}$ 中，就一定位于 $\Ker \hat{g'}$ 中。&lt;/p>
&lt;h4 id="证明-operatornameim-hatf-supseteq-operatornameker-hatg">证明 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$
&lt;/h4>&lt;p>下来我们就证明 $\Coker \beta$ 处正合的第二部分。我们希望能从 $\Ker \hat{g'}$ 中取到的元素能够以某种方式放到 $B'$ 中去，然后借助原正合列的性质去取得在 $A'$ 中或者 $\Coker \alpha$ 中的一些结论。 因此依旧，我们取 $\hat{b'} \in \Ker \hat{g'} \subseteq \Coker \beta$。由于 $\hat{b'}$ 在 $\hat{g'}$ 的核中，我们有 $\hat{g'}(\hat{b'}) = \hat{0}$。我们把这个运算拆开，有&lt;/p>
$$\begin{align*}
\hat{g'}(\hat{b'}) &amp;= \hat{g'}(b' + \Img \beta) \\
&amp;= g'(b') + \Img \gamma\\
&amp;= \hat{0} = \Img \gamma,
\end{align*}$$&lt;p>
由此可以得知，$g'(b') \in \Img \gamma$。然而，这和我们之前所做到的并不一样：$g'(b')$ 只是位于 $\Img \gamma$ 中，它并不等于 $0$。不过，我们依旧可以借助这个条件。&lt;/p>
&lt;p>从 $g'(b') \in \Img \gamma$ 条件中可以得知，一定有一个 $c \in C$ 使得 $\gamma(c) = g'(b')$。而此时，又由于 $g$ 是满射，我们知道一定有一个 $b \in B$ 使得 $g(b) = c$。把它们组合起来，就有了： $\gamma(g(b)) = g'(b')$，此时根据交换图的性质，就有了 $g'(b') = \gamma(c) = g'(\beta(b))$。我们现在把最右边这项移项到最左边，就有了 $g'(b'-\beta(b)) = 0$。&lt;/p>
&lt;p>通过上面的方式，我们成功构造出了一个位于 $g'$ 的核中的元素。因此，直接借助短链&lt;/p>
$$A'\xrightarrow{f'} B' \xrightarrow{g'} C'$$&lt;p>是正合的这一条件，就有：$b'-\beta(b) \in \Ker g' = \Img f'$。&lt;/p>
&lt;p>我们现在再看看这个新构造出的，位于 $\Img f'$ 中的这个元素的等价类是什么样的。我们把 $\hat{b'}$ 写成 $b' + \Img \beta$ 的形式，此时又由于 $\beta(b)$ 自然就在 $\Img \beta$ 中： $\beta(b) \in \Img \beta$，我们就有 $b'+\Img \beta = b' - \beta(b) + \Img \beta$。这意味这我们新构造出的这个更好的元素，它与我们一开始选择的 $b'$ 是等价的，都可以作为 $\hat{b'}$ 的代表元。&lt;/p>
&lt;p>现在我们现在想知道的是，对于等价类 $\hat{b'} = b'-\beta(b) + \Img \beta$，是否一定存在 $\Coker \alpha$ 中的某个等价类，使得它在 $\hat{f'}$ 的作用下就是我们已有的 $\hat{b'}$。为此，我们回到刚刚构造出的，位于 $\Img f'$ 中的这个元素 $b'-\beta(b)$。既然在 $f'$ 的像内，就一定有一个或者几个元素 $a' $ 满足 $f'(a' ) = b'-\beta(b)$。我们知道，$a'$ 在 $A'$ 中的等价类是 $\hat{a'} = a'+\Img \alpha$。而该等价类经过 $\hat{f'}$ 的作用后得到的结果是：&lt;/p>
$$
\hat{f'}(a'+\Img\alpha) = f'(a') + \Img\beta = b'-\beta(b) + \Img\beta = b'+\Img\beta.
$$&lt;p>好，我们现在总结我们已有的信息。我们从一个任意的 $\Coker \beta$ 中的元素 $\hat{b'}$ 出发，构建出了一个位于 $\Ker g'$ 中的元素 $b'-\beta(b)$，其中 $b$ 是直接根据 $b'$ 确定的。这个新的元素所处的等价类就是我们之前挑选的等价类。另外，我们从构造的元素出发，得到了若干个位于 $A'$ 中的元素 $a'$。它所在的等价类则是 $\hat{a'}\in\Coker \alpha$。现在，我们可以注意到：我们只挑出来了一个 $\hat{b'}$，剩下的所有的东西都是由它以及它相关的量决定的。也就是说，$\hat{b'}$ 决定了这些 $\hat{a'}$。而经过上面式子的验证，有 $\hat{f'}(\hat{a'}) = \hat{b'}$。这就说明了：任取一个位于 $\hat{g'}$ 的核内的元素，我们都能确定出一些 $\hat{a'}$，它们全都是满足 $\hat{f'}(\hat{a'}) = \hat{b'}$ 的。&lt;/p>
&lt;p>这就证明了我们想要的结论：任意一个 $\hat{g'}$ 的核内的元素都是 $\Coker \alpha$ 中元素的像，也就是 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$。再结合上一节证明的内容，我们就证明了这个链条在 $\operatorname{Coker} \beta$ 处是正合的。&lt;/p>
&lt;h4 id="callback">Callback
&lt;/h4>&lt;p>可以看到，对于 $\operatorname{Coker} \beta$ 处正合性的证明，是和 $\operatorname{Ker} \beta$ 处正合性的证明很类似的。不过我个人感觉，后面证明的这个，相比于 $\operatorname{Ker} \beta$ 处正合性的证明是要难一些的。这可能是因为需要手动构造一个 $b'-\beta(b)$ 来满足应用正合性的条件，以及对余核的性质的不熟悉吧。总之，顺利地证明了。而下面要证明的，就和我们自己构造出的 $\delta$ 相关了。&lt;/p>
&lt;h3 id="operatornameker-gamma-处正合性的证明">$\operatorname{Ker} \gamma$ 处正合性的证明
&lt;/h3>&lt;p>接下来我们尝试证明短链&lt;/p>
$$\Ker\beta\xrightarrow{g|}\Ker\gamma\xrightarrow{\delta}\Coker\alpha $$&lt;p>在中间一点处的正合性。我们依旧采取原来的策略。&lt;/p>
&lt;h4 id="证明-operatornameim-g-subseteq-operatornameker-delta">证明 $\operatorname{Im} g| \subseteq \operatorname{Ker} \delta$
&lt;/h4>&lt;p>照旧取一个 $\Img g|$ 中的元素 $c\in C$，我们希望能证明 $\delta(c) = \hat{0}$ 恒成立，这样一来自然就有 $\Img g| \subseteq \Ker \delta$ 了。&lt;/p>
&lt;p>既然 $c\in\Img g|$，就会有一个元素 $b\in \Ker\beta$ 使得 $g|(b) = c$。又由于这个 $b$ 是在 $\beta$ 的核中的，因此 $\beta(b) = 0$。此时我们再作用上 $(f')^{-1}$，由于 $f'$ 是单态，所以把 $0\in B'$ 作用上它的左逆只能得到唯一的元素 $0\in A'$，而这对应的 $\Coker \alpha$ 中作为元素等价类正是 $\hat{0}$。&lt;/p>
&lt;p>注意到我们上面的步骤，实际上就是在对 $c$ 作用 $\delta$。因此，我们得到了我们想要的结论：$\delta(c) = \hat{0} \in \Coker \alpha$，也就证明了本命题。&lt;/p>
&lt;h4 id="证明-operatornameim-g-supseteq-operatornameker-delta">证明 $\operatorname{Im} g| \supseteq \operatorname{Ker} \delta$
&lt;/h4>&lt;p>我们还是取 $c\in \Ker \delta$。因此，$\delta(c) = \hat{0} = 0 + \Img \alpha$。我们回顾 $\delta$ 的构造，或者说从 $c\in\Ker\gamma$ 出发抵达 $\Coker \alpha$ 的过程，如果 $\delta(c) = \Img \alpha$，那么 $c$ 就一定会经理这样的过程：它首先在 $B$ 中找到原像中的元素 $b$ 们，然后把这些元素打包被 $\beta$ 映射到 $B'$ 上，此时由于我们的构造，所有的 $\beta(b) \in \Img f'$。此时就一定有许多对应的 $a' \in A'$ 满足 $f'(a') = \beta(b)$。最后由于 $\delta(c) = \hat{0} = \Img \alpha$，必须要有 $a' \in \Img\alpha$ （注意，不是 $a' = 0$，因为只需属于 $\Img \alpha$ 即可满足条件）。&lt;/p>
&lt;p>经过上面的过程，我们得到了这样和原条件等价的条件，即必须至少有一个 $a'\in\Img\alpha$，它由 $f'(a') = \beta(b)$ 确定，而 $\beta(b)$ 中的 $b$ 则从 $c$ 的原像中找到。&lt;/p>
&lt;p>因此，我们先关注这个集众多条件于一身的 $a'$，由于其处在 $\alpha$ 的像内，就一定有 $a\in A$ 使得 $\alpha(a) = a'$。此时我们从 $a$ 出发，利用交换图的性质，就有 $f'(\alpha(a)) = \beta(f(a))$。注意到我们 $a'$ 上的两个条件，将它们带入这个关系，就得到 $f'(\alpha(a)) = f'(a') = \beta(b) = \beta(f(a))$。&lt;/p>
&lt;p>我们关注最后一个等号，它说明了这样的问题：$\beta(b) = \beta(f(a))$，则有 $\beta(b-f(a)) = 0$，也就是 $b-f(a)$ 是属于 $\Ker \beta$ 的。回顾这个元素的构造过程，$b$ 是任意一个在 $c$ 的原像中的元素，这里的 $a$ 是根据 $a'$ 任意选取的在原像内的元素，$a'$ 又是 $\beta(b)$ 在其原像内任意选取的元素。我们看到，$b$ 和 $a$ 都是除了利用 $c\in\Ker\gamma$ 和交换图性质以外任意选取的符合条件的元素，如果对它作用 $g|$ 之后能够回到 $c$，就说明这样的一件事：$c$ 的原像内元素不管怎么选，总会以某些形式回到 $\Ker\beta$，进而映射到 $g|$ 的原像内。&lt;/p>
&lt;p>幸运的是，这很好验证：$g|(b-f(a)) = g(b-f(a)) = g(b) - g(f(a)) = g(b) = c$。第一个等号来自 $g|$ 的定义，当将之放入 $B$ 中考虑是就可以使用 $g$ 替代；第二个等号来自 $g$ 是同态的保运算性质；第三个等号来自链复型的要求；而最后一个等号就是我们一开始选取 $b$ 的方式。这正是说明了我们前面讲的：$c$ 原像中的 $b$，会以 $b-f(a)$（其中 $a$ 也是由 $c$ 间接决定的）的形式出现在 $\Ker\beta$ 里，最后被 $g|$ 映射回 $c$，而这就证明了任何一个 $\Ker\gamma$ 中的元素，其都是 $\Img g|$ 中的元素，也就证明了本命题。再结合上一条命题的证明，我们成功得到了这条链条在 $\Ker\gamma$ 上的正合性。&lt;/p>
&lt;h4 id="一点绕过的弯路">一点绕过的弯路
&lt;/h4>&lt;p>第二个命题的证明其实没有特别顺利。这主要是因为对 $\delta$ 构造的理解不够导致的，或者说太过希望 $\delta$ 有一个好的显式表达而造成的。在取到 $a' = \alpha(a)$ 的时候，我希望直接得到 $b$ 是一定属于 $\Ker\beta$ 的结论，虽然感觉上会有和之前类似的从 $b$ 出发构造的属于 $\Ker\beta$ 的元素一样的桥段，但由于依赖 $\delta$ 的显示表达，我卡在了 $(f')^{-1}$ 只是左逆而非右逆这一点上。因为如果按照我之前的思路，就一定要遇到 $f'((f')^{-1}(\beta(b)))$ 这样的元素。而由于 $(f')^{-1}$ 并非右逆，这个式子是无法约化到 $\beta(b)$ 上的。&lt;/p>
&lt;p>可以看到，最后解决这个问题的方法，是直接采用 $\delta$ 在构造过程中的表现，在从 $B'$ 至 $A'$ 的过程中选择使用 $\beta(b)$ 一定在 $f'$ 的像中的条件，从而绕过了这个问题。虽然说用形式化的思路，比如限定这里 $f'$ 的范围，从而让做出一些限定条件的 $f'$ 成为同构来解决这个问题，但这始终不是个很好的方案。&lt;/p>
&lt;p>另外，就是 $b$ 一定属于 $\Ker\beta$ 的错觉。实际上，$b$ 可以不在 $\Ker\beta$ 中，只需要 $b$ 和某个经过 $g|$ 映射后等于 $0$ 的东西结合之后位于 $\Ker\beta$ 即可。当然我们现在知道，这个东西就是从 $c$ 一路确定下来的 $f(a)$ 了。&lt;/p>
&lt;p>好了，我们开始准备证明蛇引理主体的最后一部分吧：$\Coker\alpha$ 处的正合性。&lt;/p>
&lt;h3 id="operatornamecoker-alpha-处正合性的证明">$\operatorname{Coker} \alpha$ 处正合性的证明。
&lt;/h3>&lt;p>我们不多废话，还是先证明 $\Img \delta \subseteq \Ker \hat{f'}$，后证明 $\Img \delta \supseteq \Ker \hat{f'}$。对应的短链是：&lt;/p>
$$\Ker \gamma \xrightarrow{\delta} \Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta$$&lt;h4 id="证明-operatornameim-delta-subseteq-operatornameker-hatf">证明 $\operatorname{Im} \delta \subseteq \operatorname{Ker} \hat{f'}$
&lt;/h4>&lt;p>取 $\Img \delta$ 中的元素 $\hat{a'} \in \Coker\alpha$，通过证明 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$ 即可证明本命题。由于 $\hat{f'}$ 的定义，我们有 $\hat{f'}(\hat{a'}) = \widehat{f'(a')} = f'(a') + \Img \beta = 0 + \Img \beta$，也就是说只需要证明 $f'(a') \in \Img \beta$，我们就能证明本命题。由于 $\hat{a'}\in\Img\delta$，一定有一个 $\Ker\gamma$ 中的元素 $c$ 满足 $\delta(c) = \hat{a'}$。&lt;/p>
&lt;p>我们这时使用 $\delta$ 的定义：若 $\delta(c) = \hat{a'}$，就说明一定有一个 $b\in B$，这个 $b$ 在 $c$ 的原像中，而且 $\beta(b) = f'(a')$。啊，这不就是我们要的结论吗？既然 $f'(a') = \beta(b)$ 了，那自然 $f'(a')$ 就在 $\beta$ 的像里面了呀。就这样，我们证明了这个命题。&lt;/p>
&lt;h4 id="证明-operatornameim-delta-supseteq-operatornameker-hatf">证明 $\operatorname{Im} \delta \supseteq \operatorname{Ker} \hat{f'}$
&lt;/h4>&lt;p>还是一样，取 $\Ker \hat{f'}$ 中的元素 $\hat{a'} \in \Coker\alpha$。既然在 $\Ker\hat{f'}$ 里，我们就有 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$（我们是不是刚刚见过这句，那就快进吧），进而 $f'(a') \in \Img \beta \subseteq B'$。那么，既然是在 $\Img \beta$ 中的，我们就取所有满足 $\beta(b) = f'(a')$ 的 $b\in B$。此时我们用交换图右侧的交换性，给这个式子左右两边左作用上 $g'$，就得到&lt;/p>
$$0 = g'(f'(a')) = g'(\beta(b)) = \gamma(g(b)),$$&lt;p>其中第一个等号来自交换图下面的链复型的性质，第二个等号就是作用 $g'$ 的结果，第三个等号则是交换图的性质。观察这个式子的左右两端，不难根据核的定义得到结论：只要是满足条件的 $b$，$g(b)$ 就全都在 $\Ker \gamma$ 中。&lt;/p>
&lt;p>到这里其实已经证明完了，因为我们仅从 $\hat{a'}\in\Ker\hat{f'}$ 出发，仅利用交换图就得到了所有满足条件的 $b$，证明了它们全都会在 $g$ 的作用下进入到 $\Ker\gamma$ 里，也就是说，$\hat{a'}$ 确定了且一定对应到了 $\Ker\gamma$ 中的某些元素。这就说明了 $\Img \delta \supseteq \Ker \hat{f'}$。&lt;/p>
&lt;p>我们写详细点，多写几步，那么让 $g(b) = c$，根据 $\delta$ 的定义（或者作用过程），对 $c$ 作用上 $\delta$ 后，将会先有若干个满足 $g(b) = c$ 的 $b$，紧接着这些 $b$ 将被 $\beta$ 映射到 $B'$ 里，最后从 $A'$ 里找到对应的原像，用它们生成一个等价类。而由于我们上面的过程，最后找到的 $A'$ 中的元素所生成的等价类，就是我们一开始的 $\hat{a'}$。这就说明 $\delta(c) = \hat{a'}$。 由于 $\hat{a'}$ 是我们随意取的在 $\Ker\hat{f'}$ 中的元素，都能得到 $\delta(c) = \hat{a'}$，因此 $\hat{a'}$ 确实就存在于 $\Img \delta$ 里。&lt;/p>
&lt;p>至此，我们证明了该命题，并结合上一个证明的命题，一起证明了链条在 $\Coker \alpha$ 处是正合的。&lt;/p>
&lt;h3 id="虚线箭头的相关证明">虚线箭头的相关证明
&lt;/h3>&lt;p>其实上面已经证明完了蛇引理的主体部分。下来我们将证明最后的两个命题：若交换图中的上下两个链条都是短正合列（也就是有 $0\to A$ 和 $C' \to 0$ 成立），那么在从该交换图中得到的正合列的头尾就可以补上 $0\to\Ker\alpha$ 以及 $\Coker\gamma\to 0$，使得 $\Ker\alpha$ 以及 $\Coker\gamma$ 处正合。&lt;/p>
&lt;p>我们还是先证第一个，也就是从 $0\to A$ 的存在可以得到 $0\to\Ker\alpha$ 且 $\Ker\alpha$ 处正合。&lt;/p>
&lt;h4 id="证明-operatornamekeralpha-处的正合性">证明 $\operatorname{Ker}\alpha$ 处的正合性
&lt;/h4>&lt;p>若有 $0\to A$，则根据正合列的性质（或者直接看交换图下面的那个链条），我们就有 $f$ 也是个单态。因此，对 $f$ 做出在 $\Ker\alpha$ 上的限制得到的 $f|$ 并不会改变它是单态的事实（只缩小了定义域）。此时，由于 $f|$ 是单态，它的核根据单态的性质，就一定是一个平凡群。&lt;/p>
&lt;p>此时我们补上 $0\to\Ker\alpha$，由于它一定是单态，它的像只能是平凡群。这自然地就证明了链条在 $\Ker\alpha$ 处是正合的。&lt;/p>
&lt;h4 id="证明-operatornamecokergamma-处的正合性">证明 $\operatorname{Coker}\gamma$ 处的正合性
&lt;/h4>&lt;p>如果有 $C'\to 0$，则根据正合列的性质，我们知道 $g'$ 就必须是满态，这也就意味着 $\Img g' = C'$。&lt;/p>
&lt;p>我们来看我们定义出的 $\hat{g'}\vcentcolon\space\Coker\beta\to\Coker\gamma$，任取它的定义域上的一个元素 $\hat{b'} = b'+\Img\beta$，经过 $\hat{g'}$ 映射后得到的 $\Coker\gamma$ 中对应的元素则是 $g'(b') + \Img\gamma$。然而由于 $\Img g' = C'$，这说明 $g'(b')$ 会随着所有对 $\hat{b'}$ 的选取而跑遍任何一个这里的 $C'$ 中的元素，进而使 $\hat{g'}$ 也是一个满态。自此，我们就可以给 $\Coker\gamma$ 的右端补上 $\Coker\gamma\to 0$ 的同时保持其正合性，因为补上的映射的核正是 $\Coker\gamma$。&lt;/p>
&lt;h3 id="证完串起来">证完串起来
&lt;/h3>&lt;p>至此，我们完全证明了前面列出的所有结论，进而证明了蛇引理。简单盘点我们证明过的东西，我们做了这些事：&lt;/p>
&lt;ol>
&lt;li>构造了五个阿贝尔群间的同态，一一验证了它们的定义是 OK 的；&lt;/li>
&lt;li>对四个点上的正合性做出证明，具体是先向前得到前一个同态的像在后一个的核内，再证明后一个的核再前一个的像内，从而得到正合&lt;/li>
&lt;li>对得到的正合列在交换图上下链条都是短正合列的情况做出补充。&lt;/li>
&lt;/ol>
&lt;p>这里有几个值得一提的点。首先，我们在一开始就得到了 $f|$ 和 $g|$ 的定义，它貌似是直接给出的，但应该是由我们自己定义的，即便定义好之后也是同样的形式。由于阿贝尔群同态的核天生就是其定义域上的阿贝尔子群，除了使用原同态在核上的限制来定义以外，并没有什么更好的定义方法了。&lt;/p>
&lt;p>另外，我们尝试给定义的 $\delta$ 一个具体的表达式，然而这个做法其实可能并不好（我们也应该已经看到了，$(f')^{-1}$ 可能会造成一些问题）。这个同态可以被称作 &lt;em>连接同态&lt;/em>，是蛇引理中连接上下两个正合列的的很重要的一个同态。&lt;/p>
&lt;p>然后，就余核来看，如果对它的一些性质更加熟悉，可能证明过程会更加简单。不过我们也在证明过程中看到了关于它的一些性质，这里就不再赘述，只提一点，就是余核内的单位元（零元）代表的不是简单的 $0$，而是一个等价类。我们还可以看到核与余核之间的一些微妙的联系。然而这里就不过多讨论这些了，这些更多是属于范畴论的内容。从范畴的角度来看，它们的区别就是用来定义的交换图内的箭头方向不一样而已。&lt;/p>
&lt;p>还有就是，我们对正合性做出验证时，并没有按照从左向右的顺序，而是先验证了处于交换图中间位置对应的点的正合性，再验证了两边的。这也许是受到了我所看的视频的影响吧。我想在这里做出另一个推荐的证明顺序，即从链条的左边开始，先证明这个链条是一个链复型，再证明它的正合性。从上面的证明过程来看，其实证明它是链复型的过程非常简单，难点则是那个反包含的证明。当然，我暂时也不计划再证明一次，这次写的很多了，就这样吧。&lt;/p>
&lt;p>此外，基础版本的蛇引理不包含最后的两个同态，就是 $0\to A$ 和 $C'\to 0$。另一个角度来讲，为了从交换图中得到一条正合列，我们只需要这些最低限度的条件。不过，蛇引理还可以继续拓展下去，不过就不叫蛇引理了。&lt;/p>
&lt;p>最后，我们要指出，我们这里做证明的方法，就是所谓的追图（Diagram Chasing）。这种方法从交换图的某个点内的元素为起点，沿着交换图中的态射移动，最终 “追” 到我们需要的元素为止，从而证明某个结论。追图是同调代数中重要的证明方法，其中最基础的一个证明例子便是这里的蛇引理。不过，这里的证明确实较为冗长，如果借助更高级更复杂的数学工具/技巧，比如范畴论，那么证明应该会更加简短一些，形式也更精简一些，不过可能很难看懂，我也不会这些（）&lt;/p>
&lt;h2 id="证毕后的一点感想">证毕后的一点感想
&lt;/h2>&lt;p>一开始动工的时候，我是没想到竟然能写这么多的。也许是因为我太罗嗦了吧，前面讲了很多的前置，也不知道讲清楚没有，而后面证明过程的很多话又都是套话；又或者我觉得写详细一些，易懂一些，可能会比较好，所以就把证明过程中我的一些想法以及口头的一些表达揉进去了。个人而言我还是挺喜欢思考这些东西并把思考过程写下来的。我也有想过把这篇拆成几个部分，不过目前先写在一起吧。即便看完这么多也需要好久好久。&lt;/p>
&lt;p>可以看到里面有一些可以点开的隐藏了的内容，有许多还没有写好，标记着 “Under Construction~”。这些内容应该会在某天我心血来潮之后再次补好吧（补档：我写好了！）。不过也有可能会删掉，或者直接拆分出来？我也不好现在就下判断。另外我还计划在这篇文章的后面，也就是在证明结束后，再补一个不那么啰嗦的证明过程。这样的话，已经有代数基础的朋友也许就可以直接跳到精简版的来看？emmm不过既然已经有代数基础了，想必来看这篇也就是图一乐了。还是希望能嘴下留情~ 作为一个普通的数学爱好者，能证完这个我感觉还挺有成就感的啦。&lt;/p>
&lt;p>不过必须承认的是，写的过程中我还是回头修改了不少表述不太合适的部分，以及这篇证明是离不开网络上的众多优秀资料的帮助的。感谢互联网，互联网万岁！~&lt;/p>
&lt;p>最后，祝您身心健康，生活愉快~&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>我其实挺纠结应该说 &lt;em>函数&lt;/em> 还是 &lt;em>映射&lt;/em> 的。函数我认为用以指代给集合上每个点指派一个数字的东西更合适，更符合我心目中对函&lt;strong>数&lt;/strong>的想象。而映射又太广泛了，因为很多地方代数结构之间不会一板一眼地讲 “同态”，而是直接就说映射了。思来想去，还是函数更合适，毕竟接触最多，接受程度也最广泛。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>这里所谓的合理性，在一般数学教材中称为良定义，而一个定义是合理的也被称为良定的。很奇怪的说法……良定……&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>有数学家表示应区别含幺环范畴 $\mathsf{Ring}$ 与不含幺的环范畴 $\mathsf{Rng}$，我觉得环应该含有乘法幺元，且应该省略元音字母 $\mathsf{i}$，所以写成这样。请根据上下文确定环范畴具体是什么样的含义。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>多相场模型与巨势方程</title><link>https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/</link><pubDate>Sun, 05 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/ShoujouRei_MikitoP.png" alt="Featured image of post 多相场模型与巨势方程" />&lt;p>&lt;em>记录一下目前使用到的两个相场模型，包括它们的推导，假设和缺陷&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://twitter.com/katorei_" target="_blank" rel="noopener"
>かとうれい&lt;/a> 太太， 为 &lt;a class="link" href="https://space.bilibili.com/108833238" target="_blank" rel="noopener"
>Mikito P&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/list/ml1197098078?spm_id_from=333.1007.0.0&amp;amp;oid=27304533&amp;amp;bvid=BV1Rs411N7Aq" target="_blank" rel="noopener"
>少女レイ&lt;/a> 的曲绘&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=1334077117" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="简介">简介
&lt;/h2>&lt;p>目前在做的 U-Nb 体系不连续析出的模拟，里面用到了这两个演化方程。之前一直没有仔细思考过这两个演化方程到底是什么来头，为什么这个体系适合使用这两个方程，导致现在想大概修改一下它们也无从下手。这里就作为笔记记录下这两个方程的推导方法，优缺点，以及我个人的一些看法吧。&lt;/p>
&lt;h2 id="多相场模型">多相场模型
&lt;/h2>&lt;h3 id="模型介绍">模型介绍
&lt;/h3>&lt;p>多相场模型（或者说是界面场模型，差不多吧）是适用于非保守场的演化方程，来自于 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
>I. Steinbach 和 F. Pezzolla 的文章&lt;/a>。它的形式为：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p>这里的 $F$ 是自由能泛函，$\tilde{N}$ 是有效序参量的个数，$\tilde{L}_{\alpha\beta}$ 是有效序参量里两相之间的界面移动参数，而括号内的差则是表示一种算符，即&lt;/p>
$$
\left(\frac{\delta }{\delta \phi_\beta} - \frac{\delta }{\delta \phi_\alpha} \right)F = \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha}.
$$&lt;p>简单来说，这篇文章考虑了使用界面场来描述不同相之间的界面并且演化，而非使用相自身的序参量作为演化参量。虽然最后还是会落到使用相自身的序参量来演化，但是界面场的思想融入到来这个演化模型中。最主要的改进应该是在考虑界面场的同时，考虑每个点处的有效序参量，也就是不为 0 的相的序参量，这样一来还可以简化计算（虽然实际计算过程中也可以只用传统的所有相的计算就是了）。&lt;/p>
&lt;p>平心而论，这篇文章写的逻辑结构并不是非常清晰，公式推导过程更是灾难，甚至符号都有一些问题，但是谁让这个模型好用呢？那就不多讲废话了，直接开始推导这个方程吧。要注意的是，这里的推导过程和作者的推导过程略有出入，同时也参考了 &lt;a class="link" href="https://doi.org/10.1016/j.commatsci.2023.112047" target="_blank" rel="noopener"
>Q. Huang et al 的这篇文章&lt;/a>。&lt;/p>
&lt;h3 id="模型推导">模型推导
&lt;/h3>&lt;p>对多相问题而言，我们引入一个约束：每个点上的所有序参量之和为一常数 1。即：&lt;/p>
$$
\sum_{\alpha = 1}^{N} \phi_\alpha = 1,
$$&lt;p>由于对时间求导的线性性，又有：&lt;/p>
$$
\sum_{\alpha = 1}^{N} \frac{\partial \phi_\alpha}{\partial t} = 0.
$$&lt;p>设我们现在已经有一个自由能泛函 $F[\{\phi\},\{\nabla\phi\}]$，其形式为：&lt;/p>
$$
F[\{\phi\},\{\nabla\phi\}] = \int_\Omega f\left(\{\phi\},\{\nabla\phi\}\right) \,\mathrm{d}\omega,
$$&lt;p>即我们写出了其能量密度形式。我们现在希望能把上面引入的约束进一步引入这个能量泛函内，因此我们使用 Lagrange 乘数法，引入 Lagrange 乘数 $\lambda$ 到自由能密度中，则有：&lt;/p>
$$
\begin{aligned}
l \left(\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right) &amp; = f\left(\left\{\phi \right\},\left\{\nabla\phi \right\}\right) - \lambda\left( \sum_{\alpha = 1}^{N} \phi_\alpha - 1 \right); \\
\mathcal{L}\left[\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right] &amp;= \int_\Omega l \,\mathrm{d}\omega.
\end{aligned}
$$&lt;p>然后我们令 $\mathcal{L}$ 对 $\phi_\alpha$ 做变分，得到：&lt;/p>
$$
\begin{aligned}
\frac{\delta \mathcal{L}}{\delta \phi_\alpha} &amp; = \frac{\partial l}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial l}{\partial \nabla \phi_\alpha} \\
&amp; = \frac{\partial f}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial f}{\partial \nabla \phi_\alpha} - \lambda \\
&amp; = \frac{\delta F}{\delta \phi_\alpha} - \lambda .
\end{aligned}
$$&lt;p>此时我们应用所谓的 “Relaxation Ansatz”，即这个变分导数值为 $\phi_\alpha$ 的演化速率，即：&lt;/p>
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta \mathcal{L}}{\delta \phi_\alpha}\\
&amp;= -\frac{\delta F}{\delta \phi_\alpha} + \lambda
\end{aligned}
$$&lt;p>则根据上面的约束条件，我们能解出 $\lambda$ 为：&lt;/p>
$$
\lambda = \frac{1}{N} \sum_{\alpha = 1}^{N} \frac{\delta F}{\delta \phi_\alpha}
$$&lt;p>此时将 $\lambda$ 带入应用 “Relaxation Ansatz” 后的变分结果中，得到：&lt;/p>
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta \neq \alpha} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= - \frac{1}{N} \sum_{\beta \neq \alpha} \left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F \\
\end{aligned}
$$&lt;p>最后，我们考虑到由于我们只考虑有效序参量，即不为 0 的序参量，这里的 $N$ 可以修改为 $\tilde{N}$；括号内属于对两相间的界面场的驱动力描述，对于不同的两相驱动力，驱动力大小应该是不同的，所以我们给驱动力前面乘以和两相相关的界面移动参数，$\tilde{L}_{\alpha\beta}$。这样一来结果为：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p>即我们的多相场模型。&lt;/p>
&lt;h3 id="模型解释">模型解释
&lt;/h3>&lt;p>上面的推导过程，在最后一步之前都是比较合理的。然而为什么最后能把 $\tilde{L}_{\alpha\beta}$ 硬生生塞进求和里面呢？也许只能通过物理的角度去尝试解释。这个公式在考虑 “Relaxation Ansatz” 时没有引入移动性的一些参数，比如经典 Allen-Cahn 方程里的移动性矩阵，也是为了方便公式推导，否则会陷入求和地狱，得到的 $\lambda$ 的值会变成：&lt;/p>
$$
\lambda = \frac{\sum_\alpha\sum_\beta{}L_{\alpha\beta}\frac{\delta F}{\delta \phi_\beta}}{\sum_\alpha\sum_\beta{}L_{\alpha\beta}},
$$&lt;p>带入公式后会得到：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = \frac{\sum_\beta{L_{\alpha\beta}}}{\sum_\xi\sum_\zeta L_{\xi\zeta}}{\sum_\xi\sum_{\zeta\neq\beta} L_{\xi\zeta}\left( \frac{\delta }{\delta \phi_\beta} -\frac{\delta }{\delta \phi_\zeta} \right)F}
$$&lt;p>虽然严谨，但是难以理解，而当考虑到这里的移动性参数可以直接集成在 $\tilde{L}_{\alpha\beta}$ 和 $\tilde{N}$ 后，整个式子都会变得更简洁，物理意义也更加明确。&lt;/p>
&lt;p>另外，在 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
>I. Steinbach 和 F. Pezzolla 的文章&lt;/a> 里，$\left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F$ 被解释为界面场 $\psi_{\alpha\beta}$，这也是为什么这个模型叫做界面场模型。而这篇文章中的推导过程里，如果考虑使用界面场进行推导的话，可以绕过求取 $\lambda$ 的显式表达，因为这个 $\lambda$ 对所有相都是相同的，而界面场这样差值的定义方式注定会消去 $\lambda$ 的影响。&lt;/p>
&lt;p>最后，我们指出，这个演化方程并没有对自由能 $F$ 做出任何的约束，因此该模型适用性非常广。事实上，多相场模型的应用极为广泛，经常可以在近年的相场模拟文章中见到。所以，尽管看起来这个模型的推导（在我看来，也许是我的问题）并不足够可靠，但是它很好用。是的，很好用。&lt;/p>
&lt;h2 id="巨势方程">巨势方程
&lt;/h2>&lt;h3 id="模型介绍-1">模型介绍
&lt;/h3>&lt;p>为了演化保守场变量，我们经常需要使用 Cahn-Hilliard 方程。然而，为了得到更好的结果，又或者当我们遇到了一些由演化方程引入的数值上的问题，我们也许需要对这个经典的方程做一些改变，就像上面的 Allen-Cahn 方程和多相场模型之间的关系一样。对于浓度这个最经典的变量而言，我们有总浓度场模型（考虑整个模拟域的浓度），相浓度场模型（考虑每个相内部的物质浓度），以及我们这里要介绍的巨势方程（演化模拟域内的化学势）。&lt;/p>
&lt;p>在介绍巨势方程具体的表达式之前，我们先来看一下所谓的“相浓度”和“总浓度”吧。我们知道，对于整个体系而言，其组分数量（元素）是固定的，而一个体系中可能有多个晶粒，而每个晶粒又可能分属不同的相。对不同的相而言，其成分很有可能是不同的。因此，一个组分的浓度在每个相内应该是不变的（不随位置变化），而在整个模拟域内会发生改变（随着相的不同而变化）。另外，浓度的改变是依赖于扩散势的，扩散势梯度会引导浓度进行变化，从高势处流向低势处。因此，相生长过程中浓度的变化可以认为是相浓度不同所导致的相之间扩散势不同所引发的。根据这一点，我们还可以通过演化模拟域内扩散势的变化来间接地模拟浓度的变化。这里我们要介绍的巨势方程，就是这么一个用来模拟扩散势变化的方程。&lt;/p>
&lt;p>巨势方程的表达式如下：&lt;/p>
$$
\frac{\partial \mu_i}{\partial t} = \left[\phi_\alpha \frac{\partial c_j^\alpha}{\partial \mu_i} \right]^{-1} \left( \nabla\cdot \bar{M}_{jk} \nabla\mu_k + R_j - c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \right).
$$&lt;p>我需要解释一下这个方程的记号。首先，和往常相似，$c$ 代表相浓度（即一个相内部的浓度），$\phi$ 代表相。此外，这个公式中的 $\mu$ 代表化学势（严格来讲是巨势，这也是这个方程名称的由来，但为方便理解我们就称为化学势），$M$ 代表浓度的移动性参数， $R$ 代表可能存在的浓度/物质源。再者，这个方程实际上使用了爱因斯坦求和约定，即如果一个乘积中一个指标出现了两次，那么就对这个指标求和。我们举个例子，比如方程右侧圆括号中的最后一项的记号代表的是：&lt;/p>
$$
c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \coloneqq \sum_{\alpha}^{N}c_j^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p>因此，上面的方程实际上是一个复杂求和。另外，记号中的 $i,j,k$ 都是用以标记元素（组分）的，我们设一共有 $K$ 个组分，所以独立组分一共有 $K-1$ 个（最后一个的量可以用 1 减去其余所有的组分的量），同时 $\alpha,\beta$ 等是用来标记相的，我们设一共有 $N$ 个相。根据我们的记号，上面的公式中如果有某个量没有重复指标（重复指标通常也称为哑指标，dummy index），则说明这个变量实则是代表了一个向量，这个向量根据指标的记号区别有 $N$ 或者 $K-1$ 个分量。而如果一个变量有两个指标，则说明这个变量实则是一个矩阵。我们后文记 $K-1$ 为 $\tilde{K}$ 以方便书写。&lt;/p>
&lt;p>最后我们要解释的是中括号和 $-1$ 的上标。这个记号是代表我们先以括号内的元素组成一个矩阵，然后对矩阵求逆。至此方程中的下标记号应该已经全部清晰明了了。&lt;/p>
&lt;h3 id="方程推导">方程推导
&lt;/h3>&lt;p>下面我们来尝试对这个方程进行推导。我们直接从 Cahn-Hilliard 方程出发：&lt;/p>
$$
\frac{\partial \tilde{c}_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \frac{\delta F}{\delta \tilde{c}_j} + R_i.
$$&lt;p>这里我们再次对记号做一些解释。这里我们先不使用爱因斯坦求和约定，方便解释方程内部发生了什么，另外这里的 $\tilde{c}_i$ 代表的是体系内的总浓度。我们加上了波浪线是为了强调是整个体系内的总浓度，方便和后面的相浓度做出区分。&lt;/p>
&lt;p>由于我们这里使用了总浓度，它实际上可以使用相浓度和相分数来表示：$\tilde c_i = \sum_\alpha^N \phi_\alpha c^\alpha_i$。另外我们知道，$\frac{\delta F}{\delta \tilde{c}_j}$ 实际上是表示的体系内化学势（巨势）。所以我们直接用 $\mu_j$ 来替代。这样就有：&lt;/p>
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p>现在我们把目光聚焦在等式左侧，因为等式右侧，可以看到，其实已经是最终结果的一部分了。对于等式左侧，首先对有限求和而言，求导的线性性保证了我们可以把求导和求和交换次序。然后我们考虑使用对乘积偏导（求导）的规则，则有：&lt;/p>
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \sum_\alpha^N\left(\phi_\alpha \frac{\partial c^\alpha_i}{\partial t} + c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} \right) = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p>我们考虑把求和拆开，把含有相分数对时间求偏导的部分挪到等式右侧，则有：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i - \sum_\alpha^N c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} .
$$&lt;p>接下来是比较关键的一步，我们考虑把浓度和化学势联系起来。即考虑相浓度作为化学势的函数：$c_i^\alpha = c_i^\alpha\left( \mu_1, \mu_2, \cdots, \mu_{\tilde{K}} \right)$。这样我们就可以使用求（偏）导的链式法则，有：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t},
$$&lt;p>然后考虑到对成分求和实际上与相无关，我们把对成分求和的求和号挪到最外面，这样就得到了：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p>我们先在这里暂停一下，回忆矩阵乘法的记号。设我们有两个矩阵，一个 $n\times m$ 矩阵 $A = \{a_{ij}\}$ 和一个 $m\times p$ 矩阵 $B = \{b_{jk}\}$，则它们的乘积矩阵 $C$ 应该是一个 $n \times p$ 矩阵，它的元素可以记为：$\sum_j^m a_{ij}b_{jk}$。另外，我们考察偏导 $\frac{\partial c^\alpha_i}{\partial \mu_k}$ ，这个偏导在当 $i$ 和 $k$ 都在 $\tilde{K}$ 个元素中取值时，实际上它组成了一个 $\tilde{K} \times \tilde{K}$ 矩阵中的元素。对应的，我们可以把 $\partial \mu_k$ 看作一个具有 $\tilde{K}$ 个分量的向量（或者 $\tilde{K} \times 1$ 的矩阵）。&lt;/p>
&lt;p>根据上面的内容，我们可以发现，实际上这里的求和可以写作两个矩阵的乘积（或者矩阵乘以一个向量）。至此我们采用爱因斯坦求和约定，则有：&lt;/p>
$$
\sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} \coloneqq \phi_\alpha\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p>我们把上面等式右边的三个因子做简单的区分，前两个因子的乘积实际上由于 $\alpha$ 指标重复的原因，代表了一个求和，而后又因为这个求和与第三个因子的 $k$ 指标重复，代表了矩阵的乘法。或者我们可以把 $\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}$ 理解为矩阵中的第 $\left( i,k \right)$ 个元素&lt;/p>
&lt;p>那么经过上面的说明，我们将等价变量依次带回，并对整个方程使用爱因斯坦求和约定重写，则有下面的结果：&lt;/p>
$$
\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p>现在我们可以将上式翻译为：一个 $\tilde{K} \times \tilde{K}$ 的矩阵 $\left\{\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k} \right\}$ 与一个 $\tilde{K} \times 1$ 矩阵 $\frac{\partial \mu_k}{\partial t}$ 相乘，得到的结果是三个 $\tilde{K} \times 1$ 矩阵相加。而我们希望的是能够得到演化体系扩散势变化的方程，这正好可以用 $\frac{\partial \mu_k}{\partial t}$ 来表示。所以我们的最后一步就是在等式两边同时左乘上这个 $\tilde{K} \times \tilde{K}$ 矩阵的逆矩阵，得到了：&lt;/p>
$$
\frac{\partial \mu_k}{\partial t} = \left[\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\right]^{-1}\left(\nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}\right).
$$&lt;p>也许你会发现这个式子和我们一开始给出的式子在下标上有差别。这个实际上是为了公式美观而改变了下标的排列顺序。只要保证公式内部的记号顺序一致，就可以保证公式，或者说矩阵乘法的逻辑顺序一致，因此我们这里得到的结果和上面给出的公式是没有本质区别的。&lt;/p>
&lt;h3 id="模型解释-1">模型解释
&lt;/h3>&lt;p>我知道，这里其实留了很多的坑，比如说什么是巨势方程里的“巨势”？巨势和化学势有什么关系？为什么非要用化学势/巨势来演化整个体系，用总浓度不好吗？相浓度不行吗？我们来一个个解释这些问题。&lt;/p>
&lt;p>首先，巨势是什么呢？我们知道，热力学中有很多不同的热力学函数，比如焓 $H$，熵 $S$，内能 $U$，吉布斯自由能 $G$，亥姆霍兹自由能 $F$ 等等。巨势，又称朗道自由能也是一种热力学函数，其表达式为：&lt;/p>
$$
\Omega \coloneqq F-\mu N = U-TS-\mu N,
$$&lt;p>其中 $F$ 是亥姆霍兹自由能，$U$ 是内能，$T$ 是体系温度，$S$ 是熵，$\mu$ 是化学势，$N$ 是体系内的粒子数。巨势的微分形式为：&lt;/p>
$$
\mathrm{d}\Omega = \mathrm{d}U-T\mathrm{d}S-S\mathrm{d}T-\mu\mathrm{d}N-N\mathrm{d}\mu = -P\mathrm{d}V-S\mathrm{d}T-N\mathrm{d}\mu.
$$&lt;p>巨势在体系达到热力学平衡的时候会取到最小值。当体系内的其余变量 $V$，$T$ 不变时，巨势的变化实际上就反映了化学势的变化。另外我们还可以从这个公式中得到浓度的表达方式：考虑将巨势除以体系的体积得到能量密度，此时 $N$ 将从体系内粒子数量变为体系内的粒子浓度/数密度 $\rho$。假设我们还得到了物质的原子体积 $V_a$，那么浓度 $c$ 就可以表达为：&lt;/p>
$$
c = V_a \rho = V_a \left(\frac{\partial \Omega}{\partial \mu}\right)_{V,T}.
$$&lt;p>据此，我们可以考虑将浓度表达为化学势的函数。这也是前述的浓度能对化学势求导的一个佐证吧。&lt;/p>
&lt;p>那么，为什么要用巨势方程呢？它对比总浓度或者相浓度有什么优势呢？我们考虑一个多元多相体系，每个相内部都有多种组元，在相内部这些组元的浓度是固定的，而相与相之间的组元浓度一般是不同的。当发生相变时，相内物质浓度可能会发生变化。在这个情况下，我们如果想演化整个体系的浓度分布情况，就不可避免地必须演化每个相的浓度分布。&lt;/p>
&lt;p>我们首先会想到使用相浓度去演化整个体系，这样再将相浓度和相分数相结合就可以得到整个体系内的浓度分布。这个方法从理论上讲很不错，但从实际处理过程中会发生一些数值问题：在相界面处，特别是相分数较小的情况下，不可避免的要用一个数去除以一个非常小的（接近于0）的数字。由于 Cahn-Hilliard 方程是直接对总浓度进行演化的，因此必须先从总浓度中拆分出相浓度才可以直接演化相浓度。从总浓度反推相浓度时，不可避免要处理在界面上的浓度分配，这时必须要借助某种假设来正确地把浓度分配到每个相中。一般采用的假设是假设界面上的每个点上，每个相的化学势都相等。根据这点，总浓度和相浓度的关系可以表达为：&lt;/p>
$$
c^i = \sum_\alpha\phi_\alpha c_\alpha^i
$$&lt;p>这里，相浓度前的 $\phi_\alpha$，相分数，就会引发问题。假设现在需要演化某个很靠近某个相内部的位置（或者说 $\phi_\alpha \approx 1$ 的区域），此时将会有很多别的相的相分数约等于 0。为了演化各自的相浓度，就需要把这个相分数除过去，此时由于计算机精度问题，很容易造成结果不稳定。&lt;/p>
&lt;p>那如果直接考虑总浓度呢？总浓度实际上就是最传统的 Cahn-Hilliard 方程，而为了求得相的演化速率，还是需要通过某种方式去推出每个相中的浓度分配问题。这样会增加过多的计算量：反求相浓度的过程实际上是解线性方程组问题。也就是说，使用相浓度，会遇到数值问题，使用总浓度，又会增加很多的计算量，到头来不过是和相浓度方法的先后顺序调换一下，在反求相浓度的时候依旧可能遇到数值问题。&lt;/p>
&lt;p>然而，使用扩散势时，这个问题被巧妙地隐藏到了偏导数中。这样相当于用某种方法绕过了这样的数值问题，保持了合理的计算开销。简单来说就是，又快又好。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>其实很不好意思地说，这篇内容实际上只是对这两个公式做了一些简单的推导，而后面的解释部分我自认为写的并不好。好像所有的解释最后都要归结到一个结论上：好用。这个点实际上在考虑纯理论时是没有什么用处的：我需要精准的理论来描述物理现象，结果你却告诉我 XXX 然后 YYY 最后得到这些东西，它的理论背景可能不够强，但是它好用就够了。我相信这样的解释是很难真正地打动某个人的心的。&lt;/p>
&lt;p>然而，好用其实就已经够了，因为这些理论到头来本就是为了能够帮助我们在某个假设的基础上能够更好地做模拟。在这里，这个基础假设可以说是 relaxation ansatz 以及等势假设。首先第一个假设能够让我们的体系从一个非平衡态&lt;em>演化&lt;/em>到平衡态，而不是只能直接地给出一个平衡态下的数量场，而第二个假设则能够解决相场法中界面上物质分配的问题，让演化能够得以在多相的情况下正常进行下去。这些假设，不论从过程还是结果来看，都是很有必要的。而除了这些假设外，（在不考虑我自己推导过程不够严谨的情况下，）推导过程都是尽可能严谨的。得到的结果，也正如上面所说，好用。&lt;/p>
&lt;p>上面这一大段，我希望能传达到的意思就是，这些公式已经在较少的叫宽松的假设的基础上用尽可能严谨的逻辑推导出了可用，好用的结果，那么作为使用这些公式的人来讲，它好用就够了，坚持实用主义也许是更实际的做法。当然了，阅读本段的您也可以认为是我对自己的推导过程没有什么自信的开脱就是了，嘿嘿嘿~&lt;/p>
&lt;p>那么最后，祝您生活愉快~&lt;/p></description></item><item><title>关于泛函导数和变分法-来自相场公式推导的问题</title><link>https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/HelloWorld-r-906.jpg" alt="Featured image of post 关于泛函导数和变分法-来自相场公式推导的问题" />&lt;p>&lt;em>本文系拾人牙慧之作，仅为解决公式推导过程中的一些边角料的数学问题，内容如有错漏还请谅解。另外，感谢老大中先生的《变分法基础》第三版。本文的主要内容几乎全部参考本书。&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://x.com/amn_amn_/status/1580863274081349632" target="_blank" rel="noopener"
>雨野&lt;/a> 太太，为 &lt;a class="link" href="https://twitter.com/arukuremu" target="_blank" rel="noopener"
>r-906&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1Ee4y1E7J6/" target="_blank" rel="noopener"
>Hello World!&lt;/a> 的曲绘&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=2076684514" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;p>2025.06.06 更新：感谢&lt;a class="link" href="https://github.com/which-is-my-way" target="_blank" rel="noopener"
>@which-is-my-way&lt;/a>指正，公式 &lt;a class="link" href="#modify" >16&lt;/a> 补上点乘单位法向量&lt;/p>
&lt;h2 id="晶体相场公式带来的问题">晶体相场公式带来的问题
&lt;/h2>&lt;p>在一个阳光明媚的晚上，师兄找到我问了一个问题：下面的这个相场公式是怎么组装起来的？具体来讲是：从下面的公式（2）和公式（3）是怎么得到公式（4）的：
&lt;/p>
$$
\begin{align}
F &amp;= \int_V f \mathrm{d}v\\ &amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \left( \omega\left( \nabla^2 \right) \psi + \psi^3 \right)+ \xi.
\end{align}
$$&lt;p>
这里我们做一些简单的背景介绍吧。这个公式来源于&lt;a class="link" href="https://doi.org/10.1103/PhysRevE.70.051605" target="_blank" rel="noopener"
>这篇文章&lt;/a>，是提出晶体相场理论的文章，其重要性不言而喻，近乎所有的该领域的文章在使用这篇文章的结果时都需要引用这些个公式。我们这里不对晶体相场做太多介绍了（因为我也不了解，虽然也有相场两个字，但是几乎只有最最基础的假设相似而已了），简单介绍一下这些公式（名称）这些方便后面表述。其中公式（1）是指体系总能量可以表达为能量密度对体积的积分（这里先不给出能量和能量密度的参量），这里可以看到总能量实际上是一个泛函；（2）是指能量密度的具体构造，（3）是和传统相场形式相类似的一个演化方程，在传统相场里是 &lt;em>Cahn-Hilliard&lt;/em> 方程。而（4）就是将（3）中的变分展开得到的结果，或者说是具体计算过程中使用的公式的显式表达。&lt;/p>
&lt;p>另外我必须提到的一点是，这里列出的公式并不完整，比如 $\omega$ 是什么我并没有做说明，这是为了复述一下我的心路历程（即便是笔记，也不希望太死板，毕竟是从实际问题来的）。当然，后面会把完整的问题复述，以及推导过程完整地列出来的。&lt;/p>
&lt;h2 id="传统相场公式对吗">传统相场公式，对吗？
&lt;/h2>&lt;p>拿到这个公式的时候其实并不是直接从文献拿到的，而是几张图片（大概就是公式（2）（3）和（4））。而我看到公式的第一反应是：这符号不是很对吧？把 $\psi$ 放到括号外面？这不太对吧？然后我便开始按照以往推导传统相场能量变分的方式推导了。我们来看看传统相场公式吧。
&lt;/p>
$$
\begin{align}
F(c, \nabla c ) &amp;= \int_{\Omega} f(c, \nabla c )\, \mathrm{d}\omega = \int_{\Omega} f_b(c, \eta) + \kappa_c \left| \nabla c \right|^2 \mathrm{d}\omega;\\
\frac{\partial c_i}{\partial t} &amp;= \nabla \cdot M_{ij} \nabla \frac{\delta F}{\delta c_j \left( r,t \right)},
\end{align}
$$&lt;p>
其中，公式（6）即为 Cahn-Hilliard 方程，而公式（5）则是传统相场中的总能构造的一种常见（最基础的）形式，其中 $f$ 是能量密度，$f_b$ 是体自由能密度。可以看到能量泛函是依赖于（?）浓度和浓度的梯度的。对这个公式的推导我们直接使用三维条件下的 Euler-Lagrange 方程：
&lt;/p>
$$
\begin{align}
\frac{\delta F\left[ x,y,y' \right]}{\delta x} = \frac{\partial f}{\partial x} - \nabla \cdot \frac{\partial f}{\partial \nabla x}.
\end{align}
$$&lt;p>
这样一来，这个公式就可以被展开了，只需要按照能量泛函的具体表达形式带入，然后求一下偏导，很快就会得到结果。&lt;/p>
&lt;p>说实话，这是在太棒了，只需要用很多现成（?）的内容，做一些非常简单（?）的推导，就（?）可以得到最后体系的演化方程具体表达形式。那心动不如行动，直接把这一套挪到上面的原始问题吧。很好，我们先对 $\psi$ 求偏导，得到（?）下面的东西：
&lt;/p>
$$
\frac{\partial f}{\partial \psi} = \frac{1}{2}\omega\left( \nabla^2 \right)\psi + \psi^3,
$$&lt;p>
然后，我们要对 $\nabla \psi$ 求偏导了。嗯，$\nabla \psi$ …… 但是这里是 $\nabla^2$ ？话说回来为什么要用 $\omega$ 带括号把 Laplacian 算子包起来呀？啊？&lt;/p>
&lt;p>这对吗？这不对吧？&lt;/p>
&lt;h2 id="重新审视问题omega-是什么">重新审视问题，$\omega$ 是什么？
&lt;/h2>&lt;p>问题看来根本不是我想得那么简单。还是需要从零开始一步步建立起这个问题的合理描述，并找到真正的解决方法。首先要解决的，就是 $\omega(\nabla^2)$ 这个奇怪的写法。假如这个写法是对的，那 $\omega$ 就不是什么参数之类的东西了，就应该是算符的一个函数或者别的什么东西了。&lt;/p>
&lt;p>找到原始文献，查看定义，我们得到了 $\omega$ 的真面目：
&lt;/p>
$$
\begin{align}
\omega (\nabla^2) = r + \left(1 + \nabla ^2\right)^2,
\end{align}
$$&lt;p>
其中的 $r$ 是一个复杂的常数，不用关心。果不其然。$\omega$ 应该解释为一个对 $\nabla^2$ 算子做一种变换得到的新的算子。或者说，它是把算子映射到算子的一个映射。太棒了，我们把这个结果带入公式（1）中的 $f$ 吧：
&lt;/p>
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\\
&amp;= \frac{\psi}{2} \left(r + \left(1 + \nabla ^2\right)^2 \right)\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p>
等一下，算子中的平方应该怎么解释？常数作用于一个变量应该怎么解释？根据算符的运算规则，我们得知：算符的平方，应该解释为算符作用于被作用量两次，而常数作用应解释为标量乘法。那么我们得到：
&lt;/p>
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \left(r\psi + \left(1 + \nabla ^2\right)^2\psi \right) + \frac{\psi^4}{4}\\
&amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \nabla^2\psi + \frac{1}{2}\psi\nabla^2\nabla^2\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p>
啊，看起来头好晕，怎么 Laplacian 也有个平方？我们更换符号：$\Delta = \nabla^2$，就有了：
&lt;/p>
$$
\begin{align}
f &amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{align}
$$&lt;p>
好了，这下我们搞清楚了 $\omega$ 到底是什么以及它对公式有何影响，现在我们对 $\psi$ 求的偏导应该就没问题了吧？&lt;/p>
&lt;p>等等，什么是 $\Delta\Delta\psi$ ？对 $\psi$ 求偏导的话要管它吗？就算不管这个东西，这个公式里没有熟悉的 $\nabla\psi$ 呀，那我们的能量密度对 $\nabla\psi$ 求偏导等于 0 ？这不太对吧？话说回来我们的总能量泛函到底依赖于什么变量？再等一下，依赖？对于一个泛函而言，我们只需要找到最符合要求的一个函数就好了呀？这个函数自然就可以通过对坐标求导得到自己的偏导数了，那偏导数就不应该是一个独立变量才对吧，我们对它做偏导数到底是为什么？&lt;/p>
&lt;p>完了，本来以为什么都知道，现在什么都不知道了。变分法，Euler-Lagrange 方程，这些都不应该是现成的吗？Laplacian，奇怪的 $\Delta\Delta\psi$，这些都不是能直接套到已有公式里的吧？&lt;/p>
&lt;h2 id="死胡同从头开始吧">死胡同？从头开始吧！
&lt;/h2>&lt;p>其实 $\Delta\Delta\psi$ 或多或少能想到是怎么个形式，无非就是把 $\Delta$ 作用两次就行了，关键在于这个变量，以及 $\Delta \psi$ 怎么参与到这个泛函构造中的，并且它们应该怎么参与到泛函导数里面。而为了搞清楚这个问题，我们也许必须明白这个泛函的“自变量”都有哪些，或者说，依赖于哪些变量，并且要搞清楚变量函数本身和它对位置的求导之间到底是有着什么样的关系。&lt;/p>
&lt;p>问题很多，我们干脆从头开始，一步步拆解吧，就从&lt;em>泛函是什么&lt;/em>这个问题开始。&lt;/p>
&lt;h3 id="泛函">泛函
&lt;/h3>&lt;p>我们讨论的泛函其实是一类特殊的映射，这个映射拥有定义域和陪域，其定义域为在某个空间上定义的全体函数组成的空间（比如，$\mathbb{R} \supseteq \Omega\to\mathbb{R}$ 的函数组成的空间，或者 $\mathbb{R}^3 \supseteq \Omega\to\mathbb{R}$ 的函数空间，根据我们的问题是几维的来确定这些函数的定义域），而泛函的陪域则是一个数域，对于能量而言我们就选择 $\mathbb{R}$ 好了。所以这个映射，从形式上来写，应该就是：&lt;/p>
$$
F:\left\{ y \;\Big|\; y: \Omega \to \mathbb{R} \right\} \to \mathbb{R}.
$$&lt;p>另外我们的泛函的另一个特殊之处在于，它常常可以写成这样一个积分的形式：&lt;/p>
$$
F = \int_\Omega f\, \mathrm{d}\omega.
$$&lt;p>我们常遇到的变分问题，也就是说在求什么样的函数 $\phi \in \left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 能够使得将之带入泛函 $F$ 时能让这个泛函取到最小值&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。甚至我们遇到的问题更加得特殊，因为我们要求函数族 $\left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 满足这样的条件：在区域边界 $\partial \Omega$ 上这些函数族内的函数都必须相等，或者换句话说，就是我们的问题是固定边界问题。&lt;/p>
&lt;p>太棒了，但是上面这些叙述，对我们的问题有什么帮助呢？我们把目光聚焦到泛函积分形式中的这个 $f$ 上。它没这里有具体的表达式，只是说明了要对它做积分。它具有什么样的意义呢？&lt;/p>
&lt;h3 id="被积函数泛函的核">被积函数（泛函的核）
&lt;/h3>&lt;p>我们这里指出：这个被积分的东西 $f$ 实际上是对泛函的要求。在部分文献中 $f$ 也称为泛函的核。$f$ 的具体表达形式，将会对最后得到的 $y$ 做出约束，使之满足泛函 $F$ 取到最小值的结果。那么，一个对 $y$ 的约束，要怎么表达它呢？或者说我们应该对 $y$ 做一些什么，来使之成为 $y$ 的约束呢？&lt;/p>
&lt;p>为了用 $f$ 来约束 $y$，我们考虑使用 $f$ 来描述 $y$ 的行为。$y$ 在什么情况下，会得到什么样子的结果，大概就是这样的方式去描述。而我们常常在描述 $y$ 的行为时，会考虑到它的导数的行为，将导数 $y'$ 和 $y$ 二者相互作用时得到的结果结合起来。最后考虑到我们描述 $y$ 时很难避免加入函数自变量 $x \in \Omega$，最后我们得到的 $f$ 就会变成这样的东西：它看起来像是一个关于 $x\in \Omega$，$y : \Omega \to \mathbb{R}$ 以及 $y' : \Omega \to \mathbb{R}^n$ 三个变量的函数（其中 $n$ 的取值取决于考虑的函数的定义域维数）。当存在更多高阶导数参与描述 $y$ 的行为时，这个函数 $f$ 所依赖的变量就更多了。在这个函数中，我们不考虑 $y$ 是和 $y'$ 或者更高阶的导数相关的，因为它们都独立地描述函数 $y$ 的行为。可以这样理解：$y'$ 对函数 $y$ 的约束作用是没法直接用 $y$ 自己或者 $x$ 自己单独去描述的，所以它的影响就应该是独立于 $y$ 和 $x$ 的。 这样一来，令 $f$ 对 $y$，$y'$ 等求偏导也是可以理解的了。另外，我们只关注对 $y$ 起实际约束作用的量，假如 $f$ 中不含有 $y'$，我们认为 $f$ 是不显含 $y'$ 的，此时并不是说 $y'$ 不存在了，而是它不参与到对 $y$ 的行为约束中。&lt;/p>
&lt;p>当我们想要求取得到的函数的定义域从一维上升到我们更常遇到的三维时，函数 $y$ 所依赖的变量也就更加复杂了，可能包括 $\nabla y$，$\nabla \cdot y$，$\nabla \cdot \nabla y$ 等等。和上面类似，我们依旧将这些处理为独立存在于 $f$ 中的变量。有了上面这些的铺垫，我们至少能让我们的问题变得更加清楚一些：问题中的能量形式，将其变量依赖状态完整地写出，应该是以下的形式（这里我们按照惯例将&lt;em>双调和算子&lt;/em> $\Delta\Delta$ 写成 $\Delta^2$ 的形式，它也可以写作 $\nabla^4$）：&lt;/p>
$$
\begin{align}
F\left[\psi\right] &amp;= \int_V f \left(\psi,\Delta\psi,\Delta\Delta\psi\right) \mathrm{d}v\\ &amp;= \int_V r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4} \mathrm{d}v.
\end{align}
$$&lt;h3 id="再考察-euler-lagrange-方程">再考察 Euler-Lagrange 方程
&lt;/h3>&lt;p>然而上面的一切似乎只是澄清了一些基本事实，并没有对解决这个问题起到非常实质的帮助呀。别灰心，至少我们知道了：上面的 Euler-Lagrange 方程，应该是只适用于 $f(x,y,\nabla y)$的，而对于新的 $f$，我们需要自己想办法得到这样的方程。因此，我们必须深入到变分法的根本，去了解变分法到底是怎么推导出了上面我们用到的 Euler-Lagrange 方程的。为此，我们采用我们一开始认为非常轻易地获得的 Euler-Lagrange 方程所对应的泛函形式来作为例子，自己推导一下它对应的 Euler-Lagrange 方程。&lt;/p>
&lt;p>回忆我们面对的变分法的一般问题：在什么样子的函数 $y$ 下，我们构造出的泛函能够取最小值。我们的函数 $y$ 的定义域是固定的，所以我们要关心的是这个符合要求的函数在每一个点处的值应该是什么样的。不妨假设我们已经有了一个最佳的函数满足要求了，称这个函数为 $\varphi$。此时，由于这个函数已经是最好的，最满足需求的函数了，任何对这个函数某个值的改变，都会让我们的泛函不能取最小值。&lt;/p>
&lt;p>我们来试着把这个结论写成更形式化一些的表达：假设函数 $\varphi : \Omega \to \mathbb{R}$ 是满足泛函 $F$ 的最小值需要的函数，则此时任意函数 $y \neq \varphi$ 都会造成这样的结果：$F[y] - F[\varphi] = \delta F > 0$ ，这里的 $\delta F$ 就是泛函 $F$ 的&lt;em>变分&lt;/em>。这里大于 0 是因为我们已经知道了 $F[\varphi]$ 是最小值。反过来讲，当 $\delta F = 0$ 的时候，就能说明此时的函数 $y$ 就是我们需要的函数 $\varphi$。&lt;/p>
&lt;p>这个表达是否让你感到一丝熟悉？我们先继续向下推进。&lt;/p>
&lt;p>可以看到，假如我们把这个不等式用我们之前熟悉的泛函的积分形式展开，并根据积分的线性性合并，得到的结果是：&lt;/p>
$$
\delta F = \int_\Omega f(x,y, \nabla y) - f(x,\varphi,\nabla\varphi) \mathrm{d} \,\omega = \int_\Omega \delta f\, \mathrm{d}\omega.
$$&lt;p>上面的第二个等号是我们把被积函数的差记为了这样对函数的全变分。这个积分不等式的被积分项里，变量 $x$ 没有什么变化，那我们干脆将 $f$ 在现在看作一个二元函数。我们把 $\varphi$ 改写为以 $y$ 为基础加上一个扰动的形式：$\varphi = y+\delta y$，那么我们可以模仿全微分那样，把这里对函数的全变分 $\delta f$ 做全微分式的处理，就可以根据它的两个变量的偏导来写出其全变分的表达式。带入上式，则有：&lt;/p>
$$
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega = \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\delta\nabla y \right) \, \mathrm{d}\omega.
$$&lt;p>这个形式已经是我们很熟悉的形式了，但是还有一些区别。这里我们指出，函数对向量求偏导得到的也是一个向量，所以这里需要用向量内积，其中的技术细节我们不多赘述，我们更关注的是：怎么把 $\delta \nabla y$ 写成别的形式，来进一步向我们的结果前进。注意到 $\nabla$ 是对坐标求导，而 $\delta$ 则是在保持定义域不发生改变的情况下，改变了函数的值。因此二者应该是相互独立的，也意味着两个算符是可以相交换的。再使用点乘的乘积律：$\nabla \cdot (f{\bf{}v}) = f\nabla\cdot{\bf v}+{\bf v}\cdot\nabla f$，这样一通操作，就得到：&lt;/p>
$$
\begin{align}
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega &amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\nabla\delta y \right) \, \mathrm{d}\omega \\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y - \nabla \cdot \frac{\partial f}{\partial \nabla y}\delta y \right) \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega .
\end{align}
$$&lt;p>而在式（13）中，最后的积分可以根据多元积分的 Green 公式，化成对区域 $\Omega$ 的边界 $\partial \Omega$ 积分。而此时，由于在边界上所有的函数的值都要相等，此时 $\delta y = 0$，这样最后一项积分就化为0了。我们写为下面的结果：&lt;/p>
&lt;span id="modify">
$$
\begin{align}
\delta F &amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_{\partial\Omega} \left(\frac{\partial f}{\partial \nabla y}\delta y\right)\cdot\hat{n} \, \mathrm{d}A\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega.
\end{align}
$$&lt;/span>
这样，我们就距离我们希望得到的形式，Euler-Lagrange 公式只差一步了。注意到这里使用的 $\delta y$ 是任意的，假如 $\delta F = 0$，从积分里的内容来看，只能是括号内的部分等于 0。
&lt;p>我们可以看到，上面的过程，可以分为大致四个部分：得到全变分形式，将非目标变分以变分和微分的交换律改写为目标函数变分，消去多余项，由变分任意性得到被积函数内部等于 0。我们因此，可以根据我们已经熟悉的函数导数的概念，将公式（18）中的被积函数括号内这个关键部分定义为泛函的导数，即：
&lt;/p>
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y},
$$&lt;p>
当其为 0 时，
&lt;/p>
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} = 0,
$$&lt;p>
泛函即取到极值（在我们的情境下即为最小值）。这就是所谓的 Euler-Lagrange 方程。&lt;/p>
&lt;h3 id="最后一步">最后一步
&lt;/h3>&lt;p>现在，我们对泛函的概念做了一些解释，并从头建立起了我们之前使用的 Euler-Lagrange 公式。这里我希望做一些补充说明。可以看到这里的泛函导数并不是直接的“某些东西的商然后做极限”，而是将某个对我们有用的部分定义为了泛函导数。对这个概念最佳的解释，就是它等于 0 时代表泛函的极值，通过解这个方程就能得到令泛函取得极值的极限函数。它不应被解释为变化率或者什么别的内容。&lt;/p>
&lt;p>另外，我们上面用到了“二元函数全微分”这样的类比。平心而论，我自己并不是特别能接受这种说法。另一个可行的解释是，将函数 $y$ 化为 $y = \varphi + \varepsilon\eta$，也就是说我们使用了一个任意函数 $\eta : \Omega \to \mathbb{R}$，让它乘上一个极小的量 $\varepsilon$，这样就相当于用 $\varepsilon\eta$ 形成了一个函数的扰动，即 $\delta y$。我们要求 $\eta$ 是一个任意的函数，而在任何计算过程中都保持 $\eta$ 不变。此时整个式子将会成为只关于 $\varepsilon$ 的一元函数了。对于一个一元函数，其极值点就会出现在导数等于 0 的位置。那么此时对 $\varepsilon$ 求偏导，也能得到和上面类似的结论，并且通过格林公式化简得到最后的结论。当然，这也只是另一种思路，仅供参考。&lt;/p>
&lt;p>最后要提出的是，上面的推导过程是和 $f$ 的表达式强相关的，尤其是其依赖的变量。然而当我们再考察其和变量之间的关系时，可以发现每个变量实际上对应到最后的 Euler-Lagrange 公式中都是相对独立的。比如，$x$ 这个部分没有在公式中出现，$y$ 的部分对应对 $y$ 求偏导，而 $\nabla y$ 的部分则对应着对 $\nabla y$ 求偏导后再对结果做散度。这个结果是可以预想到的：由于全微分公式，或者换成泛函的语境，全变分公式，的性质，是会出现这样的结果。那么我们也自然可以预想到，假如 $f$ 依赖的变量是别的变量，也应该有类似的结论才对。&lt;/p>
&lt;p>到这里，我们近乎完全搞通了我们最后想要解决问题的路径。我们已经得到了泛函具体的表达式，搞清楚了泛函的核（即那个被积函数 $f$）的参数表，得到了对泛函做变分法的具体思路。我们的下一步，或者最后一步，便是真的带进去算了。&lt;/p>
&lt;h2 id="计算">计算！
&lt;/h2>&lt;p>为了读者的精神健康，我们隐藏当 $f$ 依赖情况为 $f(p,\psi,\Delta \psi,\Delta\Delta \psi)$ （其中 $p \in V$ 代表位置）时的 Euler-Lagrange 公式的推导，直接给出结果：&lt;/p>
$$
\begin{equation}
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right)
\end{equation}
$$&lt;details>
&lt;summary>如果你愿意看推导过程的话：&lt;/summary>
&lt;p>不，你其实不想看，你只是好奇我到底有没有真的写这些推导过程。事实是：写了，下面就是。&lt;/p>
&lt;p>但是如果你真的想看这个部分，谢谢你，我的努力没有白费。&lt;/p>
&lt;p>我们先根据全变分，写出泛函的核函数变分后的结果：&lt;/p>
$$
\begin{align*}
\delta F &amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \int_V \delta f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; =\int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v. \\
\end{align*}
$$&lt;p>接下来我们分别考察被积分的每一项。其中第一项的对 $\psi$ 的变分 $\delta\psi$ 已经符合我们的要求了，第二项中的 $\delta \Delta \psi$ 和第三项中的 $\delta \Delta\Delta\psi$ 则需要我们处理为某个函数乘以 $\delta\psi$ 的形式，以便于最后的逻辑处理。&lt;/p>
&lt;p>根据变分与求导和交换的关系，我们有：&lt;/p>
$$
\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi = \left(\frac{\partial f}{\partial \Delta\psi}\right)\Delta \delta \psi = f_1 \Delta\delta\psi;\\
\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi = \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right) \Delta\Delta\delta\psi = f_2\Delta\Delta\delta\psi,
$$&lt;p>其中每行公式的第二个等号都是为了护眼做的处理，即将括号中的偏微分用记号表示。我们先看上面第一个式子，这是两个标量函数的乘积，其第二个因式展开应为:&lt;/p>
$$
\Delta \delta \psi = \nabla \cdot \nabla \delta\psi,
$$&lt;p>注意到散度存在恒等式：$\nabla \cdot (f\mathbf{v}) = f\nabla\cdot\mathbf{v} + \nabla f \cdot \mathbf{v}$，其中 $f$ 为标量函数或标量场， $v$ 为向量值函数或向量场，我们可以对上面的结果变换得到：&lt;/p>
$$
\begin{align*}
f_1\nabla \cdot \nabla \delta\psi &amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla f_1\cdot \nabla\delta\psi \\
&amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla\cdot(\delta\psi\nabla f_1) + \delta \psi \nabla\cdot\nabla f_1.
\end{align*}
$$&lt;p>上式对一个三维区域 $\Omega$ 的积分，根据散度定理，有：&lt;/p>
$$
\begin{align*}
\int_V f_1 \nabla\cdot\nabla\delta\psi \,\mathrm{d}v &amp;= \int_V \nabla\cdot(f_1\nabla\delta\psi)\,\mathrm{d}v -\int_V \nabla\cdot(\delta\psi\nabla f_1) \,\mathrm{d}v+\int_V \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v \\
&amp;=\int_{\partial V} f_1\nabla\delta\psi\cdot\hat{n}\,\mathrm{d}s - \int_{\partial V} \delta\psi\nabla f_1\cdot\hat{n} \,\mathrm{d}s + \int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v\\
&amp;=\int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v.
\end{align*}
$$&lt;p>上式第二个等号使用了散度定理，第三个等号则是考虑到在边界处 $\delta\psi = 0$，$\nabla\delta\psi = \mathbf{0}$。这样我们就得到了原变分中被积函数第二项的表达形式。我们现在考虑其中的第三项，即 $f_2\Delta\Delta\delta\psi$。我们先将其中的 $\Delta\delta\psi$ 看作函数标量函数 $\varphi$，则原式写为 $f_2\Delta\varphi$。此时，套用我们上面已经得到的结果，有：&lt;/p>
$$
\begin{align*}
\int_V f_2 \Delta\Delta\delta\psi \,\mathrm{d}v &amp;= \int_V f_2 \Delta\varphi \,\mathrm{d}v\\
&amp;= \int_{\partial V} f_2\nabla\varphi\cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \varphi\nabla f_2\cdot\hat{n} \,\mathrm{d}s+\int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v \\
&amp;= \int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v = \int_V \varphi \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \Delta\delta\psi \Delta f_2 \,\mathrm{d}v = \int_V \nabla\cdot\nabla\delta\psi\, \Delta f_2 \,\mathrm{d}v\\
&amp;= \int_{\partial V} \Delta f_2\nabla\delta\psi \cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \delta\psi\,\nabla (\Delta f_2)\cdot\hat{n} \,\mathrm{d}s+\int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v,
\end{align*}
$$&lt;p>其中所有的操作与前面是一样的，不断用恒等式拆开，然后由于在边界上的包含 $\delta\psi$ 的项全部归零，所有对 $V$ 的边界 $\partial V$ 的积分都会变成 0，最后就得到了我们想要的结果。我们把这些积分再合起来，将为了方便所做的记号带回，就有：&lt;/p>
$$
\begin{align*}
\delta F &amp; = \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v \\
&amp;= \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \psi
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \psi \,\mathrm{d}v \\
&amp;= \int_V \left(\left(\frac{\partial f}{\partial \psi}\right)
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\right)\delta \psi \,\mathrm{d}v.
\end{align*}
$$&lt;p>那么，由泛函导数的定义，我们就得到了 Euler-Lagrange 方程：
&lt;/p>
$$
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right).
$$&lt;/details>
&lt;p>现在,我们来把式子带进去吧。为了方便，我们先把公式待带入的公式写在下面：&lt;/p>
$$
\begin{align}
F[\psi] &amp;= \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \mathrm{d}v\\
&amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\omega (\nabla^2) &amp;= r + \left(1 + \nabla ^2\right)^2;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi.\\
\end{align}
$$&lt;p>我们的目的也就是将公式（21）先带入公式（20）得到能量的具体表达形式，然后将得到的结果带入公式（18）来计算能量变分，最后得到公式（22）的显式表达。其中第一步已经完成了，能量密度的具体表达形式为：&lt;/p>
$$
\begin{equation}
f = r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{equation}
$$&lt;p>我们先对公式（23）计算需要的这些偏导数，得到：&lt;/p>
$$
\begin{align}
\frac{\partial f}{\partial \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3;\\
\frac{\partial f}{\partial \Delta \psi} &amp;= \psi;\\
\frac{\partial f}{\partial \Delta\Delta \psi} &amp;=\frac{1}{2}\psi.
\end{align}
$$&lt;p>现在把这些得到的结果，即公式（24-26）带入到我们得到的 Euler-Lagrange 方程（18）中。注意在前面加上对应的 Laplace 算子或者双调和算子。得到的结果为：&lt;/p>
$$
\begin{align}
\frac{\delta F}{\delta \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3 + \Delta\psi+\frac{1}{2}\Delta\Delta\psi \\
&amp;=r\psi + \psi + 2\Delta\psi + \Delta\Delta\psi+\psi^3\\
&amp;=\left(r + \left(1 + 2\Delta + \Delta\Delta\right)\right)\psi+\psi^3\\
&amp;=\omega(\Delta)\psi + \psi^3.\\
\end{align}
$$&lt;p>那么最后，把式（30）带回到式（22）中。此时我们尊重原文，把符号统一，将 $\Delta$ 重写回 $\nabla^2$，就有：&lt;/p>
$$
\begin{equation}
\frac{\partial \psi}{\partial t} = \nabla^2 \left(\omega(\nabla^2)\psi + \psi^3\right) + \xi.
\end{equation}
$$&lt;p>这就是我们一开始的目标，式（4）。&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>其实这个问题一开始就很清楚：只要找到正确的 Euler-Lagrange 公式，带入无脑计算就行了。但是如何找到正确的 Euler-Lagrange 公式则是一个比较棘手的问题。本文的思路启发自老大中先生的《变分法基础》，翻开书，几乎所有的笔墨全都放在了如何去根据泛函的形式来推导出对应的 Euler-Lagrange 方程上。所幸，我们的这个方程形式非常简单，且答案几乎是现成的，只需要找到正确的位置后取用即可。&lt;/p>
&lt;p>那么这篇文章前面的部分有什么用呢？像跳梁小丑一样跳来跳去，最后发现从一开始就不对劲，转而从头开始推导整个公式。如果一开始就找到这个合适的公式，不就好了吗？也许能够找到这个合适的公式确实能立马解决眼前的问题，但是以后呢？如果遇到了一个形式又不太一样的泛函，此时应该怎么推导出其对应的 Euler-Lagrange 方程呢？而且从文章前半部分可以看到：我对变分法的理解，在推导出这个公式以前，是有问题的。我机械地认为就是带入那个人尽皆知的 Euler-Lagrange 方程，然后算算算就好了。旋即就遇到了第一个问题：怎么让 Laplacian 对梯度求导。是的，我当时并不怀疑是公式问题，而是考虑怎么让这个公式能算下去。在网上搜索一段时间之后，我貌似得到了结果，但总归不太满意，因为带入后得不到最后的公式。&lt;/p>
&lt;p>一段迷茫过后，我突然对变量之间的依赖情况产生了疑惑。网上搜寻的结果表明，不能单纯地看作相互关联的变量，或者说单纯的求导关系。最后我得到了上文中的解释，也许我在这部分的解释是错误的，但我用这个方法说服了自己。希望这个观点没有问题。顺带，我得到这个解释或多或少受到了热力学的启发：热力学中的偏导数必须标明哪些变量是固定不变的，这时因为热力学参数张成了一个高维空间，而体系的热力学状态则是这个空间上的一个超平面，热力学状态函数则是这个超平面上定义的场。因此，对热力学状态函数求偏导的时候必须固定求导方向，也就是固定某些变量不变。也许是这样的理解让我将泛函的核理解为了对函数的约束（我也不知道怎么联系上去的，所以说只可谓之&lt;em>启发&lt;/em>）。&lt;/p>
&lt;p>然而即便如此，我依旧没法得到最后最关键的公式。此时只能从头开始一步步推导 Euler-Lagrange 公式了。所幸，我找到了老大中先生的这本书，读过一部分之后，遍跳着找到了我需要的答案。感谢这本书，让我少走了不知道多少弯路。&lt;/p>
&lt;p>最后，感谢您能阅读到这里，看这么久的流水账也挺辛苦的。希望这篇流水账一样的文章也能帮助正在阅读的你增进对 Euler-Lagrange 公式和变分法或者泛函导数的理解。&lt;/p>
&lt;p>那么，祝您生活愉快~&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>请容许我这里混淆最小值和极小值，以及最值和极值，因为我们默认需要这个泛函取到的是极小的部分，且这个极小值一定是全局的，即最小值。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>