<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software on A Moment's Rest</title><link>https://a-moment096.github.io/tags/software/</link><description>Recent content in Software on A Moment's Rest</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Jul 2025 18:05:20 +0800</lastBuildDate><atom:link href="https://a-moment096.github.io/tags/software/index.xml" rel="self" type="application/rss+xml"/><item><title>安装 Arch Linux，但是笔记本物理机</title><link>https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/</link><pubDate>Fri, 02 May 2025 16:12:04 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/imgs/Alice.png" alt="Featured image of post 安装 Arch Linux，但是笔记本物理机" />&lt;p>&lt;em>之前在虚拟机上面装的 Arch Linux 根本不过瘾（搞笑，你根本就没更完(❌)），这次就把自己的小轻薄改成 Arch 好了。顺带，也记录一下实体机上安装可能会遇到的坑？&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 R Sound Design 的新曲 《アリス？》，一首很轻快的 V曲~&lt;/em>&lt;/p>
&lt;!--
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=750876" theme="#2980b9" loop="none">&lt;/meting-js> -->
&lt;p>&lt;em>很可惜 网易云/QQ音乐 都暂时没有这首歌，所以只能劳驾移步B站欣赏了。一旦有更新就会贴在这里的&lt;/em>&lt;/p>
&lt;p>&lt;em>B站&lt;a class="link" href="https://www.bilibili.com/video/BV1UtV5zqEjC/" target="_blank" rel="noopener"
>投稿&lt;/a>&lt;/em>&lt;/p>
&lt;h2 id="引子我好急怎么耗电这么大">引子：我好急，怎么耗电这么大
&lt;/h2>&lt;blockquote>
&lt;p>亲爱的笔记本：&lt;/p>
&lt;p style="text-indent: 50px">插电如面，自从我们相逢已有一年有余。上次见面，仿佛还是上次。传统派的我那时我刚刚给你刷上 Windows 10 系统，因为 Windows 11 的审美实在是在狠狠强碱我的眼睛。我们一路克服了艰难险阻，安装了各种乱七八糟的驱动，最后终于是让你成功跑了起来。虽然你的内存不大，硬盘不多，CPU 一般，显卡集成，但你要相信我，我心里面是有你的。&lt;/p>
&lt;p style="text-indent: 50px">然而，你身上的 Windows 10 虽然让我倍感熟悉，你的耗电量实在是高得吓人。我接受不了一旦不插电就几乎是和时间赛跑的工作流。我将这一切归咎于可恶的微软，可恶的 Windows 10。这不是你的错，但是我还是想告诉你：你马上就会搭载一个新的系统。她轻便灵巧的同时，又大胆火辣，相信你一定会和她打成一片的。&lt;/p>
&lt;p align="right">Love, &lt;/p>
&lt;p align="right">A Moment&lt;/p>&lt;/blockquote>
&lt;p>美丽的五一假期，不折腾点狠活儿实在是说不过去。看着越来越不顺眼的 Windows 10 笔记本，以及我的心逐渐被 Linux（特指 Arch Linux）所俘获，我决定：干掉 Windows 10, 彻底迎接 Arch Linux。想必有了之前安装 Arch Linux 的经验，这次的安装之旅肯定是一马平川了。开始吧。&lt;/p>
&lt;h2 id="准备资料备份以及准备启动盘">准备：资料备份以及准备启动盘
&lt;/h2>&lt;p>首先肯定是先把电脑上已有的资料都备份好。其实说实话没太多文件，主要是两个没打完的 Gal 吧（心虚），因为大部分的文件都其实已经搞到台式机上面了。一开始是想着把这些文件放在一块精心规划的小硬盘上，安装的时候不格式化就行了，但是感觉还是有点点点点危险，所以干脆还是挪到另一台机器上，把这台小本的硬盘全部格式化了得了。不过也许我应该考虑更加智能的备份方案？算了，以后再考虑（挖坑）。&lt;/p>
&lt;p>其次就是准备启动盘。本来这次想要换一种安装媒介来着，比如光盘？（没错我有光盘刻录机，为了听 CD 买的 ()），结果还是嫌麻烦，放弃了。给虚拟机安装的时候不是已经有了镜像了吗？为什么不直接用呢？至于为什么没有下载最新的（最新的就是昨天刚出的，5月1日版本），是因为我刚准备下载的时候看到最上面一行小字：&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/imgs/no_need_for_download.png"
width="1277"
height="133"
srcset="https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/imgs/no_need_for_download_hu_7fda391d774b472e.png 480w, https://a-moment096.github.io/p/%E5%AE%89%E8%A3%85-arch-linux%E4%BD%86%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%89%A9%E7%90%86%E6%9C%BA/imgs/no_need_for_download_hu_d075c299b95d14fd.png 1024w"
loading="lazy"
alt="安装好再更新不挺好？（滚挂警告）"
class="gallery-image"
data-flex-grow="960"
data-flex-basis="2304px"
>&lt;/p>
&lt;p>So, why not?&lt;/p>
&lt;p>镜像依旧是用 &lt;code>rufus&lt;/code> 烧录到陪伴了我6+年的小U盘上，什么格式化之类的 &lt;code>rufus&lt;/code> 会自动帮我搞好的。中间有个小插曲好像是 &lt;code>rufus&lt;/code> 不太支持最新的 syslinux 版本，需要额外下载两个小库。无所谓（）我选择相信。&lt;/p>
&lt;p>到这里，基本上就已经准备好安装工作了。相信根据这些东西，来个老手估计三下五除二就安装好整个系统了。当然，我是新手，还是一步步来吧。这大概也是这篇（以及上一篇）文章的目的：记录自己安装系统时蠢蠢的样子。&lt;/p>
&lt;h2 id="开始启动安装引导咯">开始：启动安装引导咯~
&lt;/h2>&lt;h3 id="先进安装引导再说吧">先进安装引导再说吧
&lt;/h3>&lt;p>激动的心，颤抖的手，插入U盘后从U盘启动会不会有？&lt;/p>
&lt;p>太坏了，secure boot 没关，没有。上网搜索我的笔记本的 BIOS 设置方法，Redmi Book 14 需要开机后按下 F2 进入 BIOS，然后在启动设置里 &lt;strong>先设置管理员密码&lt;/strong> 之后才能设置是否关闭安全启动。有一点点脱裤子放屁的感觉……算了。总之就是进来了，进到安装引导了。这下真是激动的心，颤抖的手了。&lt;/p>
&lt;p>（由于屏幕反光，就不拍屏了，其实和上次的屏幕一模一样咯）&lt;/p>
&lt;p>这次就得格外小心了：这可不是虚拟机。虽然说搞砸了也能重来（电脑上没什么别的重要文件了，打算全部格式化），但是一想到是实体机，还是有一些些的紧张。&lt;/p>
&lt;p>&lt;del>其实这篇文章是在我进来安装引导之后才开始动笔写的。一开始没打算写来着，不过鉴于好久没有更新博客了，还是水一篇吧（）&lt;/del>&lt;/p>
&lt;h3 id="还是先进行前期验证和网络配置">还是先进行前期验证和网络配置
&lt;/h3>&lt;p>这次由于有上次安装的记录，所以其实可以直接参考以前写的那个东西。感谢代码高亮，我立马就敲下了 &lt;code>localectl list-keymaps&lt;/code>。然而：没什么卵用。Bro，你就用的是美式键盘呀！？还列出来看个der呀……算了，不管了。不过验证启动模式也许还是有必要的？依旧，&lt;code>cat /sys/firmware/efi/fw_platform_size&lt;/code>，结果是&lt;code>64&lt;/code>。这个应该是说我的启动模式的系统是64位的吧？&lt;/p>
&lt;p>随后是验证网络。这步我其实是有点心虚来着，会不会这个安装引导不支持我的电脑网卡？害怕。但还是先试一试吧。&lt;/p>
&lt;p>从结果来看，我有一个 &lt;code>lo&lt;/code>，&lt;em>virtual loopback interface&lt;/em>，不管；一个 &lt;code>wlan0&lt;/code>，看来是认出我的无线网卡了，好耶。然而它的 &lt;code>state&lt;/code> 是 &lt;strong>DOWN&lt;/strong>，emmm……&lt;/p>
&lt;p>（找找办法……）&lt;/p>
&lt;p>太愚蠢了，&lt;strong>DOWN&lt;/strong>不就是说我没连上网嘛…… 不过根据 ArchWiki，还是先用 &lt;code>rfkill&lt;/code> 命令检查我的无线网卡是不是被 &lt;em>block&lt;/em> 了（屏蔽？也许？），好消息是没有；接着就使用 &lt;code>iwctl&lt;/code> 工具进行联网。这个步骤我感觉有一点点繁琐，先要在交互界面使用 &lt;code>device list&lt;/code> 列出设备，很幸运我这里是直接 &lt;code>wlan0 powered on&lt;/code> 状态，这里的 &lt;code>wlan0&lt;/code> 就是我的设备名了；接着就用 &lt;code>station wlan0 scan&lt;/code> 扫描可用网络，然后用 &lt;code>station wlan0 get-networks&lt;/code> 列出可用网络。这里有个很神奇的点：能连上我的校园网吗？用 &lt;code>station wlan0 connect CSU-WIFI&lt;/code> 试试。这里 &lt;code>CSU-WIFI&lt;/code> 就是我们的校园网了。好消息是成功了，不知道怎么做到的。本身链接我们学校校园网是需要使用一个网页进行验证的，不过也许是因为我在 Windows 系统上刚刚连过一次网络，所以成功重连上了？不清楚，不过也算可喜可贺。最后在用 &lt;code>exit&lt;/code> 退出 &lt;code>iwctl&lt;/code> 的交互界面后再 &lt;code>ip link&lt;/code> 一下检查是否连上：没问题。绿色的 &lt;code>UP&lt;/code> 真好看，诶嘿。&lt;/p>
&lt;p>动态IP应该是自动配置的（ArchWiki讲是 &lt;em>out of box&lt;/em>），所以不管。也许后面我会想搞个静态的？唉，不懂网络真头痛呀。不管不管。直接 &lt;code>ping archlinux.org&lt;/code> 试试。&lt;/p>
&lt;p>烂了，没有数据返回。烂完了。&lt;/p>
&lt;p>（找找办法x2……）&lt;/p>
&lt;p>顺从。又不是没有别的 WIFI 能用。直接连上办公室 WIFI好了。当然，这里也贴一下我参考了的连接校园网的方法的博文：&lt;a class="link" href="https://www.cnblogs.com/holaworld/p/17839616.html" target="_blank" rel="noopener"
>链接1&lt;/a> 以及 &lt;a class="link" href="https://www.bilibili.com/opus/852262124483772422" target="_blank" rel="noopener"
>链接2&lt;/a>。&lt;/p>
&lt;p>最后网络这里还有要设置一下系统时间。用 &lt;code>timedatectl&lt;/code> 就可以。 感谢 &lt;code>zsh&lt;/code> 和这些工具带上的自动补全，&lt;code>timedatectl --help&lt;/code> 一下，跟着感觉走，最后就得到了 &lt;code>timedatectl set-timezone Asia/Shanghai&lt;/code> 了。相当简单。&lt;/p>
&lt;h3 id="再见我的旧文件们">再见，我的（旧）文件们
&lt;/h3>&lt;p>又到了每次装系统最喜欢也最提心吊胆的磁盘分区了。总有一种破后而立的感觉，感觉在磁盘格式化之后，这台电脑就变成全新的了诶。还是一样，&lt;code>fdisk -l&lt;/code> 列一下可用分区。一下出来了一堆呀，删了删了，全部删了。&lt;/p>
&lt;p>又看到一次我的硬盘大小，只有 476.94 GiB，Sad。不过，轻薄本，出差顺带干活用的，无所谓了吧？后面再考虑加容量之类的吧，也许还可以考虑直接换台新本（好奢侈（））。&lt;/p>
&lt;p>开始分区吧，直接 &lt;code>fdisk /dev/nvme0n1&lt;/code> 进入交互模式 （这里我的硬盘只有一个，就是在 &lt;code>fdisk -l&lt;/code> 里列出的 &lt;code>/dev/nvme0n1&lt;/code>，所以就把它传入参数就好）。由于硬盘太小，我也对文件管理没有什么特别多的想法，干脆就是一个 &lt;code>SWAP&lt;/code> 一个 &lt;code>/&lt;/code> 好了。至于分区表，依旧选用 GPT 分区表。貌似 GPT 的功能更加强大？已经完全超越了老旧的 MBR？其实按理来说我应该先多了解一下这些东西再下判断来着，不过这里就还是先相信互联网吧（）&lt;/p>
&lt;p>这里搞了个大乌龙：我不小心把启动盘 &lt;code>/dev/sda&lt;/code> 给分区了。有一说一，挺愚蠢的……目前先这么搞吧，安装引导也没断，后面不碰它应该就没问题，吧？下次还是要注意：根据 ArchWiki 上的指导，实际上应该先将分区表进行备份才对，命令是 &lt;code>sfdisk -d /dev/sda &amp;gt; sda.dump&lt;/code>（这里 &lt;code>/dev/sda&lt;/code> 是要备份分区表的硬盘）。下次一定注意，唉。&lt;/p>
&lt;p>接下来就是使用 &lt;code>mkfs&lt;/code> 等进行文件系统格式化了。这里很多人推荐 &lt;code>Btrfs&lt;/code>，所谓的 &lt;em>B Tree File System&lt;/em>（我一开始以为是 &lt;em>Better File System&lt;/em> 来着），因为它貌似是支持自动压缩和别的一些高级功能，还有快照之类，很方便个人用户使用。这次就不用传统的 &lt;code>ext4&lt;/code> 了，尝尝鲜。使用命令 &lt;code>mkfs.btrfs /dev/nvme0n1p1&lt;/code> 就可以把第一个分区格式化为 Btrfs 格式了。我还留了一个分区作为 Swap 使用，大小设置为了8G。要创建 Swap 分区只需要 &lt;code>mkswap /dev/nvme0n1p2&lt;/code> 即可。&lt;/p>
&lt;p>分好了区，就需要挂载文件系统了。用 &lt;code>mount /dev/nvme0n1p1 /mnt&lt;/code> 就可以。Swap 则使用 &lt;code>swapon /dev/nvme0n1p2&lt;/code> 就行了。这样一来，我们就在硬盘上做好了准备，马上就要把 Arch Linux 安装在这个临时挂载于 &lt;code>/mnt&lt;/code> 的主硬盘了。&lt;/p>
&lt;h2 id="安装冲刺冲刺冲刺">安装：冲刺！冲刺！冲刺！
&lt;/h2>&lt;p>Arch Linux 的灵魂之一也许就是 &lt;code>pacman&lt;/code> 包管理器了。安装 Arch Linux 实际上也是使用 Pacman 进行的。因此首先就是对 Pacman 进行必要的配置。&lt;/p>
&lt;p>首先还是要选择镜像，可选的镜像站放在了 &lt;code>/etc/pacman.d/mirrorlist&lt;/code> 里。这里直接借鉴上次安装的经验好了，使用 &lt;code>reflector --latest 10 --sort rate&lt;/code> 来排出最快的10个服务器。结果出来之后可以考虑在这条命令的后面加上 &lt;code>--save /etc/pacman.d/mirrorlist&lt;/code> 来保存下来。当然，在这之前（吸取刚刚的教训）我把原文件复制了一份作为备份。&lt;/p>
&lt;p>下来就是安装必要的包，命令为 &lt;code>pacstrap -K /mnt base linux linux-firmware&lt;/code>。这里的 &lt;code>-K&lt;/code> 是指在目标处生成一空的 密钥环。（至于密钥环是什么，对不起，我不知道。后面会学的（））&lt;/p>
&lt;p>经过漫长的等待，我的安装它：报错了。先是安装的特别慢，可能是因为源的问题吧，我还是尝试了 &lt;code>reflector --country China --age 12 --sort rate&lt;/code> 这个命令获取了国内的镜像源；后面是变快了，但是突然又报 &lt;em>error: GPGME error: No data&lt;/em>，不管我怎么操作 &lt;code>pacman&lt;/code>，都没有用。我估计是密钥环之类的东西坏掉了吧，看来是前面对U盘瞎JB分区导致的。这下只能关机拔掉U盘，重新烧录，格式化电脑硬盘然后重新安装。好在这次安装地很快，这个插曲也算是过去了吧。&lt;/p>
&lt;p>现在安装的应该是一些最最基础的软件包。为了安装好后有一些别的功能能用（比如联网），还是需要再安装一些别的软件包。这里我计划是安装 &lt;code>vim&lt;/code> ，&lt;code>dhcpcd&lt;/code> 以及 &lt;code>networkmanager&lt;/code>。不过这些就等到之后 &lt;code>chroot&lt;/code> 后再搞吧。&lt;/p>
&lt;p>(安装中……)&lt;/p>
&lt;hr>
&lt;p>&lt;em>我们就当这个傻孩子搞了一通之后算是安装好了吧，其实中间应该还有一些插曲，然而他安装好之后真的一路冲刺，就安装完了抱回宿舍继续折腾了。等他再想起来写这个博客的时候已经过了10天了。原谅他吧，好多细节他也记不清了。&lt;/em>&lt;/p>
&lt;hr>
&lt;p>这下好了，安装成功咧，下面怎么装修好呢？&lt;/p>
&lt;h2 id="装修还是先试试-kde吧顺带处理一下输入法字体网络的坑">装修：还是先试试 KDE吧，顺带处理一下输入法、字体、网络的坑
&lt;/h2>&lt;p>&lt;em>后面的内容都是这个傻孩子回忆出来的，很多都不对劲了（也许），请谨慎参考&lt;/em>&lt;/p>
&lt;h3 id="不知道先看看-kde-plasma">不知道，先看看 KDE Plasma
&lt;/h3>&lt;p>直接照搬上次安装的 KDE Plasma 的流程了。安装的东西，设置的玩意儿，几乎一模一样。可能区别是 &lt;code>loacle&lt;/code> 的设置和上次相比更复杂一些？记不太清楚了。主要要处理的问题就是，每次使用 &lt;code>man&lt;/code> 的时候，都会报 &lt;code>locale&lt;/code> 的设置错误问题。解决方法也很简单：照着 ArchWiki 的 Installation Guide 的地区设置那里，再重新搞一次。剩下的什么设置 Taskbar 呀设置 Terminal 什么的，基本都没什么变化。&lt;/p>
&lt;p>KDE Plasma 很不错的一点就是，它几乎就是开箱即用的，除了两个很重要但是没有强制安装的东西：文件管理器和终端模拟器。理论上讲，应该是用同属 KDE 的 &lt;code>Dolphin&lt;/code> 和 &lt;code>Konsole&lt;/code> 的，这样能获得最好的体验（也许），然而在体验过 &lt;code>Konsole&lt;/code> 略显（真的只是略显）老旧的 UI 之后，我还是选择了使用 &lt;code>kitty&lt;/code>。它能原生支持查看图片，算是一个杀手锏级别的功能了吧，其次就是它自带多标签的功能，分栏也很方便，用着挺顺手的。至于文件管理器，目前还没有什么想法，先用着 &lt;code>Dolphin&lt;/code> 好了。&lt;/p>
&lt;h3 id="输入法还是使用小企鹅fcitx5以及中州韵rime">输入法：还是使用小企鹅（fcitx5）以及中州韵（Rime）
&lt;/h3>&lt;p>其实应该直接说“同上”或者什么的，因为实际上最后的效果和之前在虚拟机上安装的过程是一样的，除了最后我没有导入在 Winodws 上已经配置好的配置文件，仅此而已。然而这个过程还是感觉有一点坑呀，特别是不停地纠结输入法设置到底在哪里之类的问题的时候。实际上，根据 fcitx5 的文档，在使用 Wayland 的时候，直接按照教程设置变量之后重启电脑，就可以在输入法那里看到效果了。（也许不需要重启，只需要登出后重新登录就可以？）&lt;/p>
&lt;p>实际上默认的中州韵已经挺好用了。然而问题是，它的默认输入是中文，然而在 Linux 的命令行里几乎很少用到中文。每次的误输入都能让人燃气无名怒火，解决方案也很简单：把英文输入法放在首选。这里不是说让中州韵的英文成为首选，而是再装一个默认的英文输入法，并且把它放在首位。实际上我在 Winodws 上也是这么设置的。日用挺舒服。&lt;/p>
&lt;h3 id="网络科学上网不容易呀">网络：科学上网不容易呀
&lt;/h3>&lt;p>在孜孜不倦的努力以及不厌其烦的打扰 AI 下，我成功找到了在我的小破本上科学上网的方法。这里不多讲，但是核心只有一个：使用 TUN 模式。启用 TUN 之后，一切都对了，全对！感谢 AI，感谢 DeepSeek，感谢 ChatGPT！伟大，无需多言。&lt;/p>
&lt;h3 id="字体照着教程开抄">字体：照着教程开抄
&lt;/h3>&lt;p>之前在虚拟机上进行安装的时候实际上没太注意字体的问题。这次因为是日常自用，还是留意了一下，毕竟每天看着奇形怪状的汉字真的很别扭。字体的设置基本就是参考 &lt;a class="link" href="https://catcat.cc/post/2021-03-07/" target="_blank" rel="noopener"
>这篇博文&lt;/a>，谢谢你，大佬。不过也要注意，读的时候（或者，抄的时候）还是要仔细一些，有一些设置实际上不是最好的设置，可以用出现在底下的更好的配置替代。也算是挡住了一些些伸手党？也许？&lt;/p>
&lt;h3 id="指纹呜呜呜呜呜怎么硬件还能不开源呀">指纹：呜呜呜呜呜怎么硬件还能不开源呀
&lt;/h3>&lt;p>我的笔记本最让我自豪的一点就是她有非常好用的指纹识别。这个本来应该没什么要紧的，但是想到之后就很像折腾一下。特别是回回输入密码，真的有点累。虽然这个本是我自己用，里面也没啥东西，但是还是不太想无密码裸奔。而如果有了指纹，一切都变得熟悉了。啊，那该是多么美妙呀。&lt;/p>
&lt;p>直到我花了两个小时多把指纹识别都配置的差不多了的时候，我才发现，愚蠢的小米旗下的 Redmi Book 14 使用的指纹识别模块是闭源的，也没有相关的逆向工程尝试，现在没有任何驱动能启用它。&lt;/p>
&lt;p>泪就这样拉了出来。特别是愚蠢的 Firefox 还始终坚持认为我的笔记本是带了可用的指纹识别的，想生成个 Github 的 token 都不行，非得要我按指纹。我按个大头鬼。&lt;/p>
&lt;p>唉。&lt;/p>
&lt;h2 id="收尾又是一篇流水账但是还是做一些总结">收尾：又是一篇流水账，但是还是做一些总结
&lt;/h2>&lt;p>感觉这篇没写什么正经东西，又是纯粹地做了一些记录，然后就是磨磨叽叽自说自话了。鉴于此，我决定总结一下一路遇到的主要的坑在哪里，以及安装的大致流程，做一个 quick reference。&lt;/p>
&lt;h3 id="quick-reference-installation">Quick Reference: Installation
&lt;/h3>&lt;p>以下是从最初的准备工作到得到可用系统的过程：&lt;/p>
&lt;ol start="0">
&lt;li>准备启动盘，备份，barabara&lt;/li>
&lt;li>加载系统，从启动盘启动，进入 shell，执行基本检查（系统架构，键盘设置，网络验证，时区设置……）&lt;/li>
&lt;li>磁盘分区（重要）并进行格式化，挂载文件系统&lt;/li>
&lt;li>检测 &lt;code>pacman&lt;/code> 镜像速度并选择，安装必要包（base, linux, linux-firmware）&lt;/li>
&lt;li>&lt;code>chroot&lt;/code> 进挂载的文件系统，安装必要工具（网络管理，文本编辑器，pager，man-page）&lt;/li>
&lt;li>设置 bootloader（重要且坑），需要仔细阅读文档&lt;/li>
&lt;li>尝试重启并用 bootloader 启动，进入 &lt;code>tty1&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="quick-reference-customization">Quick Reference: Customization
&lt;/h3>&lt;p>以下是得到我目前使用的环境的部分配置过程：&lt;/p>
&lt;ol start="0">
&lt;li>安装好，保证能正确启动 Arch Linux&lt;/li>
&lt;li>用 &lt;code>nmcli con up&lt;/code> 启动网络（后面发现可以用 &lt;code>nmtui&lt;/code>），保证网络畅通&lt;/li>
&lt;li>添加 &lt;code>archlinuxcn&lt;/code> 源&lt;/li>
&lt;li>执行更新，安装软件包。我安装了 &lt;code>vi&lt;/code>, &lt;code>sudo&lt;/code>, &lt;code>git&lt;/code>, &lt;code>eza&lt;/code>, &lt;code>zsh&lt;/code>, &lt;code>nvim&lt;/code>, &lt;code>kitty&lt;/code>, &lt;code>firefox&lt;/code> 等基础工具&lt;/li>
&lt;li>安装 &lt;code>oh-my-zsh&lt;/code> 与 &lt;code>oh-my-posh&lt;/code>，导入已有配置，添加常用别名如 &lt;code>l&lt;/code>, &lt;code>la&lt;/code>, &lt;code>l.&lt;/code>, &lt;code>ls.&lt;/code> 等&lt;/li>
&lt;li>安装窗口管理器，这里一开始使用 &lt;code>KDE plasma&lt;/code> 作为 “起码能用” 的桌面环境，以及套件 &lt;code>dolphin&lt;/code> 作文文件管理器&lt;/li>
&lt;li>安装中文输入法 &lt;code>fcitx5-im&lt;/code> 以及 &lt;code>fcitx5-rime&lt;/code>，进行必要配置（XDG 配置等）&lt;/li>
&lt;li>更改 &lt;code>localectl&lt;/code> 以便正常使用 &lt;code>man&lt;/code>&lt;/li>
&lt;li>安装 &lt;code>yay&lt;/code> 以及尝试科学上网&lt;/li>
&lt;/ol>
&lt;h3 id="遇到的坑">遇到的坑：
&lt;/h3>&lt;p>下面是花费时间比较多的部分，这里列举一下：&lt;/p>
&lt;ol>
&lt;li>分盘搞错盘了，本来内存是 nvme 结果分到 sda 了；&lt;/li>
&lt;li>分盘的时候没想清楚到底该怎么分，瞎分最后还得重来&lt;/li>
&lt;li>没有检查镜像速度导致龟速下载（唉，Arch Linux，必须依赖网络，可惜）&lt;/li>
&lt;li>&lt;code>umount&lt;/code> 的时候没有 &lt;code>umount&lt;/code> 干净导致烂掉&lt;/li>
&lt;li>&lt;code>mount&lt;/code> 的时候没有检查是否正确 &lt;code>mount&lt;/code> 到挂载点&lt;/li>
&lt;li>忘记安装网络管理器，编辑器等等&lt;/li>
&lt;li>没有正确设置 &lt;code>bootloader&lt;/code> (一定要读完 &lt;code>bootloader&lt;/code> 的 &lt;code>ArchWiki&lt;/code> 词条！)&lt;/li>
&lt;li>没有搞好 &lt;code>localectl&lt;/code> 和 &lt;code>local&lt;/code>&lt;/li>
&lt;li>安装 &lt;code>fcitx5&lt;/code> 之后不重启（记得感觉配好之后就重启试试）&lt;/li>
&lt;/ol>
&lt;p>希望这些总结的东西会帮到你吧，让这篇文章不是那么水。&lt;/p>
&lt;h2 id="后记我一定是对-linux-有什么奇怪的幻想">后记：我一定是对 Linux 有什么奇怪的幻想
&lt;/h2>&lt;blockquote>
&lt;p>亲爱的 Arch Linux 笔记本：&lt;/p>
&lt;p style="text-indent: 50px"> 终于，BTW, I USE ARCH!!! 谢谢你和我走过的一路。自从安装了 Arch Linux，你真的跑的飞快。我还没有回过神来，你就已经启动了。KISS 的原则，pacman 与 AUR 达成的简洁与丰富的平衡，滚动发行带来的刺激，这一切都太令人兴奋了。先进的 Arch Linux 已经完全地超越了老旧的 Windows！ &lt;/p>
&lt;p style="text-indent: 50px"> 然而，也许我还是对你有太多的误会。装上 Arch Linux 的你没有变得更加省电，反而似乎更加费电了？我希望这是我没有搞好电池方案配置的锅，但是为什么你不能帮我搞好呢？我懂，我们 Linux 是讲究过生日先从办养鸡场和农场开始的，但是为什么呢？还有，为什么搞不定闭源驱动呢？不能上兼容层吗？说起来就气，怎么你的配置文件还是能变得和 Windows 一样杂乱不堪？怎么软件包随处大小便的时候你还是不管管？道理我都懂，但是系统管理员也不能每天都被埋在这些东西里面吧？还有呀……&lt;/p>
&lt;p align="middle"> -- 此处省略牢骚 2000 字 -- &lt;/p>
&lt;p style="text-indent: 50px"> 但是，你懂的，你可是 Linux，对吧？你已经是一个成熟的操作系统了，应该学会自己面对这些问题了，对吧？
&lt;p align="right">Yours, &lt;/p>
&lt;p align="right">A Moment&lt;/p>&lt;/blockquote>
&lt;p>谢谢你能看到这里。看完这一大堆废话，说实话也挺累的。如果这些整活儿的内容让你能开心一下，那就太好了。最后，一如既往，就祝您身心健康吧。&lt;/p></description></item><item><title>从零开始的 Arch Linux 安装</title><link>https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/</link><pubDate>Sun, 10 Nov 2024 22:34:55 +0800</pubDate><guid>https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Reimu_Water.jpg" alt="Featured image of post 从零开始的 Arch Linux 安装" />&lt;p>&lt;em>久闻 Arch Linux 大名, 以前尝试过在自己的电脑上安装 Arch Linux, 但是无情地失败了. 最近又有了尝试安装的想法, 故顺带做此记录, 以便将来回头嘲讽自己的离谱操作.&lt;/em>&lt;/p>
&lt;h2 id="引子-我与-linux">引子: 我与 Linux
&lt;/h2>&lt;p>我认识 Linux 是从疫情在家无所适从的时候, 在自己的戴尔笔记本上安装 Ubuntu 开始的. 在那之前, 我只知道在 Windows 的江山之外, 还有一片名为 Linux 的世外桃源 (是的, 当时还不知道有 Mac OS,笑死). 而随着对编程兴趣的逐渐浓厚, 我愈发好奇那个 &amp;ldquo;只有高手才能玩得转&amp;rdquo; 的操作系统究竟是长什么样子. 于是, 在父亲的帮助下, 我在我的戴尔笔记本上划出来一小块硬盘留给 Linux (是的, 那时想安装双系统), 并且安装了 Ubuntu. 这个过程花费了我整整一天, 中间甚至和父亲闹了点矛盾, 把为数不多的精力全都耗光了. 自然, 安装好之后除了打开看了一眼, 安装了个 QQ 然后给同学炫耀之后, 便没了下文, 在随后的哪次格式化硬盘的时候跟着不见了.&lt;/p>
&lt;p>第二次尝试 Linux 是在英国百无聊赖的时候开始的. 那时又是对电脑感兴趣, 又是好奇 Linux 操作系统是什么样子, 于是便又一次自己尝试安装 Linux. 这次是跟着鸟叔开始的, 故而安装了他的教程里的 CentOS. emmm 这个系统好像是比较老旧了还是怎么样, 目前也不是很火的样子. 鸟叔的教程还是相当细心认真的, 我这种纯小白 (也许) 也懵懵懂懂地在虚拟机上安装好了, 尝试了几个命令, 也感受到了命令行的神奇之处. 然而, 可能是好奇心太旺盛, 抑或是其他的原因, 我的兴趣点很快跑掉了, 因此这次对 Linux 的探索之旅止步于学会用命令行关机 (当然, 现在也已经忘了hhh)&lt;/p>
&lt;p>第三次便是进入研究生之后. 由于程序需要在 Linux 环境下运行, 编译和调试, 我再一次尝试起了 Linux. 不过这一次, 我使用了 WSL 来运行 Linux. 一开始也是安装的 Ubuntu, 后来总是在网上听到什么 &amp;ldquo;BTW, I use Arch&amp;rdquo; 这样的段子, 以及各路网友的推荐, 我便尝试了一下在虚拟机上安装 Arch Linux. 不过也许是心浮气躁, 没能搞成, 后来安装了网上大佬的 Arch WSL, 现在也随着老笔记本的退役而说再见了.&lt;/p>
&lt;p>目前我使用 Linux 系统还是主要通过 WSL, 毕竟真的很方便. 但是, 心里总是痒痒的: 为什么我不能装个 Arch 呢? 所以这一次, 我一定要安装好 Arch Linux 口牙! 即便可能后面还是会沦为文件夹角落的落灰软件, 我也要骄傲地喊出: &amp;ldquo;BTW, I use Arch!&amp;rdquo; (下期可能是 Debian 也说不定, 哈哈哈)&lt;/p>
&lt;h2 id="准备-virtualbox-和-arch-镜像站">准备: VirtualBox 和 Arch 镜像站
&lt;/h2>&lt;p>环顾电脑一圈, 发现我以前用的 VMware Workspace 安装包没有导到这台新电脑上来, 而且即便现在安装 VMware Workspace 17 Pro 是免费的, 它竟然还要我注册…… 于是我还是选择了 Oracle 家开源的 VirtualBox. 再下来便是 Arch Linux 的源了, 我选择使用 ISO 镜像安装, 下载是通过淘宝的&lt;a class="link" href="imgs/https://mirrors.aliyun.com/archlinux/iso/2024.11.01/" >阿里云镜像站&lt;/a>(其实就是第一个而已, 懒得往下翻了). 下载了大概40来分钟吧, 感觉速度还行, 1G 的大小来讲感觉还不错.&lt;/p>
&lt;p>VirtualBox 里给 Arch 预留了 4096MB (4GB)内存和 8GB 的硬盘容量, 希望这么多够 Arch 用. 校验过 SHA256 之后, 因为之前设置虚拟机的时候没有指定 Arch 的镜像文件 (因为还没有下载好), 所以在启动虚拟机之后会显示 &amp;ldquo;failed to boot&amp;rdquo; 并且要求指定 DVD 的路径. 这里选好 Arch 的镜像之后直接 &lt;code>mount and reboot&lt;/code>, 便会进入 Arch 的安装界面了. 从这里开始也算是正式进入 Arch Linux 的安装环节了.&lt;/p>
&lt;h2 id="开始-准备-安装">开始 (准备) 安装
&lt;/h2>&lt;h3 id="帅气的开屏-然后进入-shell">帅气的开屏, 然后进入 Shell
&lt;/h3>&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Welcome.png"
width="642"
height="555"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Welcome_hu_e95bc948cd3cad74.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Welcome_hu_dcf31ce89937d835.png 1024w"
loading="lazy"
alt="开始安装!"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>这里我们打开 &lt;a class="link" href="imgs/https://wiki.archlinux.org/title/Installation_guide" >Arch Linux Installation Guide&lt;/a>以便根据官方教程进行安装. 我不打算用 Arch Install, 感觉那个没什么意思 (&lt;del>上次也是这么说的&lt;/del>). 按照小节 1.4.2, 我们使用了光盘介质 (ISO也算是光盘镜像), 所以直接第一个选项就可以了.&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Hacking.png"
width="1282"
height="875"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Hacking_hu_2f0e84073b957cc9.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Hacking_hu_3c71f43612d684e9.png 1024w"
loading="lazy"
alt="很帅"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="351px"
>&lt;/p>
&lt;p>旋即屏幕闪过很有黑客感觉的画面 (个人猜测是系统自检, 感觉像是 systemd, 因为左边有很多绿色 OK 字样), 然后便进入了如下画面:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Install_1.png"
width="1282"
height="875"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Install_1_hu_38cbc1f281d7e433.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Install_1_hu_f3d4b85ad9ae83cd.png 1024w"
loading="lazy"
alt="安装画面1"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="351px"
>&lt;/p>
&lt;p>根据 1.4.3, 我们这是来到了第一个虚拟终端 (Virtual Console), 身份是管理员用户 root, 使用的 Shell 是 Zsh. 感谢虚拟机, 让我不用担心在 root 账户下做的愚蠢操作会害死我的电脑和我自己. 那么我们继续吧~&lt;/p>
&lt;h3 id="键盘映射和字体-以及验证启动模式">键盘映射和字体, 以及验证启动模式
&lt;/h3>&lt;p>接下来要设置键盘映射. 其实个人感觉美式键盘就不错, 不过还是看一下吧. 说不定以后会考虑搞点中文输入法, 之前看到的小狼毫还不错的样子 (现在也还再用).&lt;/p>
&lt;p>扯远了, 查看键位映射的命令是: &lt;code>localectl list-keymaps&lt;/code>. 这个命令感觉很容易拆分为 &amp;ldquo;locale ctl&amp;rdquo;, 本地化控制的感觉. 很快阿, 输入命令之后直接跳出来一个长长的列表! 里面应该是所有 Arch Linux 支持的键盘映射选项. 这里好像就是使用了 Vim 输出到屏幕上的, 所以支持所有的 Vim 操作 (当然, 我就只会那几个, 以及退出). 坏消息是, 没有中文的选项, 不过这里应该是我犯蠢了, 键盘布局其实中文用的貌似就是美式布局…… Anyway, 我们就直接接受最基本的设置即可, 不考虑更改键盘布局了. 后面可能我会考虑把 CapsLock 键映射为 ESC/Ctrl, 不过就现在而言还是省了吧. 这里还可以设置键盘的字体, 但是也省了吧, 以后再说. 感觉这个地方设置的主要目的还是为了能顺利安装 Arch Linux, 个性化之类的内容按理应该是放在装完系统之后的.&lt;/p>
&lt;p>接下来是验证启动模式. 使用命令如下: &lt;code>cat /sys/firmware/efi/fw_platform_size&lt;/code>. WTF? 竟然显示没有这个文件. 按照说明, 这里系统应该是使用 BIOS 或者 CSM 方式启动了. 查看虚拟机设置里的母板(主板)部分, 可以看到 启用EFI 没有被勾选上. 好吧, 那就说明应该就是 BIOS 启动了.&lt;/p>
&lt;h3 id="验证网路环境-然后更新系统时间">验证网路环境, 然后更新系统时间
&lt;/h3>&lt;p>然后尝试联网. 作为网络小白, 我只能按照说明上的一步步来了. 首先检查网络接口 (network interface) 有没有打开, 使用命令 &lt;code>ip link&lt;/code>, 得到了两行内容, 一行是 &lt;em>lo&lt;/em>, 另一行是 &lt;em>enp0s3&lt;/em>. 看不懂. 查看 Arch Wiki 上关于网络接口的部分, lo 是 &lt;em>virtual loopback interface&lt;/em> 的意思, 且不会用在联网上. 而另一个 enp0s3 看起来像是正确的网络接口. 根据说明, &lt;em>en&lt;/em> 代表的是以太网 (Ethernet), 而且只要显示了 &lt;em>UP&lt;/em> 的字样, 便表明该接口是已启用了的. 很好, 说明我们的网络接口设置没遇到什么阻碍.&lt;/p>
&lt;p>我的虚拟机是使用的 NAT, 这个 NAT 根据 Google 得到的结果来看, 是 Network Address Translation 的缩写, 是一种把 IP 地址重映射的技术. 听起来很像是路由器在做的工作. 根据安装引导的说明, 我们需要做的是插好网线并且配置好动态IP, 而动态 IP 又好像是会自动配置好的. 所以实际上什么都不需要做就可以了其实. 那么网络这块儿的最后一步便是尝试 &lt;code>ping archlinux.org&lt;/code>. 很不错, ping 出来结果了. 这个命令就我的认知而言, 是尝试向某个网址发送一些短数据包, 然后让对应网址的服务器返回一个数据包, 以此来检测网络延迟情况. 除了尝试 &lt;a class="link" href="imgs/archlinux.org" >archlinux.org&lt;/a>, 我还试了试 ping B站, Google, 百度. 结果除了谷歌以外都不错. 可能是因为代理没有代理虚拟机的端口吧 (瞎猜). 无论如何, 网络这块儿是搞定了. 接下来是更新系统时间. 这个简单, &lt;code>timedatectl&lt;/code> 就可以. 轻轻松松. 看来这会儿是美国时间下午4点半.&lt;/p>
&lt;h3 id="磁盘分区咯-还要格式化并挂载">磁盘分区咯, 还要格式化并挂载
&lt;/h3>&lt;p>现在要进行的就是磁盘分区了. 每次到了这里总会感觉紧张, 不知道是不是因为之前搞坏过磁盘的缘故 (虽然是物理损坏, 和操作系统没关系). 先来看看都有哪些设备可用: &lt;code>fdisk -l&lt;/code>. 结果显示找到了两个设备: &lt;code>/dev/sda&lt;/code> 和 &lt;code>/dev/loop0&lt;/code>, 一个是我预留好的 8GB 固态虚拟文件系统, 另一个是什么我不是很懂. 教程上讲, 以 &lt;code>loop&lt;/code> 结尾的可以不用管. 可是我这是以 &lt;code>loop&lt;/code> 开头的呀…… 算了, 应该没问题. 这里提示如果没有显示硬盘, 需要确保硬盘控制器没有处于 RAID 模式. RAID 阿, 看来磁盘阵列这种好像还不太好直接搞 Arch? 因为我这里的硬盘是普通的 SATA, 所以就忽略NVMe 等的提示了.&lt;/p>
&lt;p>接下来正式开始分区. 这里指出了两个要划出来的分区: &lt;strong>用于根目录 &lt;code>/&lt;/code> 挂载的分区&lt;/strong> 以及 &lt;strong>用以 UEFI 模式启动的 EFI 系统分区&lt;/strong>. 这个 EFI 分区我有印象, 在 Windows 系统的磁盘管理中, 可以看到 &lt;code>C&lt;/code> 盘里面就又一个 EFI 系统分区. 看来 EFI 现在是比较通用的系统启动方法. 这里我发现我好像设置的磁盘空间太小了, 教程里给的是至少 23-32GB 留给根目录挂载的, 唉. 郁闷阿. 看来要火速删机然后重新搞起.&lt;/p>
&lt;p>Waiting&amp;hellip;&lt;/p>
&lt;p>还好之前基本都是检查性质的条目, 直接可以跳过. 重新分配硬盘空间到了 64G, 启动后就可以开始分区了. 这里教程里有提到几个点: 1. 想好怎么分配空间; 2. 如果要组存储池之类现在就要搞; 3. 如果这个盘上已经有 EFI 了就不要重新建立 EFI 了; 4. 可以在支持 Swap 的文件系统设置 Swap. 底下还有两个分区示例, 我们就尝试最简单的那个, 也就是 1.9.1 中的 第一个方案. 个人而言这个方案也挺合适的.&lt;/p>
&lt;p>我们使用 &lt;code>fdisk&lt;/code> 来创建硬盘分区: &lt;code>fdisk /dev/sda&lt;/code> (我这里用来分区的磁盘是这个 &lt;code>/dev/sda&lt;/code>, 所以命令后面跟着的是这个). 这个命令行工具我从来没用过 (上次安装好像用的不是这个, 有个 TUI. 也有可能 fdisk 也有 TUI, 这次没搞出来吧), 查阅 fdisk 的说明, 直接从第四节开始, 首先是说明创建分区会抹掉这个磁盘上的所有数据. 很吓人, 还好我们在虚拟机上. 应该不会影响到我可爱的C盘的吧.&lt;/p>
&lt;p>首先创建分区表. 这里使用 MBR 分区表, 因为默认如此. 根据网上的搜索结果, MBR 也适合我这种磁盘容量比较小的情况. 然后按 &lt;code>n&lt;/code> 进入创建分区引导界面. 这里会询问你的分区类型 (是初始还是拓展), 分区的编号, 以及起始和结束扇区. 第一个分区分给 &lt;code>/boot&lt;/code> 作为启动分区, 结束扇区前的部分一律默认 (初始分区, 1号, 从 2048 扇区开始), 然后通过命令 &lt;code>+1G&lt;/code> 来给第一个分区 1G 的容量. 然后创建第二个分区, 也是前面全部默认, 最后用 &lt;code>+4G&lt;/code> 指定容量为 4G. 这里我把这 4G 作为 Swap (好像就是虚拟内存)分区, 先使用命令 &lt;code>l&lt;/code> 查看每种分区类型的代码 (Swap的代码是 82), 然后 &lt;code>t&lt;/code> 开始改变分区类型, 选择 2 号, 类型写82. 最后把所有的空间分给第三个区, 然后给分区1打上 bootable 的标签 (用命令 &lt;code>a&lt;/code> 然后选 1 号).&lt;/p>
&lt;p>这个时候可以用 &lt;code>p&lt;/code> 来查看分区结果, 会有一个表格写着所有的内容. 确认无误就可以 &lt;code>w&lt;/code> 来写入分区结果了. 接下来要格式化文件系统, 不然操作系统不知道文件是怎么存放的. 首先用命令 &lt;code>lsblk -f&lt;/code> 来查看现在的磁盘信息 (或者就是刚刚的分区情况). 这里我显示的结果如下:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition.png"
width="953"
height="144"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition_hu_801ed1748e0604f8.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition_hu_3b48734c8b85f864.png 1024w"
loading="lazy"
alt="lsblk -f 结果"
class="gallery-image"
data-flex-grow="661"
data-flex-basis="1588px"
>&lt;/p>
&lt;p>说明之前的 &lt;code>sda&lt;/code> 磁盘已经被分成了三个区域, 且都没有挂载. 现在我发现了一个问题: 我用的是 MBR 分区表, 为什么使用了 GPT分区表推荐的 &lt;code>/boot&lt;/code>呢? 而且之前还说没有开启 EFI, 现在又要搞 EFI 适用的 &lt;code>/boot&lt;/code>, 离谱. 很好, 那就重新分区吧.&lt;/p>
&lt;p>Waiting&amp;hellip;&lt;/p>
&lt;p>很好, 在熟练的操作下~~ (指现学)~~, 先用 &lt;code>d&lt;/code> 删除所有分区, 然后创建 4G 的 Swap 分区, 以及 bootable 的主目录分区. 现在的分区结果是这样的:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition1.png"
width="950"
height="130"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition1_hu_a9fbdaea39c39ce7.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskPartition1_hu_bdf85989c95534d3.png 1024w"
loading="lazy"
alt="新的分区结果"
class="gallery-image"
data-flex-grow="730"
data-flex-basis="1753px"
>&lt;/p>
&lt;p>我们采用最经典的 &lt;code>ext4&lt;/code> 文件格式 (其实就是教程里这么推荐的) 来格式化 &lt;code>/dev/sda2&lt;/code>, 命令为: &lt;code>mkfs.ext4 /dev/sda2&lt;/code>; 然后用命令 &lt;code>mkswap /dev/sda1&lt;/code> 将 &lt;code>/dev/sda1&lt;/code>格式化为 &lt;code>swap&lt;/code>. 整体结果如下:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskFormat.png"
width="952"
height="382"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskFormat_hu_9cd10e885e3f8544.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/DiskFormat_hu_250051301533719d.png 1024w"
loading="lazy"
alt="分区格式化"
class="gallery-image"
data-flex-grow="249"
data-flex-basis="598px"
>&lt;/p>
&lt;p>最后, 我们终于要挂载文件系统了. 这个我了解过, 使用 &lt;code>mount&lt;/code> 命令即可挂载硬件到某个目录下. 首先我们挂载根目录, 把根目录挂载到 &lt;code>/mnt&lt;/code> 下: &lt;code>mount /dev/sda2 /mnt&lt;/code>. 因为我没有别的什么文件分区, 只剩下一个 Swap 分区, 所以我们直接使用命令: &lt;code>swapon /dev/sda1&lt;/code> 来启动 Swap.&lt;/p>
&lt;h2 id="真的要安装了">真的要安装了
&lt;/h2>&lt;p>刚刚才发现, 上一节内容是 &amp;ldquo;Pre-installation&amp;rdquo;. 晕了, 原来刚才的真的全都是准备工作吗? 好像看起来确实如此, 因为没有涉及到什么具体的软件安装之类的, 更像是创造一个能让 Arch Linux 得以安装的环境. 但是看安装说明, 安装这一节只有两个小节, 看来也不是很复杂的样子.&lt;/p>
&lt;p>首先是要选择镜像. 这次选择的镜像感觉上是给系统使用的 pacman 的镜像源. Arch 已经有一份使用 Reflector 生成 的镜像服务器列表: &lt;code>/etc/pacman.d/mirrorlist&lt;/code>, 可以查看或编辑这个文件以使地理位置最靠近的服务器地址可以被优先使用. 这里我使用 &lt;code>reflector --latest 10 --sort rate&lt;/code> 来按照响应速度排序最近更新的10个服务器. 结果好多都 timeout 了. 尝试命令 &lt;code>refletor --country China --age 12 --sort rate&lt;/code>, 试了两次, 结果又是时好时坏. 不管了, 起码这个时好时坏也算是有源可用. 使用命令 &lt;code>reflector --country China --age 12 --sort rate --save /etc/pacman.d/mirrorlist&lt;/code> 即可把输出的结果保存到 &lt;code>/etc/pacman.d/mirrorlist&lt;/code> 里面.&lt;/p>
&lt;p>接下来要安装必要的包. 根据教程, 这里安装的包有 &lt;code>base&lt;/code> 包, Linux 内核以及一些常见的固件. 使用命令: &lt;code>pacstrap -K /mnt base linux linux-firmware&lt;/code>. 之后便进入了安装界面.&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Installation.png"
width="1282"
height="875"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Installation_hu_923ed015f5e8ee1c.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Installation_hu_2ada90a77a96a96.png 1024w"
loading="lazy"
alt="安装界面"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="351px"
>&lt;/p>
&lt;p>看来要安装 127 个包, 不是个小数目. 而且我这里的网速看起来也比较一般. 慢慢等吧. 这个安装进度让我莫名想起安装 $\LaTeX$ 时候的样子.&lt;/p>
&lt;p>Waiting&amp;hellip;&lt;/p>
&lt;p>? 后续过程这么快的吗? 127个包看来都不是很大的样子. 安装好之后的样子是这样的:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/AfterInstall.png"
width="1282"
height="875"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/AfterInstall_hu_e317c7d974aee116.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/AfterInstall_hu_bb8c85132c748127.png 1024w"
loading="lazy"
alt="安装完成"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="351px"
>&lt;/p>
&lt;p>可以看到其实有一些部分是缺失的. 这个应该没什么关系, 毕竟虚拟机可能确实会缺一些不紧要的组件. 这里还可以安装一些别的组件, 比如 CPU 的指令集更新 (&lt;code>microcode&lt;/code>), 使用 RAID 的工具之类. 这里就先跳过了, 之后使用 &lt;code>pacman&lt;/code> 安装需要的内容. &lt;code>microcode&lt;/code> 由于我使用的是虚拟机, 指令集补丁应该存在于主机 (这台Windows) 上,
所以不需要安装.&lt;/p>
&lt;p>安装在虚拟机上的时候好像不需要安装 &lt;code>linux-firmware&lt;/code>, 额…… 无所谓了. 现在才看到也是醉了. 那么就下一步吧.&lt;/p>
&lt;h2 id="设置系统吧">设置系统吧!
&lt;/h2>&lt;h3 id="分区文件-chroot-以及本地化">分区文件, chroot, 以及本地化
&lt;/h3>&lt;p>首先先生成一份分区表文件, 使用命令: &lt;code>genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code>. 之后用 &lt;code>cat&lt;/code> 看看结果是否正确, 不对的话需要改一下. &lt;code>fstab&lt;/code> 的 Arch Wiki 页面有一些例子, 这里就不再赘述 (因为我搞的好像没什么问题).&lt;/p>
&lt;p>接下来 change root 到新系统下: &lt;code>arch-chroot /mnt&lt;/code>. 根据中文 Arch Wiki 的解释, chroot 是 &amp;ldquo;修改当前进程及其子进程的可见根目录的操作&amp;rdquo;. 似乎修改之后进程就会以 &lt;code>/mnt&lt;/code> 为根目录 &lt;code>/&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Chroot.png"
width="297"
height="73"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Chroot_hu_1e2ac4412cf332e5.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/Chroot_hu_f871e9a622e51ab2.png 1024w"
loading="lazy"
alt="chroot 之后"
class="gallery-image"
data-flex-grow="406"
data-flex-basis="976px"
>&lt;/p>
&lt;p>我大胆猜测, 现在就是把进程从 ISO 文件中的系统转移到了我虚拟机上的系统. 不过怎么验证这个想法我没什么主意. 下一步吧.&lt;/p>
&lt;p>现在要设置时区. 国内应该是东8区. 根据教程, 可以使用 &lt;code>timedatectl list-timezones&lt;/code> 来列出可用时区. 然而坏消息是, 列出来的时区因为太多了, 而不知道为什么, 这个终端我没法滚动 (鼠标或者键盘的 &lt;code>Shift + PgUP&lt;/code> 好像都不可以). 经过一番查找, 向上翻页的功能应该是被从内核中砍掉了, 因为没多少人用了, 目前几乎都在用终端模拟器. 好吧, 只好把结果重定向到文件里, 然后再用 Vim 打开试试了. 不过竟然新系统是真的什么都没有, 包括 Vim 或者 Nano 都没有??? 只好退回到安装镜像里看看了. 国内时区使用的是 &lt;code>Asia/Shanghai&lt;/code>, 所以重新 &lt;code>arch-chroot /mnt&lt;/code> 回到根目录, 使用命令 &lt;code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code> 命令设置好时区, 然后使用命令 &lt;code>hwclock --systohc&lt;/code> 生成 &lt;code>/etc/adjtime&lt;/code>.&lt;/p>
&lt;p>再下来是设置本地化. 我个人倾向于不改中文使用, 而且因为没有安装编辑器, 现在要改变本地化设置也不行 (太蠢了, 为什么不安装编辑器!). 好吧, 再憋一下. 还是先设置主机名吧. 因为没有编辑器, 干脆直接使用 &lt;code>echo&lt;/code> 重定向到 &lt;code>/etc/hostname&lt;/code> 好了. 那么在不使用 LVM 或者 RAID 的情况下, 下一步便是设置密码. 设置密码的时候输入的字符是隐形的, 所以看不见是正常现象. 好像 Linux 下的大多数密码输入的时候都会隐形, 也算是保护隐私的一种惯例了.&lt;/p>
&lt;h2 id="boot-loader-然后决定命运的重启">Boot loader, 然后决定命运的重启!
&lt;/h2>&lt;p>最后, 选择并安装 boot loader. 这一步很重要, 不然会导致无法启动 Arch Linux. 根据 boot loader 的特性表, 以及网上查找到的信息 (其实是我没找到怎么搞 EFI boot stub 的安装), 我选择使用 GRUB 作为 boot loader. 首先安装 GRUB (算了, 顺带这一步把vim也安装了吧, 憋不住了): &lt;code>pacman -S grub vim&lt;/code>. 根据 GRUB 的 Arch Wiki 页面, 找到 BIOS System 的第二条 Master Boot Record (MBR) (我怎么在 UEFI 这里兜兜转转好久). 使用命令: &lt;code>grub-install --target=i386-pc /dev/sda&lt;/code>. 这里 &lt;code>--target=i386-pc&lt;/code> 是固定的, 而后面的 &lt;code>/dev/sda&lt;/code> 是指的硬盘而非分区.&lt;/p>
&lt;p>安装好这一步之后就需要对 GRUB 进行配置了. 使用命令: &lt;code>grub-mkconfig -o /boot/grub/grub.cfg&lt;/code>. 貌似这样就已经配置好了. 感觉还是挺简单的. 怎么心里毛毛的. 好, 重启吧! 希望一切顺利.&lt;/p>
&lt;p>成功辣! 好耶! 但是迎接我的并不是美丽的图形化界面, 而是简洁的 tty1, 甚至要我输入账户名来登录. 好吧, 看来起码安装是成功了, 现在要做的就是后处理了.&lt;/p>
&lt;h2 id="安装后的配置">安装后的配置
&lt;/h2>&lt;p>其实要是较真地讲, 现在已经把 Arch Linux 安装好了. 但是我决定送佛送到西, 配置一个能日常使用 (&lt;del>玩耍&lt;/del>) 的系统出来. 按照安装教程的说明, 现在跳转到了 general recommendations 的页面. 这也算是教程吧, 就按着这个来吧.&lt;/p>
&lt;h3 id="系统管理-添加用户和其他">系统管理: 添加用户和其他
&lt;/h3>&lt;p>首先是要学习两个概念, 系统管理 (system administration) 和包管理 (package management). 这两个里第一个对任何的 Linux 系统而言都应该是重要的, 而第二个应该是出于 Arch Linux 独特的滚动更新模式, 所以要特别强调.&lt;/p>
&lt;p>第一点就是讲明 root 账户应该只应用于系统管理的情况, 平时应该使用未经提权 (提高权限) 的普通用户. 使用命令: &lt;code>useradd -m amoment&lt;/code> 便可创建一个名为 &lt;code>amoment&lt;/code> 的用户, 并初始化这个账户对应的 &lt;code>/home/amoment&lt;/code> 文件夹. 随后使用 &lt;code>passwd amoment&lt;/code> 来给这个账户一个密码. 具体操作中, 因为要先登入 &lt;code>root&lt;/code> 账户进行操作, 所以可以在执行完之后 &lt;code>logout&lt;/code> 然后重新以新创建的 &lt;code>amoment&lt;/code> 账户登录.&lt;/p>
&lt;p>接下来是安全问题. 看不了一点儿, 越看越觉得自己在互联网上裸奔 (其实应该已经是了). 感觉自己的网络安全意识还有待提高. 这一部分的文档很长, 以后再细看吧. 随后是服务管理, 主要是说 &lt;code>systemd&lt;/code> 的使用. 也许以后会有需要用 &lt;code>systemd&lt;/code> 来搞一些自动化的服务. 最后是 Arch 滚动版本带来的系统维护的需要. 由于是&lt;del>玩具&lt;/del>系统, 这步也暂时免了吧.&lt;/p>
&lt;h3 id="包管理-pacman-但是">包管理: pacman, 但是……
&lt;/h3>&lt;p>Arch Linux 默认使用 &lt;code>pacman&lt;/code> 作为包管理器. 用包管理器可以安装东西, 前提是有网络. 然而…… 好消息是, 我新安装的 Arch Linux 莫名其妙没有网了. 所以, 包管理章节先暂停一下, 先跳转至 &lt;strong>网络设置&lt;/strong> 部分.&lt;/p>
&lt;h3 id="有网络再说安装吧">有网络再说安装吧!
&lt;/h3>&lt;p>问题的症状很奇怪, 使用命令 &lt;code>ip link&lt;/code> 之后显示的网络适配器都是未启动的状态, 而使用 &lt;code>ip a&lt;/code> 之后显示的内容都是没有 ipv4 地址的.&lt;/p>
&lt;ul>
&lt;li>猜测1: 虚拟机设置有问题
&lt;ul>
&lt;li>捣鼓了半天的 NAT 网络设置, 但是感觉问题应该不是出现在了这里, 因为之前就是使用的 NAT, 不然我的 &lt;code>vim&lt;/code> 都安装不上去的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>猜测2: ip 设置有问题
&lt;ul>
&lt;li>可是 ip 我也不懂啊, 互联网 (物理) 小白是真的搞不懂这些网络协议之类的. 回去翻看安装说明, 也没有讲到这里呀.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>回忆: 安装的时候是有网络的, 安装完好像没碰过网络环境.&lt;/li>
&lt;li>猜测3: 该不会是我自己系统上没有装驱动吧
&lt;ul>
&lt;li>坏了, 网上一通搜, 真的是没有装网络服务 &lt;code>dhcpcd&lt;/code> 和 &lt;code>networkmanager&lt;/code>. 乖乖回去用安装镜像进入, &lt;code>mount&lt;/code> 根分区 &lt;code>/dev/sda2&lt;/code> 到安装镜像的 &lt;code>/mnt&lt;/code> 然后 &lt;code>arch-chroot /mnt&lt;/code>, 开始老实安装 &lt;code>dhcpcd&lt;/code> 和 &lt;code>networkmanager&lt;/code>. 这里要感谢&lt;a class="link" href="https://bbs.archlinuxcn.org/viewtopic.php?id=12603" target="_blank" rel="noopener"
>讨论串&lt;/a>和&lt;a class="link" href="https://www.cnblogs.com/yuxiayizhengwan/p/16576946.html" target="_blank" rel="noopener"
>一篇博文&lt;/a>.
回看安装指引, 这时才明白, 条目 1.7 最底下的 Note 是什么意思了: 网络服务在新装的系统上面是通通没有滴! Okay, 安装完毕, 继续回到 &lt;code>pacman&lt;/code> 上.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="pacman-没错-孩子-又是我">pacman: 没错, 孩子, 又是我
&lt;/h3>&lt;p>首先, 为了能让我以普通用户身份提权然后使用 &lt;code>pacman&lt;/code>, 先在 &lt;code>root&lt;/code> 账户下安装好 &lt;code>sudo&lt;/code> 吧: &lt;code>pacman -S sudo&lt;/code>. 然后安装结束后会发现一个很尴尬的事情: 我的普通账户不在 sudoers 文件中. 查看指南, 指出需要使用 &lt;code>visudo&lt;/code> 来修改 &lt;code>/etc/sudoers&lt;/code> 文件, 但是 &lt;code>visudo&lt;/code> 需要 &lt;code>vi&lt;/code>. 我安装了 &lt;code>vim&lt;/code>, 但是这个不默认安装 &lt;code>vi&lt;/code>. 网上的解决方法看起来有点麻烦, 所以干脆直接 &lt;code>pacman -S vi&lt;/code> 安装. 之后 &lt;code>visudo /etc/sudoers&lt;/code>, 在某处 (我在 root 开头那行的底下) 插入 &lt;code>amoment ALL=(ALL:ALL) ALL&lt;/code> , 即可在需要时提权我的个人账户.&lt;/p>
&lt;p>太棒了, 但是这是否已经解释了如何使用 &lt;code>pacman&lt;/code>? 好像还不够. 查阅指南, 指南中指出在安装软件包时, 不要使用 &lt;code>pacman -Sy&lt;/code>, 这样会造成部分更新, 容易搞崩系统 (俗称 &amp;ldquo;滚挂&amp;rdquo;). 安装软件包使用 &lt;code>pacman -S &amp;lt;pack name&amp;gt;&lt;/code>; 升级系统使用 &lt;code>pacman -Syu&lt;/code>. 这里再解释一下 &lt;code>pacman&lt;/code> 的命令行的意思吧, &lt;code>-S&lt;/code> 代表的是 &lt;em>Sync&lt;/em>, 是同步的意思, 意即使用该命令是从 Arch Linux 的软件源服务器上把对应的软件包同步到本地. 实在是很新颖的做法, 起码概念已经甩开传统的安装了. &lt;code>-Syu&lt;/code> 中的 &lt;code>y&lt;/code> 是指 &lt;em>refresh&lt;/em>, 从服务器上下载最新的包数据库, 而 &lt;code>u&lt;/code> 则代表 &lt;em>sysupgrade&lt;/em>, 更新系统上的所有软件包. 所以 &lt;code>-Syu&lt;/code> 的意义就很明显了, 不希望拉到了最新的软件包数据, 却又没有实际更新软件. 所以这两者放在一起最合适是有道理的.&lt;/p>
&lt;p>看一下删除包吧. 我发现 &lt;code>networkmanager&lt;/code> 好像是不必要的, Arch Linux 使用的 &lt;code>systemd&lt;/code> 自带一个 &lt;code>systemd-networkd&lt;/code>. 删除软件包使用命令 &lt;code>pacman -R&lt;/code> 即可删除包, 但是这种情况下会留下这个跟着这个包一起下载到本地的依赖们. 要顺带删掉&lt;em>空闲&lt;/em>的依赖 (可能有些依赖别的软件包也在用), 使用 &lt;code>pacman -Rs&lt;/code> 即可. 其中 &lt;code>s&lt;/code> 代表的是 &amp;ldquo;recursive&amp;rdquo;. &lt;code>R&lt;/code> 的意义就很明显了, 就是删除 (Remove). 所以为了删掉 &lt;code>networkmanager&lt;/code> 且不影响到别的软件包依赖, 使用命令 &lt;code>sudo pacman -Rs networkmanager&lt;/code> 即可.&lt;/p>
&lt;p>最后了解一下如何列出安装好的软件包吧. 使用命令 &lt;code>pacman -Q&lt;/code> 即可列出所有已经安装好了的软件包 (非常多, 因为在安装系统的时候就已经在使用 &lt;code>pacman&lt;/code> 了). 其他的设置可以通过 &lt;code>pacman -h -Q&lt;/code> 来查看 (&lt;code>-h&lt;/code> 即为帮助的意思咯).&lt;/p>
&lt;h3 id="桌面环境-kde">桌面环境: KDE
&lt;/h3>&lt;p>很好, 先在这个系统距离可以让我谜之自信地喊出 &amp;ldquo;By the way, I use Arch&amp;rdquo; 感觉只剩下最后的一步: 安装桌面环境. 经过不细致的选择, 我决定使用 KDE Plasma 作为桌面环境 (Gnome 的拟物图标感觉不是很喜欢呀, 虽然左侧栏的设计很喜欢, 不过好像 Plasma 也可以搞?).&lt;/p>
&lt;p>通过 &lt;code>pacman -S plasma-meta&lt;/code> 安装 plasma. 中间有几处需要选择一些诸如字体, 解码器之类的供应源, 网上没有多少讨论这个的, 所以就基本全部默认了. 然后顺手安装上 &lt;code>zsh&lt;/code>, &lt;code>noto-fonts-cjk/emoji/extra&lt;/code>, &lt;code>bluez-utils&lt;/code> &lt;code>kitty&lt;/code>, &lt;code>konsole&lt;/code> 和 &lt;code>alacritty&lt;/code>. 这里 &lt;code>kitty&lt;/code>, &lt;code>konsole&lt;/code>, &lt;code>alacritty&lt;/code> 三个重复了, 因为我想都试试.&lt;/p>
&lt;p>首先打开蓝牙: &lt;code>sudo systemctl enable --now bluetooth&lt;/code>, 然后通过 &lt;code>sudo systemctl enable --now sddm&lt;/code> 即可进入 KDE Plasma 桌面. 剩下的就是点点点了, 点点点, 爽! 我必须立刻把任务栏 (这里叫 panel) 移至左边!&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/KDE.png"
width="2055"
height="1228"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/KDE_hu_26b0b26ff0c6bd3.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/KDE_hu_27cfeb358a561524.png 1024w"
loading="lazy"
alt="KDE Plasma 桌面环境"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="401px"
>&lt;/p>
&lt;h3 id="安装别的工具">安装别的工具……
&lt;/h3>&lt;h4 id="我中文输入法呢">我中文输入法呢!
&lt;/h4>&lt;p>为了实现中文输入法, 我安装了 &lt;code>fcitx&lt;/code> 大礼包: &lt;code>fcitx5&lt;/code>, &lt;code>fcitx5-configtool&lt;/code>, &lt;code>fcitx5-chinese-addons&lt;/code>, &lt;code>fcitx-gtk&lt;/code>. 然而莫名其妙地遇到了几个奇怪的坑:&lt;/p>
&lt;ol>
&lt;li>教程讲要把一些内容加入到文件 &lt;code>/etc/environment/&lt;/code> 里面, 然而我用 &lt;code>vim&lt;/code> 打开之后发现是只读的. 虽然可以覆盖, 但是总是感觉不对. 经过网上的搜索才得知: 没错, 这就是权限控制. 使用 &lt;code>ls -l /etc/environment&lt;/code> 命令可以看到最左边的权限控制符, 指明了这个文件是只有拥有者才可以读写, 同组或其他人只能读, 而这个文件的创建者正是 &lt;code>root&lt;/code>. 所以乖乖使用 &lt;code>sudo vim /etc/envirnment&lt;/code> 就可以了, 其实很简单.&lt;/li>
&lt;li>为了配置中文输入法, 我找到 KDE Plasma 的设置里面的 &lt;code>Input Method&lt;/code> 部分, 并且在右下角的 &lt;code>Add Input Method...&lt;/code> 中选择了 &lt;code>Keyboard - Chinese&lt;/code>. 然而什么都没有发生. 即便左下角的输入法显示的是 zh, 可依旧不是中文输出. 很怪! 然而解决方法出乎意料的简单: 在仔细观察各路大佬博客之后, 我发现中文输入法不叫这个名字, 而是应该直接搜索 &lt;code>pinyin&lt;/code>. 无语了, 心态有点小爆炸.
根据 &lt;code>fcitx&lt;/code> 的官网教程, 为了使 &lt;code>fcitx5&lt;/code>生效, 应该在路径 &lt;code>~/.config/environment.d/&lt;/code> 下创建文件 &lt;code>im.conf&lt;/code>, 并在其中输入：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="nv">XMODIFIERS&lt;/span>&lt;span class="o">=&lt;/span>@im&lt;span class="o">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="nv">SDL_IM_MODULE&lt;/span>&lt;span class="o">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一来, 重启之后就可以使用中文输入了&lt;/p>
&lt;h4 id="还是想要用-fcitx5-rime">还是想要用 &lt;code>fcitx5-rime&lt;/code>
&lt;/h4>&lt;p>安装 &lt;code>fcitx5-rime&lt;/code> 我是直接按照说明来的. 直接用 &lt;code>pacman&lt;/code> 就好: &lt;code>sudo pacman -S fcitx5-rime&lt;/code> 即可. 然后在输入法中直接搜索 &lt;code>rime&lt;/code> 选中应用就好. 但是这个时候的词库啊配置啊什么的都不太合意. 然而我 Windows 端也用 的是 Rime 家族的输入法 (具体来讲是小狼毫 &lt;code>weasel&lt;/code>) 而且有一套调教过的配置 (使用 &lt;code>oh-my-rime&lt;/code>, 也叫薄荷输入方案). 所以, 干脆把配置从 Windows 上导入到虚拟机里好了.&lt;/p>
&lt;p>为了能把我在 Windows 上的配置文件直接导入到 Arch 里, 需要在 Arch Linux 里面下载: &lt;code>virtualbox-guest-utils&lt;/code> (不支持 X 的话要安装带个 &lt;code>-nox&lt;/code> 后缀的版本), 然后把它加入到 &lt;code>systemd&lt;/code> 的服务中去: &lt;code>sudo systemctl enable --now vboxservice.service&lt;/code>. 然后再在虚拟机上打开 Drag and Drop 以及 Shared Folders. 我将我用的 Rime 配置文件打包成 tar 之后放在了 Shared Folder里, 然后就可以从虚拟机上的指定位置取出来然后解压缩到需要的路径了. 其实期间有考虑过使用 &lt;code>ssh&lt;/code> 或者是其他的方式来传输这个压缩包, 后面还是放弃了. 反正能完成目标就好, &lt;code>ssh&lt;/code>? 不用也罢! ()&lt;/p>
&lt;h4 id="不能科学上网吗">不能科学上网吗？
&lt;/h4>&lt;p>虽然是虚拟机, 还是想试试安装一些科学上网的工具. 目前 Windows 上有在用的工具, 但是貌似在 Linux 上并不是很好用呀 &amp;hellip; 经过一通搜索之后锁定到了 V2rayA, 使用 &lt;code>yay&lt;/code> 就能很简单的安装 (? 代理? Github?).&lt;/p>
&lt;p>实际尝试过后, 发现这个工具好像和我目前在用的有点八字不合? 在 Windows 上也尝试同款工具之后, 发现确实是不太好用, 唉. 那就算了吧. 不科学上网, 那又能怎么样呢?&lt;/p>
&lt;h4 id="终端字体怎么怪怪的-alacritty">终端字体怎么怪怪的? Alacritty?
&lt;/h4>&lt;p>听闻 Alacritty 使用 Rust, 性能十分优异, 然而在我满心欢喜地调整系统字体为中文之后, Alacritty 的字体变得惨不忍睹了 &amp;hellip;&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_font.png"
width="304"
height="99"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_font_hu_889e7bde4bf4dbc5.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_font_hu_6802c400800e5e2b.png 1024w"
loading="lazy"
alt="奇怪的字体"
class="gallery-image"
data-flex-grow="307"
data-flex-basis="736px"
>&lt;/p>
&lt;p>这究竟是怎么回事? 在热心群友的帮助下, 我查阅了 Alacritty 的 Arch Wiki, 得到了令人震惊的事实: 我竟然没有配置字体文件. 直接下载安装 &lt;code>ttf-cascadia-mono-nerd&lt;/code> (其实不下载也可以), 然后在家文件夹下创建新文件夹和文件: &lt;code>.config/alacritty/alacritty.toml&lt;/code> 并使用 &lt;code>vim&lt;/code> 修改内容. 格式如下:&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_fc.png"
width="429"
height="441"
srcset="https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_fc_hu_d477b62ca02ff625.png 480w, https://a-moment096.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-arch-linux-%E5%AE%89%E8%A3%85/imgs/alacritty_fc_hu_3c77fd6b7ff550e8.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="233px"
>&lt;/p>
&lt;p>保存的时候便会直接应用. 其中 &lt;code>family&lt;/code> 是可以从设置的字体管理部分看到字体族的名字, 输入即可. 这里字体族主要是需要等宽字体族才能正常显示, 选择这款字体是因为我 Windows 上的终端字体也是用的这套 &lt;code>Cascadia&lt;/code>, 很喜欢所以就干脆保持一致了.&lt;/p>
&lt;h4 id="试试-zsh">试试 Zsh!
&lt;/h4></description></item></channel></rss>