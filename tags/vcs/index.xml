<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>VCS on A Moment's Rest</title><link>https://a-moment096.github.io/tags/vcs/</link><description>Recent content in VCS on A Moment's Rest</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 25 Aug 2025 10:10:13 +0000</lastBuildDate><atom:link href="https://a-moment096.github.io/tags/vcs/index.xml" rel="self" type="application/rss+xml"/><item><title>Git，你能帮帮我吗？其三</title><link>https://a-moment096.github.io/p/git%E4%BD%A0%E8%83%BD%E5%B8%AE%E5%B8%AE%E6%88%91%E5%90%97%E5%85%B6%E4%B8%89/</link><pubDate>Sat, 16 Aug 2025 16:49:16 +0800</pubDate><guid>https://a-moment096.github.io/p/git%E4%BD%A0%E8%83%BD%E5%B8%AE%E5%B8%AE%E6%88%91%E5%90%97%E5%85%B6%E4%B8%89/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post Git，你能帮帮我吗？其三" />&lt;p>&lt;em>最后一节，聊聊如何在 GitHub 上进行多人协作吧~&lt;/em>&lt;/p>
&lt;p>&lt;em>头图信息请参考第一节内容，谢谢~&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=455026" theme="#2980b9" loop="never">&lt;/meting-js>
&lt;h2 id="所以git-怎么实现多人协作">所以，Git 怎么实现多人协作？
&lt;/h2>&lt;h2 id="后记">后记
&lt;/h2></description></item><item><title>Git，你能帮帮我吗？其二</title><link>https://a-moment096.github.io/p/git%E4%BD%A0%E8%83%BD%E5%B8%AE%E5%B8%AE%E6%88%91%E5%90%97%E5%85%B6%E4%BA%8C/</link><pubDate>Thu, 14 Aug 2025 16:49:16 +0800</pubDate><guid>https://a-moment096.github.io/p/git%E4%BD%A0%E8%83%BD%E5%B8%AE%E5%B8%AE%E6%88%91%E5%90%97%E5%85%B6%E4%BA%8C/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post Git，你能帮帮我吗？其二" />&lt;p>&lt;em>上一节已经介绍了平时会怎么用 Git 进行单分支仓库的管理，这一节就来讲讲 Git 要怎么进行多分支协作吧！&lt;/em>&lt;/p>
&lt;p>&lt;em>头图信息请参考上一节内容，谢谢~&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=785695" theme="#2980b9" loop="never">&lt;/meting-js>
&lt;h2 id="分支是那个分支吗">分支，是那个分支吗？
&lt;/h2>&lt;p>我们上一节已经了解过 Git 在单分支下的日常工作流了。值得注意的是，我们说的是 “单分支”，那么自然，Git 是支持，同时鼓励使用多分支的。那么分支是什么呢？&lt;/p>
&lt;p>也许有过 Galgame 经验，或者玩过有分支剧情游戏的你已经想到所谓的 “分支” 是什么东西了。没错，很像这么回事儿，不过功能更丰富一些，因为你不止是体验若干个分支的剧情，Git 甚至可以允许你在没有冲突的前提下合并两个分支！如果有一款游戏支持用 Git 来操控分支的话，也许就可以手动后宫了……&lt;/p>
&lt;p>咳咳，不开玩笑了。我们来看看分支具体是什么样的。先来个分支图：&lt;/p>
&lt;h3 id="一个也许简单的-git-分支示意图">一个也许简单的 Git 分支示意图
&lt;/h3>&lt;figure class="mermaid-container">
&lt;div class="mermaid">gitGraph
commit id: "initial commit"
commit
branch feature1
checkout feature1
commit id: "new feat1, first commit"
commit
checkout main
merge feature1 id: "merge feature1"
branch feature2
checkout feature2
commit id: "new feat2"
checkout main
commit
merge feature2 id: "finish, merge feat2"
&lt;/div>
&lt;figcaption>Git 分支示意图&lt;/figcaption>
&lt;/figure>&lt;p>（嘶，mermaid 竟然直接有 gitGraph 的功能，NB）&lt;/p>
&lt;p>那么可以看到，我们这里有三条分支：一条 &lt;code>main&lt;/code>， 一条 &lt;code>feature1&lt;/code> 以及一条 &lt;code>feature2&lt;/code>。有时我们开启了一个分支，有时我们又将两个分支进行了合并。上面的图是怎么生成的呢（双关意）？下面是用到的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">gitGraph
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> commit id: &amp;#34;initial commit&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> commit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> branch feature1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> checkout feature1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> commit id: &amp;#34;new feat1, first commit&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> commit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> checkout main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> merge feature1 id: &amp;#34;merge feature1&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> branch feature2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> checkout feature2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> commit id: &amp;#34;new feat2&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> checkout main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> commit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> merge feature2 id: &amp;#34;finish, merge feat2&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mermaid 的 gitGraph 很有趣的地方在于，上面的代码几乎就是为了实现这样的提交树/分支形状所需要的 Git 命令。我们可以不管 &lt;code>id&lt;/code> 后面的部分，因为这些在实际 &lt;code>commit&lt;/code> 的时候应该是用 &lt;code>-m&lt;/code> 来指定的提交信息才对。&lt;/p>
&lt;p>那么，这些命令都干嘛了？要怎么用命令来操控分支？&lt;/p>
&lt;h2 id="和分支相关的命令们">和分支相关的命令们
&lt;/h2>&lt;p>下面来讲讲上面出现的（和没出现的一些）命令吧~&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git checkout&lt;/code>&lt;/p>
&lt;p>说实在的，这个命令真的是个很大的坑。&lt;code>git checkout&lt;/code> 从 Git 诞生之初就已经存在，它是集创建、管理、变更分支或提交等功能为一体的一个命令。造成这个情况的主要原因在于 &lt;code>git checkout&lt;/code> 实际上不是在我们现有的对 Git 存储模型的理解上进行操作，而是在 Git 更贴近实现层面的操作，即移动 “指针”。&lt;/p>
&lt;p>然而，我们这里先不打算介绍这么深入/详细。我们还是从实用角度来聊聊这个命令。观察上面的 Mermaid 图，我们可以看到，好像 &lt;code>git checkout&lt;/code> 的功能没有直接体现在图上。然而仔细观察的话可以猜到，&lt;code>git checkout&lt;/code> 在这里的作用是更换分支。比如，&lt;code>git checkout main&lt;/code> 就是告诉 Git “现在我要切换分支到 main 分支上”。这是 &lt;code>git checkout&lt;/code> 的主要用途之一。另外我们还可以用 &lt;code>git checkout -&lt;/code> 来像 &lt;code>cd -&lt;/code> 一样切换到上一个分支。&lt;/p>
&lt;p>我们还可以对这个命令多讲一些。如果给它带上 &lt;code>-b&lt;/code> 的参数则可以用来创建一个新分支。比如 &lt;code>git checkout -b new-branch&lt;/code> 就可以创建一个新的名为 &lt;code>new-branch&lt;/code> 的分支，同时你还会直接切换到该分支上。而如果你在后面带的参数是某个文件或者单纯的 &lt;code>.&lt;/code>，则是要让 Git 该文件/所有文件里没有暂存的更改。&lt;/p>
&lt;p>上面说的都是比较老派的做法。相信你也一定从上面的 Mermaid 图中猜到了新式的创建新分支的方法，那就是：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git branch&lt;/code>&lt;/p>
&lt;p>这个命令是用来管控和单个分支相关的操作的。我们简要介绍一下。&lt;/p>
&lt;p>如果后面不带任何的参数，则是会打印出可用分支。如果要创建一个新的分支，就可以用 &lt;code>git branch &amp;lt;another-branch&amp;gt;&lt;/code>, 就是让 Git 尝试创建一个名为 &lt;code>&amp;lt;another-branch&amp;gt;&lt;/code> 的分支。当这个分支已经存在的时候，Git 就会报错，告诉你已经有了叫这个名字的分支了。&lt;/p>
&lt;p>要注意的是，&lt;code>git branch &amp;lt;branch-name&amp;gt;&lt;/code> 只会创建分支，并不会把当前分支更改到这个新分支上。要想在创建分支后切换分支，除了传统方式 &lt;code>git checkout&lt;/code> 外，还可以使用更现代（？）的命令：&lt;code>git switch -c &amp;lt;branch-name&amp;gt;&lt;/code>。我们后面会介绍到。&lt;/p>
&lt;p>除了创建分支以外，我们肯定还希望能实现查看/删除/重命名分支。我们干脆都列在下面吧。如果不想看可以跳过这一段。&lt;/p>
&lt;ul>
&lt;li>要查看分支，可以直接 &lt;code>git branch&lt;/code>。如果要看所有的分支（包括远程的），可以使用 &lt;code>git branch -a&lt;/code> 来查看。你还可以使用 &lt;code>-v&lt;/code> 来输出上次提交的信息。&lt;/li>
&lt;li>要创建分支，就像上面说的，在后面补上你要的分支名称，即 &lt;code>git branch &amp;lt;branch-name&amp;gt;&lt;/code>。如果这个分支已经存在则会报错，另外这个命令只会创建，并不会切换过去。&lt;/li>
&lt;li>如若要从某个提交上创建分支，还可以在 &lt;code>&amp;lt;branch-name&amp;gt;&lt;/code> 后面添加上 &lt;code>&amp;lt;commit-hash&amp;gt;&lt;/code>。至于 &lt;code>&amp;lt;commit-hash&amp;gt;&lt;/code> 是什么，我们在后面关于 Git 的一些概念里进行介绍。&lt;/li>
&lt;li>想要删除分支，可以用 &lt;code>git branch -d &amp;lt;branch-name&amp;gt;&lt;/code> 来删掉它。要是你要删除当前分支，请先切换到别的分支哦。&lt;/li>
&lt;li>要是打算重命名分支，可以考虑像操作文件一样 &lt;em>移动&lt;/em> 它：&lt;code>git branch -m &amp;lt;branch-name&amp;gt; &amp;lt;new-name&amp;gt;&lt;/code>。依旧，这个命令也只能更改别的分支。&lt;/li>
&lt;/ul>
&lt;p>So, that&amp;rsquo;s it! Git 针对单分支的操作都可以用 &lt;code>branch&lt;/code> 子命令来做到。那么，我们要怎么切换分支呢？除了 &lt;code>checkout&lt;/code> 以外，“比较现代”（存疑）的方法是使用：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git switch&lt;/code>&lt;/p>
&lt;p>这个命令是相对较新的用来切换分支的命令。可以通过 &lt;code>git switch &amp;lt;branch-name&amp;gt;&lt;/code> 来简单地实现切换。有趣的是，我们还可以用 &lt;code>git switch -c &amp;lt;branch-name&amp;gt;&lt;/code> 来创建新分支的同时切换过去。也就是说，&lt;code>git switch -c&lt;/code> 命令和 &lt;code>git checkout -b&lt;/code> 几乎是等价的。另外我们可以使用 &lt;code>git switch -&lt;/code> 来直接跳回上一个分支。&lt;/p>
&lt;p>另外还可以考虑使用 &lt;code>git switch -m &amp;lt;branch-name&amp;gt;&lt;/code> 来在切换分支的同时把当前分支合并到要切换的分支上。这一点还是相当不错的，因为我们经常会遇到这样的情形：在 &lt;code>dev&lt;/code> 分支上完成某个特性之后，经过测试希望能合并到 &lt;code>main&lt;/code> 分支上。如果没有这条命令的话，我们可能需要先 &lt;code>git checkout main&lt;/code> 之后再 &lt;code>git merge dev&lt;/code>，而有了这条命令我们就可以简单地 &lt;code>git switch -m main&lt;/code> 了。&lt;/p>
&lt;p>总之，如果你需要切换分支，你就可以使用 &lt;code>switch&lt;/code> 这个命令。语义很明确，不是吗？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git merge&lt;/code>&lt;/p>
&lt;p>这个命令，如它的名字一样，是用来合并分支的，或者，不那么明显地，&lt;em>合并到当前分支&lt;/em>。它的使用方式相对而言比较简单，就是单纯的 &lt;code>git merge &amp;lt;branch-name&amp;gt;&lt;/code>。&lt;/p>
&lt;p>这个命令的主要问题是，合并过程中会出现恶魔般的 &lt;em>冲突&lt;/em>。解决冲突实在是一件令人头痛的事情（在我看来）。为了避免（逃避）合并冲突后的麻烦，你可以考虑 &lt;code>--abort&lt;/code> 参数来告诉 Git 如果合并失败就什么都别动。然而，要是你真想合并，到底还是要解决冲突的。&lt;/p>
&lt;p>其实解决冲突就是一个 “选择应用谁的代码” 的过程。Git 会在发生冲突的地方用箭头标出来本分支和被合并分支的内容，你要做的就是把你不要的那个部分删掉然后保存。另外，合并会创建一个新的提交。如果你不喜欢默认提交信息，可以考虑使用 &lt;code>-e&lt;/code> 参数来告诉 Git 你打算自己编辑合并产生的提交的提交信息。&lt;/p>
&lt;p>最后就是 Git 合并时有不同的策略。我们这里不多介绍，大部分情况可以使用 &lt;code>ff&lt;/code> 模式，即 &lt;em>Fast Forward&lt;/em> 模式。这个模式会让你的提交树看起来是一条直线，即如果历史提交相同的话就让两个分支有同样的提交了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>分支相关的基本命令我们就先介绍到这里吧。有了上面的介绍，相信你已经可以运用 Git 的分支功能了吧~&lt;/p>
&lt;h2 id="git-的概念们">Git 的概念们
&lt;/h2>&lt;p>然而，止步于介绍使用 Git 的方式，总是觉得不够透彻。知其然还要知其所以然，我们既然是在介绍 Git，那就尝试把 Git 更深一些（其实也没那么深）的概念多介绍一些吧。&lt;/p>
&lt;h3 id="仓库-repository">仓库 (Repository)
&lt;/h3>&lt;p>我们几乎所有的 Git 项目都是从建立或者克隆 Git 仓库开始的。仓库是一个比较大的概念，我们和 Git 相关的所有内容都是要从仓库出发的，所有的信息都会存储在仓库中。&lt;/p>
&lt;p>那么 “所有信息” 都有什么呢？这个问题会比较深，我们从表观的理解来讲，首先肯定得有我们工作内容息息相关的内容，毕竟 Git 就是用来管理它们的。另外就是和 Git 相关的内容了，大部分都存储在 &lt;code>.git&lt;/code> 文件夹中，还有一些零散的 &lt;code>.gitignore&lt;/code> 文件。其中 &lt;code>.git&lt;/code> 存储了这个仓库的所有和 Git 直接相关的内容，例如文件快照，提交记录，不同的分支记录等等，都会以特殊的结构记录下来。这也意味着，如果你删了 &lt;code>.git&lt;/code> 文件夹，那么这个仓库就没了，Git 的记录就全都消失啦。删除之前要好好想清楚咯~&lt;/p>
&lt;p>然后 &lt;code>.gitignore&lt;/code> 也是能控制 Git 行为的文件。它能够让 Git 不记录某些文件。比如说你有一些测试文件，它们其实不应该被记录在仓库里，只希望在本地有一份方便测试而已，那么就可以把他们的名字或者所在文件夹写进 &lt;code>.gitignore&lt;/code> 里。&lt;/p>
&lt;p>总之，Git 仓库就是这么个总的玩意儿了。有时我们会简称仓库英文为 &lt;em>repo&lt;/em>，我还挺喜欢这个名字。&lt;/p>
&lt;h3 id="工作目录-working-directory--working-tree">工作目录 (Working directory / Working tree)
&lt;/h3>&lt;p>这实际上就是我们正在编辑的项目目录。比如说我们从网上克隆了一个仓库之后，我们会进入这个仓库的目录里。这个仓库的根目录就是所谓的工作目录了。至于为什么叫 “工作树”，我个人看法是因为 Git 分支的存在让整个仓库像树一样伸展开，或者是说目录下的文件层级结构像树一样吧。不过怎么想都觉得有点怪，毕竟如果是说仓库分支的话，我们应该是在树叶上而不是在树上吧……&lt;/p>
&lt;p>然而，不深究的话，我们干活儿的地方就是工作目录。就是这样。&lt;/p>
&lt;h3 id="暂存区-staging-area">暂存区 （Staging Area）
&lt;/h3>&lt;p>其实我们应该已经介绍过暂存区了。就像它的名字一样，暂存区是用来暂时存下 “觉得改的差不多了” 的内容的地方。我们用 &lt;code>git add&lt;/code> 命令来把修改好的内容放在暂存区内等待提交。如果感觉暂存区的内容有不妥的地方，我们可以随时打回来重新修改。我们也可以把一些内容从暂存区撤下来。总之，暂存区给了我们再次考虑的机会。而假如我们认为 “暂存区的东西我很满意，可以提交了”，我们就可以用 &lt;code>git commit&lt;/code> 来提交 &lt;em>暂存区&lt;/em> 的内容到分支上（或者仓库，取决于你怎么看这个行为）。&lt;/p>
&lt;p>总之，暂存区就是一个介于 “保存文件” 和 “保存整个工作目录状态” 之间的一个地方。这也决定了 Git 的工作流是 &lt;code>修改文件 -&amp;gt; 保存文件 -&amp;gt; 交给暂存区 -&amp;gt; 提交至分支/仓库&lt;/code>。&lt;/p>
&lt;h3 id="分支-branch">分支 (Branch)
&lt;/h3>&lt;p>相信你已经对分支有所了解了。我们在创建仓库的同时，会创建一个主分支，曾经主分支名称为 &lt;code>master&lt;/code>，后来因为一些政治原因，现在更多叫 &lt;code>main&lt;/code> 了。除了主分支外，我们还可以有很多别的分支。这些分支允许我们在仓库里存储不同的信息，不同分支间不会产生干扰，而在我们希望的时候我们又可以对分支们做出诸如合并、删除等的改动。&lt;/p>
&lt;p>分支就像平行世界一样，我们可以让两个分支拥有同样的过去，在某个地方发生变化，最后独立演化下去。而分支胜过平行世界的地方在于，我们可以在没有直接分歧的情况下把两个分支合并在一起，而不会出现 “我才是蜘蛛侠” 的问题。&lt;/p>
&lt;p>分支可以说是 Git 的灵魂和精髓了。推荐多运用分支进行项目管理，相当好用。遇事不决开个分支先测试一下，这不失为一个好办法。&lt;/p>
&lt;h3 id="提交-commit">提交 (Commit)
&lt;/h3>&lt;p>我们有了一个分支之后我们就需要向这个分支不断做出提交了。每一次的提交都会让这个分支的记录变多一些，分支实际上也是记录的每一次的提交。大白话讲，提交就是存档，只不过这些存档要依附在某个世界线（分支）上而已。&lt;/p>
&lt;p>提交可以说是组成分支的部分。当我们查看分支具体有什么的时候，映入我们眼帘的就是每一次的提交记录。所谓的合并分支，也不过是比较两个分支之间的提交情况，如果没有冲突的提交就可以顺利合并了。&lt;/p>
&lt;p>要注意的是，在 Git 里我们不提交文件本身，我们提交的是文件的变更。也正是由于 &lt;strong>变更&lt;/strong> 这一关键特征，让 Git 可以高效地进行版本控制，不过坏处也有，那就是面对二进制文件就显得有点笨笨的了：二进制文件可以认为是一变全变的，不像文本那样可以有明显的局部改动。这也说明我们应该尽量让 Git 记录纯文本的文件而非二进制文件。&lt;/p>
&lt;p>另外，需要再提醒的是，提交只会提交暂存区内的内容。如果有改动发生但没有放在暂存区里的话，提交是不会搭理这些改动的。这一点还请注意。&lt;/p>
&lt;h3 id="远程remote">远程（Remote）
&lt;/h3>&lt;p>虽然我们还没有介绍太多和远程仓库/托管平台的内容，但远程仓库确实是在 Git 设计之初就已经有了的关键概念了。&lt;/p>
&lt;p>我们介绍过，Git 一开始的设计目的是所谓 &lt;em>分布式&lt;/em> 版本管理系统。这个 &lt;em>分布式&lt;/em> 就在于每个人都可以拥有一份源代码，然后大家可以互相传递自己的修改，也可以自由选择是否进行合并别人的修改。这样去中心化的特点是相当超前的设计。而为了实现这样的设想，我们必须让 Git 拥有连接到别人仓库的能力。远程也正是这么个东西。&lt;/p>
&lt;p>Git 可以把网络上的仓库作为自己的远程库来使用。我们通常不直接和远程库中的文件交互，而是把提交作为基础单元和远程库进行交互。当我们有了新的提交或者新的分支时，我们就可以把本地的这些改动 &lt;em>推送 (push)&lt;/em> 到远程仓库；当远程仓库有了新的变动时，我们可以把新的变动 &lt;em>拉取 (pull)&lt;/em> 到本地来。我们会在下一节对 Git 的远程功能进行更详细的介绍。&lt;/p>
&lt;p>总之，Git 的远程仓库让一份代码可以被保存在多个位置，并且让我们和这些位置的仓库进行交互，这样就能让我们和别人进行协作了。然而，由于现实协作的众多需求，最终 Git 还是发展出了很多代码托管平台，来方便大家存储 Git 的远程库，并让大家在远程库上进行协作，避免直接塞给别人电脑上。&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>我必须立刻承认我这篇文章离不开 &lt;code>tldr&lt;/code>，准确来说是 &lt;code>tealdeer&lt;/code> 的帮助。很难想象没有 &lt;code>tldr&lt;/code> 我要怎么介绍可用命令。唉，我还是对 Git 不够熟悉。如果里面有任何的错漏，又或是对这个系列有什么建议，请直接告诉我，谢谢，我会及时修改的（球球了，告诉我哪里写的不好吧，呜呜呜）。&lt;/p>
&lt;p>另外我还想推荐一个很不错的网站，&lt;a class="link" href="https://learngitbranching.js.org/" target="_blank" rel="noopener"
>Learn Git Branching&lt;/a>，一个让你在实际操作中练习 Git 分支管理的网页，从进行提交，创建分支，合并分支，到变基 (Rebase)，远程库协作等复杂操作，全都有涉猎。我花了一下午通关，收获很大，因此墙裂建议。&lt;/p>
&lt;p>下一节就是我们的最后一节内容，我打算聊聊 Git 的远程协作功能，以及协作时的注意事项等等。另外，由于深感 Git 命令之繁杂，我有计划做一个小工具来通过问答的方式给出合适的 Git 命令。我暂时将这个工具命名为 &lt;code>Giao&lt;/code>，希望不会难产吧，哈哈。有兴趣的话也可以关注我/给我提建议，谢谢啦。&lt;/p></description></item><item><title>（也许是）一个 Git 教程？其一</title><link>https://a-moment096.github.io/p/%E4%B9%9F%E8%AE%B8%E6%98%AF%E4%B8%80%E4%B8%AA-git-%E6%95%99%E7%A8%8B%E5%85%B6%E4%B8%80/</link><pubDate>Mon, 28 Jul 2025 22:49:16 +0800</pubDate><guid>https://a-moment096.github.io/p/%E4%B9%9F%E8%AE%B8%E6%98%AF%E4%B8%80%E4%B8%AA-git-%E6%95%99%E7%A8%8B%E5%85%B6%E4%B8%80/</guid><description>&lt;img src="https://a-moment096.github.io/posts/Shell_Note/Git_How/Tatara%20Kogasa.jpg" alt="Featured image of post （也许是）一个 Git 教程？其一" />&lt;p>&lt;em>Git 真的很好用，但是 Git 的命令真的好复杂。简单整理一下，就当写个教程好了~&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://www.pixiv.net/en/users/75383094" target="_blank" rel="noopener"
>夏空&lt;/a> 太太所画的 &lt;a class="link" href="https://www.pixiv.net/en/artworks/116876998" target="_blank" rel="noopener"
>多多良 小伞&lt;/a>，可爱捏~ 那就来一曲小伞的个人曲吧&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=22636608" theme="#2980b9" loop="never">&lt;/meting-js>
&lt;h2 id="git熟悉又陌生的名字-">Git，熟悉又陌生的名字 ……
&lt;/h2>&lt;p>也许是所处环境的原因，我身边有很多人不知道 Git 是什么。他们都听过 &lt;em>Github&lt;/em>，但很多却只知道上面有好多程序和程序员。虽然也没错，但是并不准确；而当我说我在用 &lt;em>Git&lt;/em> 的时候，会有人把 &lt;em>Git&lt;/em> 和 &lt;em>Github&lt;/em> 混为一谈；很多人觉得 Git 很复杂，顺带觉得 Github 也很复杂…… 为此，我想分享一下我对 Git 和 Github 的理解，聊聊 Git 和 Github 都是什么。&lt;/p>
&lt;p>所以，如果你不了解 Git 是什么，那我很荣幸能在这里向你简单介绍它。&lt;/p>
&lt;h3 id="所以到底什么是-git版本控制啊">所以到底什么是 Git？版本控制？啊？
&lt;/h3>&lt;p>所谓的 Git，它就是：&lt;/p>
&lt;p>&lt;strong>&lt;center>一款为程序开发的存档系统。&lt;/center>&lt;/strong>&lt;/p>
&lt;p>是的，事实就是这样。游戏存档。卡关的时候/做支线的时候/后悔的时候可以进度回溯的游戏存档。如果你在翻阅 &lt;em>ProGit&lt;/em> 或者某些教程时不太明白什么是 &lt;em>版本控制系统&lt;/em>，没关系，就是游戏存档（程序用）的比较花哨的名字。&lt;/p>
&lt;p>不过，为了能高效地，更好地服务程序员，Git 自然有了一大票复杂的功能，且每个子功能还会做特别多的细分，另外对每个存档都可以有非常复杂 &lt;del>（麻烦）&lt;/del> 的，细致 &lt;del>（啰嗦）&lt;/del> 的控制。然而，这依旧不能让它摆脱它就是个存档系统的事实。&lt;/p>
&lt;p>一旦你接受了这个设定，那么 Git 就其实没有多少秘密了。&lt;/p>
&lt;h3 id="ok但是听你说好像很麻烦">OK，但是听你说好像很麻烦……
&lt;/h3>&lt;p>不得不承认的是，正如上面所说的那样，Git 的命令实际上可以非常地复杂。如果你愿意翻阅它的 man-page，你会发现内容出奇地长；而当你尝试用 &lt;code>git --help&lt;/code> 来获取一些简单有效的信息的时候，很抱歉，&lt;code>git --help&lt;/code> 只会告诉你你能怎么做，并伴随着看不太懂的 usage，却不太会告诉你怎么做能做什么。&lt;/p>
&lt;p>然而，转折来了。首先，如果你受环境所限，只能从命令行操作 Git，待会儿介绍的四五个命令几乎就能覆盖 80% 的使用场景了。而如果你的环境支持你使用图形化的界面，那么如果不是命令行的忠实用户，完全可以挑个 GUI 程序，比如和 Github 集成度高的 &lt;em>Github Desktop&lt;/em>，界面美观现代，功能也已经足够丰富，没必要和自己过不去。&lt;/p>
&lt;p>所以，结论是：Git 很复杂，但是我们可以用的很简单呀。它很强大，很好，但这不影响我只需要那几个最基础的功能。最重要的是，当你需要更复杂的功能的时候，互联网永远是你的好朋友。你完全可以现场上网搜索，大概率会有来自 StackOverflow 的朋友向你答疑解惑（贴答案）（好几年前且点赞特别高的）。&lt;/p>
&lt;p>So, don&amp;rsquo;t be afraid! Just try it!&lt;/p>
&lt;h3 id="行但是-git-和-github-到底是什么关系">行，但是 Git 和 Github 到底是什么关系？
&lt;/h3>&lt;p>这算是很常见的问题了。解释起来也很简单：Github 能提供云存档功能。就像 Steam 有游戏云存档一样，Git 也可以有个云存档。只不过，Steam 有个专门的服务器来帮你自动地存好你的游戏内容，而 Git 则可以允许你选择你喜欢的地方存你的代码存档。&lt;/p>
&lt;p>而 Github，正是那个大部分程序员都喜欢的选择。不仅如此，Github 上传的存档还兼具展示功能，大家可以在 Github 上给自己喜欢的代码存档投票，也可以把别人的存档下载到自己电脑上，甚至可以尝试和别人一起组排。所以，说是交友网站，也未尝不可（也许）&lt;/p>
&lt;p>那么我可以选择别的地方存放存档吗？当然可以！除了 Github，还有很多很多的 Git 服务提供商。你还可以 &lt;em>自建 Git 服务&lt;/em>！甚至，Github 显得有些 “&lt;em>违背&lt;/em>” Git 的初衷：分布式的存档存储。什么意思呢？Git 一开始是打算，让所有的代码开发者（玩家）都留一份存档，然后大家就可以一起攻略组排了。大家都保留一份源码，这不就相当于大家都做存储功能了吗？只不过随着合作要求的提高和开源社区的扩大，Github 这样一个公开自己代码的地方就这么自发地出现了。&lt;/p>
&lt;p>总而言之，Git 是存档工具，Github 是大家上传/分享/讨论/合作云存档的地方。&lt;/p>
&lt;h3 id="好耶我逐渐理解一切">好耶，我逐渐理解一切！
&lt;/h3>&lt;p>是这样的，Git 就是做这么个事儿。也许你会看到一些介绍一开始会提 Git 使用的技术多么先进，多么高效，多么体现开源精神，然后不明所以。然而 Git 就是做这么个代码存档的东西，为了使用它以期了解它的话，大框架就是这样的。&lt;/p>
&lt;p>然而这里还是要提个醒：上面也许的确抓住了 Git 的核心目的，但是依旧是很粗糙的，非常概括性的。上面的文字只能帮助 &lt;em>了解 Git 是什么&lt;/em>，并不能告诉你 &lt;em>Git 怎么做的&lt;/em>。另外，使用 Git 的命令完成最基础的工作是很简单，但是在切实明白一条命令到底在做什么前，&lt;strong>请最好不要盲目运行这条命令&lt;/strong>。实际上，要想运用好 Git 管理你的代码/项目，还是需要了解一些关于 Git 究竟在背后怎么做的知识的。&lt;/p>
&lt;p>所以，如果你还对 Git 感兴趣，或者想把 Git 用起来的话，我们就来讲一些技术细节吧~&lt;/p>
&lt;h2 id="要怎么用-git-存档">要怎么用 Git 存档？
&lt;/h2>&lt;p>想解答这个问题，我们不可避免地要接触一些没啥意思的概念。与其直接介绍它们，我们先来看看，日常开发会怎么使用 Git 吧。&lt;/p>
&lt;h3 id="tig-的一天">Tig 的一天
&lt;/h3>&lt;p>Tig 是热爱 Minecraft 的忠实玩家。他很享受创造神的感觉，毕竟他就是被游戏名吸引而来的。今天他计划开展一个新的工作：制作一个百万刷铁机！&lt;/p>
&lt;p>Oh no! Tig 的 Minecraft 除了点奇怪的问题！他被告知，Minecraft 的图形界面已经坏了，取而代之的，他可以用代码来操控角色并任意创造游戏中的物品，且他只能用 &lt;code>git&lt;/code> 来做存档（究竟是谁干的，真坏呀）。Tig 感到心里五味杂陈：这还是 Minecraft 吗？然而他心中有一个信念：我一定要做好这个刷铁机，即便我能直接虚空点出来铁块！等游戏恢复的时候，就可以在这台刷铁机的基础上继续快乐玩耍啦！&lt;/p>
&lt;p>于是，Tig 用 &lt;code>git init&lt;/code> 创建了一个空世界的存档。然后就开始在存档里用代码一行行写他在这个世界里要做些什么……&lt;/p>
&lt;p>过了一会儿，Tig 妈妈喊他要他吃午饭了。虽然不愿意，Tig 还是要先放下手上的工作。他打算先暂时保存一下，于是使用 &lt;code>git add .&lt;/code> 来保存好自己手上的所有写好的代码。毕竟，他也不知道是不是有的地方有点问题，带会儿还要调一下，他现在也是被拉过去吃饭的。&lt;/p>
&lt;p>吃完饭后还睡了个午觉，Tig 回来又写了一会儿。他对自己的成果很满意，因为他已经想办法把村里的刁民挪到了高空中了。这实在是不太容易，他不希望待会儿犯蠢丢掉这几个村民。于是他决定要存档。他先用 &lt;code>git add .&lt;/code> 来保存所有文件的所有改动，然后用 &lt;code>git status&lt;/code> 查看了改动的文件们。感觉没什么问题，他使用 &lt;code>git commit&lt;/code> 来正式保存了这个存档。存档系统问他要他给自己的改动写个简述，他写了 &lt;code>村民挪好了，准备搭框架&lt;/code>。&lt;/p>
&lt;p>过了一个下午和一个晚上，Tig 终于在睡觉前把刷铁机搞好了！实在是一个无比伟大的创举，Tig 忍不住把它分享出去，也方便自己在其他电脑上继续工作。他创建了 Github 账号和一个仓库，并且用 &lt;code>git push&lt;/code> 把这个存档放在了它的仓库里。然而睡前他还是想先在另一台电脑上先把存档下下来，于是使用 &lt;code>git clone &amp;lt;git-link&amp;gt;&lt;/code> 来把仓库克隆到本地。&lt;/p>
&lt;p>晚上躺在床上，他一想到以后就可以把存档用 &lt;code>git push&lt;/code> 方便地推送到 Github 上，并且用 &lt;code>git pull&lt;/code> 在另一台电脑上来获取最新的改动了，他就不自觉地笑出声，心里盘算着怎么在明天做一些改善，给刷铁机套个好看的壳子之类的……&lt;/p>
&lt;p>可喜可贺，可喜可贺！~&lt;/p>
&lt;h3 id="所以他都干了些啥">所以，他都干了些啥？
&lt;/h3>&lt;p>Tig 的故事貌似有点无聊，毕竟，给 Git 硬套个背景，貌似有点牵强；更重要的是，谁家好人这么玩 Minecraft 呀！然而他用到的命令，几乎就是我平时常用的所有命令了。我们来总结一下吧。我们就不再多提游戏的事，毕竟好像都戳穿了是在写代码……&lt;/p>
&lt;ul>
&lt;li>&lt;code>git init&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>我们可以用 &lt;code>git init&lt;/code> 来在本地创建/初始化一个 Git 仓库。这代表着，你打算用 Git 来管理这个文件夹了。很简单的命令，其实频率也很低，因为你很少反复初始化一个仓库。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git add .&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>一个频率还挺高的命令。你在仓库内的修改，Git 都不会立马记录下来。他怕他立马记下来之后，随后用户又马上反悔。另外，这样立马就记录下来，反而和单纯的文件保存功能有所重叠了。&lt;/p>
&lt;p>所以，当你觉得目前的进展还不错，你就可以用这个命令来 &lt;em>暂存&lt;/em> 当前的所有修改。这里的 “暂存” 有两个意思：一是 Git 确实是把你的修改保存到了 &lt;em>暂存区&lt;/em> 里，另一个则是你要是现在发现有个修改不太对，可以很方便的从暂存区里撤下来。&lt;/p>
&lt;p>&lt;code>git add .&lt;/code> 里的这个 &lt;code>.&lt;/code> 就是当前目录的意思，也就是说这个目录下的所有文件我都要暂存起来。Git 会很聪明地只保存修改，这也是设计之初就确定的。如果你只想保存一部分，那就写他们的名字吧，或者写对应的目录，都可以，能定位到就好。&lt;/p>
&lt;p>不过，总之，这个命令就是让你暂存当前所有修改的。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git status&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>一个我很爱用的命令。可以向你报告当前暂存区的情况以及工作目录的情况。比如什么文件被修改了，哪些文件是新加的，谁被删除了，而这些改动里谁被暂存下来，又有哪些你没暂存下来。&lt;/p>
&lt;p>如果你的 Git 是默认配置，他还会提醒你可以怎么撤回某些修改。跟着做就好了。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git commit&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当你对你的进度感到满意时，你就可以用 &lt;code>git commit&lt;/code> 来提交你暂存区的东西了。所谓的提交，就是形成一个存档，你后续可以回来的一个存档。这个存档里你的仓库的模样会被冻结下来，当你回到这个提交时，一切都会回到当初的模样。非常的美好。&lt;/p>
&lt;p>要注意的有两点，一是 &lt;code>git commit&lt;/code> 只提交 &lt;strong>暂存区&lt;/strong> 的内容。没被暂存的，还会在原地等待你先用 &lt;code>git add&lt;/code> 暂存起来，或者等你撤回那些修改。二是，&lt;code>git commit&lt;/code> 会要求你给这个提交留个注释。请不要省事瞎写个什么东西，因为未来的你可能会对瞎写注释的现在的你感到伤心。默认情况下，&lt;code>git commit&lt;/code> 会打开你的文本编辑器然后让你开写，而如果你觉得很麻烦不想开编辑器，可以用 &lt;code>git commit -m &amp;quot;messages&amp;quot;&lt;/code> 来把这行 &lt;code>messages&lt;/code> 作为提交注释。&lt;/p>
&lt;p>可以再补充两点：如果你提交过后发现因为小失误忘记暂存某些内容或者有些小改动的话，你可以在把改动加入暂存区后补充到这次提交里，用法则是 &lt;code>git commit --amend&lt;/code>。另外，提交要慎重，因为提交过的内容就不是那么好修改了。你当然能改，但是相比 &lt;code>git add&lt;/code> 到暂存区的内容而言，实在是要麻烦一些。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git push&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>把你当前的内容推送到远程仓库里。如果你的仓库是用 &lt;code>git clone&lt;/code> 获得的且你拥有这个仓库的修改权限，那么 &lt;code>git push&lt;/code> 就可以简单直接地把 &lt;em>这条分支&lt;/em> 的修改推送到远程。&lt;/p>
&lt;p>我们这里还是先不讲什么分支，也先不谈远程协作之类的东西。不过就常用命令介绍来说，&lt;code>git push&lt;/code> 算是比较常用且同样很简单的一个命令了。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git clone&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>把 git 仓库从远程下载到本地。后面跟上仓库的链接就好。如果你是从 Github 来克隆到本地的话，点绿色按钮的 Clone 就会看到你可以怎么做。你可以直接复制里面的命令然后执行。&lt;/p>
&lt;ul>
&lt;li>&lt;code>git pull&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>把远程仓库的内容拉取到本地。和 &lt;code>push&lt;/code> 的方向是近乎相反的。如果远程有个修改，你希望同步到本地，那就 &lt;code>git pull&lt;/code> 一下吧。&lt;/p>
&lt;p>这个命令要注意的点是，不要在本地有修改没存的情况下执行 &lt;code>git pull&lt;/code>。如果本地和远程起了冲突，会很麻烦。避免麻烦的最好方式是，先 &lt;code>git pull&lt;/code> 之后再做自己的修改。&lt;/p>
&lt;h3 id="画个流程图">画个流程图
&lt;/h3>&lt;figure class="mermaid-container">
&lt;div class="mermaid">flowchart LR
A[开始] --> B[git init\n创建新仓库]
A --> C[git clone\n克隆已有仓库]
B --> D[在仓库中做出变更]
C --> D
D -- 暂时存下 --> E[git add .\n暂存已有变更]
E -- 满意已暂存内容 --> F[git commit\n提交所有暂存的变更]
F --> G[git push\n上传至远程仓库]
G --> H[其他设备: git pull\n从远程获取最新变更]
H --> D
F --> D
&lt;/div>
&lt;figcaption>Git 日常工作流&lt;/figcaption>
&lt;/figure>&lt;h2 id="好累先聊到这里吧">好累，先聊到这里吧
&lt;/h2>&lt;p>我们已经介绍了 Git 是什么以及日常会用到的功能。我可以说，除了剩下关于 Git 另一个非常强大的功能：分支的两三个命令，以及一两个我觉得好用的命令以外，剩下的命令都是我很不常用的命令了。剩下的命令几乎只有在我搞砸了什么东西的时候临时从网上搜来救火用的，而保持良好的使用习惯的话真的是很少用到这些麻烦/复杂/难以理解的功能的。&lt;/p>
&lt;p>所以，如果你看到了这里，恭喜你已经掌握了 Git 单分支的工作流程了。就是改文件，暂存，提交，推送。而下一章我们会看看 Git 被吹的神乎其神的分支到底是个啥，再解释 Git 中的一些概念。&lt;/p>
&lt;p>这里要特别声明的是，这篇文章的比喻借鉴了 &lt;a class="link" href="https://space.bilibili.com/337242418" target="_blank" rel="noopener"
>HDAlex_John&lt;/a> 的 Git 教程系列：&lt;a class="link" href="https://www.bilibili.com/video/BV1Hkr7YYEh8" target="_blank" rel="noopener"
>给傻子的 Git 教程&lt;/a>，讲的相当好。好在我不是傻子，看着也不累，哈哈哈哈。（还是自己写起来比较累）&lt;/p>
&lt;p>那么最后，感谢你看到这里，祝你心情愉悦，生活顺遂！~&lt;/p></description></item></channel></rss>