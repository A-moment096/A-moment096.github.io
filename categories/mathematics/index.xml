<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mathematics on A Moment's Rest</title><link>https://a-moment096.github.io/categories/mathematics/</link><description>Recent content in Mathematics on A Moment's Rest</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://a-moment096.github.io/categories/mathematics/index.xml" rel="self" type="application/rss+xml"/><item><title>2025! 非零的最后一位数字是多少？</title><link>https://a-moment096.github.io/p/2025-%E9%9D%9E%E9%9B%B6%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%A4%9A%E5%B0%91/</link><pubDate>Mon, 25 Aug 2025 18:01:23 +0800</pubDate><guid>https://a-moment096.github.io/p/2025-%E9%9D%9E%E9%9B%B6%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%A4%9A%E5%B0%91/</guid><description>&lt;img src="https://a-moment096.github.io/p/2025-%E9%9D%9E%E9%9B%B6%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%A4%9A%E5%B0%91/qingshuiyin.jpg" alt="Featured image of post 2025! 非零的最后一位数字是多少？" />&lt;p>&lt;em>在知乎上看到了&lt;a class="link" href="https://www.zhihu.com/question/666502327" target="_blank" rel="noopener"
>这样一个有趣的问题&lt;/a>，以及&lt;a class="link" href="https://www.zhihu.com/question/666502327/answer/18810753693" target="_blank" rel="noopener"
>很厉害的回答&lt;/a>，实在是很有意思。这里就写一写我的解决这个问题的方法以及当时的心路历程吧。&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://www.pixiv.net/en/users/8605991" target="_blank" rel="noopener"
>fasnakegod&lt;/a> 大大的 &lt;a class="link" href="https://www.pixiv.net/en/artworks/124177921" target="_blank" rel="noopener"
>清水吟&lt;/a>，搭配的曲子是 &lt;a class="link" href="https://ddby.jp/" target="_blank" rel="noopener"
>&lt;strong>DDBY&lt;/strong>&lt;/a> 的 &lt;em>Cramped space&lt;/em>，笛声真的很棒，搭配轻快的鼓组和旋律，给人一种很悠闲放松的感觉呢。希望你也喜欢~&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=715690" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="问题介绍">问题介绍
&lt;/h2>&lt;p>如果您不想点开那个链接的话，这个问题实际上只有一行：求 2025! 从右向左起第一个不为0的数字是什么。这算是一道奥数题吧，同时也是某本书（&lt;em>具体数学&lt;/em>）上的课后习题。&lt;/p>
&lt;p>由于 2025! 几乎是没法用计算器简单计算验证的（即便知乎上有神人&lt;a class="link" href="https://www.zhihu.com/question/666502327/answer/18577793245?share_code=8Xj75jf4cL99&amp;amp;utm_psn=1942598977787761098" target="_blank" rel="noopener"
>算出来了这个值&lt;/a>），我们可以权当这个问题是在问，某个大数字 $n$ 的阶乘：$n!$ 在十进制表示下的，从右至左数第一个非零数字是几。&lt;/p>
&lt;p>这个待求数字描述起来好麻烦。我们就称这个数字为 $A$ 好了。另外，我们稍微滥用一下符号，用 $A$ 来取出我们要的那个数字，比如数字 $12345000$ 的 $A$ 就记作 $A(12345000) = 5$ 了。另外我们为了方便讨论，把 $n!$ 的结果表示为 $a_k\dots a_3 a_2 a_1$，即给每一位上的数字都编个号。如 $120$ 的 $a_3 = 1$，$a_2 = 2$，$a_1 = 0$。&lt;/p>
&lt;p>好了，我们现在开始吧，尝试解决这个问题。&lt;/p>
&lt;h2 id="第一次尝试肯定得和质数有关吧">第一次尝试：肯定得和质数有关，吧？
&lt;/h2>&lt;p>这个题肯定得有个通用算法，但是在发现这个通用解法前，我们还是手动尝试几个简单的值，观察下有没有什么规律吧。&lt;/p>
&lt;h3 id="不要-0谢谢">不要 $0$，谢谢。
&lt;/h3>&lt;p>比如我们计算 $5! = 1\times 2\times 3\times 4\times 5 = 120$，那么我们要的 $A$ 就等于 2 了。这个结果里有一个0，它源自于 $2$ 和 $5$ 的乘积。这一定很重要！我们还知道 $4\times 25 = 100$，$8\times 125 = 1000$ 等。我们肯定在求 $A$ 时肯定不希望考虑这些 “没用” 的数字，因为它们的结果对我们要求的 $A$ 没有任何的影响。&lt;/p>
&lt;p>我们更进一步，考虑上面几个乘积，实际上都是 $2$ 和 $5$ 的次幂相乘，或者说有几个 $2$ 和 $5$ 的配对。我们可以发现：如果阶乘在被质因数分解后，出现了若干 $2$ 和 $5$ 配对，那么这个配对就对最后的结果没有影响。&lt;/p>
&lt;p>好，那我们就把阶乘拆成质因数们吧！然后拆掉里面的每个 $2-5$ 对儿，最后就只剩下最后的一堆结果，我们把它们乘起来看最后一位数字，肯定就是 $A$ 了……&lt;/p>
&lt;p>对，对吗？算了，我们先算个简单的，我们让 $n = 10$ 看看结果吧。我们先找到质数们。10 以下的质数只有 $2, 3, 5, 7$ 四个，然后把 10 以下的数字们拆成质因数后统计它们的个数，得到：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">质数&lt;/th>
&lt;th style="text-align: center">个数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">2&lt;/td>
&lt;td style="text-align: center">8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">3&lt;/td>
&lt;td style="text-align: center">4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">7&lt;/td>
&lt;td style="text-align: center">1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>然后我们删掉俩 $2$-$5$ 对后把别的乘起来，得到结果是：$36288$ ，所以 $A = 8$&lt;/p>
&lt;p>OMG 好麻烦，怎么就两对儿？这还只是 $10$ 以下的质数，$100$ 以下的质数有 25 个嘞。这要怎么搞？&lt;/p>
&lt;h3 id="其实我们应该只用算-a-来着">其实我们应该只用算 $A$ 来着……
&lt;/h3>&lt;p>但是我们好像也不用算整个结果吧，得到 $A=8$ 就已经 OK 了的样子。而我们想得到 $A$ 好像也只需要关注每一次乘出来的结果的个位数就好？&lt;/p>
&lt;p>我们看看这四个数字的次幂，它们的个位数都有什么特点：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">质数&lt;/th>
&lt;th style="text-align: center">1次&lt;/th>
&lt;th style="text-align: center">2次&lt;/th>
&lt;th style="text-align: center">3次&lt;/th>
&lt;th style="text-align: center">4次&lt;/th>
&lt;th style="text-align: center">5次&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">2&lt;/td>
&lt;td style="text-align: center">2&lt;/td>
&lt;td style="text-align: center">4&lt;/td>
&lt;td style="text-align: center">8&lt;/td>
&lt;td style="text-align: center">6&lt;/td>
&lt;td style="text-align: center">2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">3&lt;/td>
&lt;td style="text-align: center">3&lt;/td>
&lt;td style="text-align: center">9&lt;/td>
&lt;td style="text-align: center">7&lt;/td>
&lt;td style="text-align: center">1&lt;/td>
&lt;td style="text-align: center">3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">5&lt;/td>
&lt;td style="text-align: center">5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">7&lt;/td>
&lt;td style="text-align: center">7&lt;/td>
&lt;td style="text-align: center">1&lt;/td>
&lt;td style="text-align: center">3&lt;/td>
&lt;td style="text-align: center">9&lt;/td>
&lt;td style="text-align: center">7&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>好像有点意思，它们的结果是循环的，且实际上只有 $2$-循环 和 $3$-循环两个循环。&lt;/p>
&lt;p>等一下，我们好像还没考虑别的质数，比如什么 $11$, $13$，$17$， $19$ 等。然而，嘛，我们可以发现，任何大于 $10$ 的质数们的末位只会是 $1, 3,7, 9$ 四个数字，而它们又恰好都在 $3$-循环的样子。&lt;/p>
&lt;p>可是，即便如此，我们要怎么数质数？这个方法强烈依赖把质数的个数数清楚这样的麻烦问题的解决。感觉还是不行……&lt;/p>
&lt;h2 id="第二次尝试至少确实我们只用管最后一位">第二次尝试：至少，确实我们只用管最后一位
&lt;/h2>&lt;h3 id="重复的-1-到-9是否预示了什么">重复的 $1$ 到 $9$，是否预示了什么！？
&lt;/h3>&lt;p>但是好消息也有，那就是我们锁定了 &lt;strong>只管最后一位&lt;/strong> 的思路。假如我们只考虑最后一位数，我们又何必考虑什么质数什么的东西呢？比如我们考虑 $A(20!)$，那么我们就得计算 $1\times 2\times \dots \times 9 \times 10\times 11\times 12\times \dots\times 19\times 20$ 的 &lt;em>非0个位&lt;/em> 们的乘积结果，也就是反复计算 $A(9!)$。在计算结束后，我们还得考虑乘上 $10$ 里面的 $1$，以及 $20$ 里的 $2$。&lt;/p>
&lt;p>诶？好像我们计算 $A(n!)$ 可以简化为 &lt;strong>计算小于&lt;/strong> $n$ &lt;strong>每一个数对应的&lt;/strong> $A$ &lt;strong>，然后计算它们的乘积的&lt;/strong> $A$。写得更 &lt;em>数学&lt;/em> 一点就是说：&lt;/p>
$$
A(n!) = A(\prod_{i=1}^{n} i ) = A(\prod_{i=1}^{n} A(i)).
$$&lt;p>如果这个是成立的，那我们的计算完全可以只关心每个数字所对应的 $A$，因为我们始终只想要那个非零的最后一位数字。我们甚至可以有这样的等式：&lt;/p>
$$
A(A(xy))=A(A(x)A(y)).
$$&lt;p>即任意两个数乘积所对应的 $A$ 等于两个数对应的 $A$ 相乘后再取 $A$。取两次 $A$ 的主要原因是为了规避可能存在的末位的零们。那么，照这个方法的话，也许我们可以重复计算很多次 $A(9!)$，其结果是 $8$；然后数清楚有多少个对应的 $1$-$9$，即有多少个 $8$ 相乘，取到它对应的 $A$，最后再乘上不够 $1$ 到 $9$ 的几个数字的阶乘对应的 $A$。当然，最最后再取一次 $A$，就是我们要求的结果了。&lt;/p>
&lt;p>我们用 $A(20!)$ 来验证一下我们的想法吧。由上面的过程，我们可以看到个位上的 $1$ 到 $9$ 一共出现了两次 （即 $1$ 至 $9$ 和 $11$ 至 $19$）。 那么按照我们的算法， $20!$ 对应的 $A$ 那就是 $8\times 8\times 1\times 2 = 8$。&lt;/p>
&lt;p>我算的对吗？经过计算器的暴力计算，我们得到它的结果是 $2432902008176640000$，则其 $A = 4$。&lt;/p>
&lt;p>&lt;strong>太棒了，我算错了。太坏了，怎么会这样！？&lt;/strong>&lt;/p>
&lt;h3 id="5-怎么这么坏">$5$ 怎么这么坏
&lt;/h3>&lt;p>上面一套分析，竟然结果是错的？！？到底是哪里出问题了？经过仔细的验算以及一点点点点的细心，可以发现罪魁祸首是个位的 $5$，因为每当 $5$ 出现时总会让结果出现一个 $0$ 然后向前进一位，或者说，乘以 $10$ 之后再除以 $2$。&lt;/p>
&lt;p>在考虑到这点后，如果尝试把个位的 $5$ 从 $9!$ 抛掉的话，我们会发现结果的末位不会有 $0$。我们还很容易得出，事实上，如果我们抛去所有个位为 $5$ 或 $0$ 的数字的话，$n!$ 的末位就不会是0。那么我们好像可以重新组织一下这个乘积的样子，比如我们先计算个位不含有 $5$ 的数字们的乘积，对 $A(9)$ 来讲即 $4!$ 和 $9!/5!$，结果分别为 $24$ 和 $3024$。然后我们再把它们的个位相乘后乘 $5$ 或者除以 $2$，得到的结果就是我们需要的结果了。简单的计算即可知道答案是 $8$，没有问题。&lt;/p>
&lt;p>嗯？！？等一下，这两个乘积的末位依旧是同一个数字 $4$！貌似这样四个一组的数字乘积的个位一定是 $4$ 的样子！？我们好像又可以采用刚刚的思路了。之前我们是 9 个数字为一组，这种方法里包括了 $5$ 这个捣蛋鬼所以失败了，那么这次我们就采用 4 个数字为一组。为了方便，我们就叫这个组为 $S$ 好了。&lt;/p>
&lt;p>还是用 $20!$ 试一下，其中有 4 个 $S$，则我们得求 $ A(4^4) = 6$；里面有4个包含了 $5$ 为质因子的坏蛋，分别是 $1\times 5$，$2\times 5$，$3\times 5$，$4\times 5$，我们把它们乘起来，得到：&lt;/p>
$$
\prod_{i=1}^{4} i \times 5^4 = 4! \times 5^4 = 15000
$$&lt;p>最后我们把它们俩乘起来得到…… 嗯？怎么是 $90000$ ！？又是哪里出问题了？如果考虑到乘以 $5$ 在我们的问题中实际上相当于除以 $2$ 的话，我们发现：&lt;/p>
&lt;h3 id="5-还会抢走别的-2不行">$5$ 还会抢走别的 $2$，不行！
&lt;/h3>&lt;p>太坏了，实在是太坏了。还好我们还有招：$S$ 里一定有多出来的 $2$ 喂给白眼狼 $5$，我们只需要考虑喂出去多少 $2$ 给不够的 $5$ 来凑。我们也许不应该急着计算 $A(4^4)$，而是把外面的 $A$ 给去掉，因为只剩下一位数字的时候肯定不够质因子 $2$ 喂给多出来的 $5$ 的 （因为 $4$ 的幂次循环只有 $4$ 和 $6$）。经过这样的修正，我们可以得到：&lt;/p>
&lt;p>有 4 组 $S$，则这四组的个位数乘积为 $4^4 = 256$。把这个结果乘上 $4! \times 5^4$，得到 $256\times 15000 = 3840000$ 再取 $A$，就能得到结果是 $4$。这下应该没问题了。我们来把这个过程规范地描述一遍吧。&lt;/p>
&lt;p>要计算 $A(n!)$，首先我们要找出 $n$ 可以分出多少组 $S$。计算方法很简单，我们用带余除法即可。这样一来，我们就可以确定有多少个 $S$ 即多少个 $4$ 要相乘，以及剩下的余数是多少。我们记 $S$ 的组数为 $k$，记余数为 $r$。另外我们还可以知道剩下的含 $5$ 的数字都是什么，即 $5$ 的倍数都有谁。由于阶乘的特点，剩下的 $5$ 的倍数的乘积一定能写成 $k!\times 5^k$，而这里的 $k$ 正是前面 $S$ 的个数。&lt;/p>
&lt;p>那么我们得到这样的式子：&lt;/p>
$$
A(n!) = A(A(4!)^k\times k!\times 5^k\times r!) = A(4^k\times k!\times 5^k\times r!),
$$&lt;p>注意到 $4^k \times 5^k = 20^k$，则 $A(4^k \times 5^k) = A(2^k)$，我们把上式简化为：&lt;/p>
$$
A(n!) = A(4^k\times k!\times 5^k\times r!) = A(2^k \times k! \times r!) = A(A(2^k)\times A(r!)\times A(k!)).
$$&lt;p>其中由于 $r$ 是一个小于 $5$ 的数字，它的阶乘特别好算，我们甚至可以打表，而 $2$ 的幂次的个位也是以 $2,4,8,6$ 进行循环的，我们可以把注意力完全放在 $A(k!)$ 上，而 $k$ 则是原数字 $n$ 缩小了四倍后的结果。接下来我们故伎重施来求解 $A(k!)$，得到的结果带回给原式后又会得到相似的模式，我们不断重复这个过程，就能递归地得到全部化简后的式子，而以这个方法得到的结果最后会由 $2$ 的幂次和余数们的阶乘的乘积构成，我们只需要求这个式子的 $A$ 即可，这是完全可以做到的。&lt;/p>
&lt;p>我们总算得到了可用的算法了。太棒啦！然而，递归的算法总是在很精妙的同时给人以 “我能再进行简化” 的感觉。这里简化的重点应该在于 $k$。如果我们能提前把 $k!$ 解开，或者说在一开始就能有方法把 $n!$ 拆开成 $2$ 的幂次和一系列的 $r!$的话，就能不依赖递归的计算了。&lt;/p>
&lt;h2 id="第三次尝试算法一定还有提升空间">第三次尝试：算法一定还有提升空间！
&lt;/h2>&lt;p>根据刚才的分析，很明显我们要首先得到我们得计算 $2$ 的多少次幂。而这个值又由 $S$ 组的数量控制。我们得给这个 $S$ 组一个比较明确的含义了，之前说什么 $4$ 个数字为一个 $S$ 组，这还是太模糊。我们所说的一个 $S$ 组应该是这样的连续数字组，它们的个位从 $1$ 到 $4$，或者从 $6$ 到 $9$ 为一组。$S$ 组有这样的特点，那就是它们均匀地分布在 $n!$ 中且数量极易统计，对于 $n!$ 的 $S$ 组，我们只需要把 $n$ 除以 $5$ 就能得到组数，而剩下的余数我们可以留作后用。另外每个 $S$ 组组内的乘积对应的 $A$ 值一定是 $4$。这是非常重要的特点，也就是这一点能让我们进行简化计算。&lt;/p>
&lt;p>由于在进行上述的算法计算时，我们必须不断地计算 $A(k!)$ 的值。而这也就意味着我们必须多次计算每次出现的 $S$ 组的数量。有什么办法能让 $k!$ 把 $S$ 组的数量一次全吐出来呢？&lt;/p>
&lt;h3 id="假如-5-不是坏蛋的话">假如 $5$ 不是坏蛋的话？
&lt;/h3>&lt;p>那假如 $5$ 不是坏蛋，乘以 $5$ 不会让后面多 $0$ 进而影响结果，那样的话不就只有整 10 数会影响最后的结果了？这也许能给我们一些计算到底统共有多少组 $S$ 的启示。&lt;/p>
&lt;p>我们试试用那个本来错了的方法进行分组吧。按 $A(n)$ 从 1 到 9 来给 $n!$ 中的所有因数进行分组。假如我们凑齐了 9 个数字，让它们的 A 正好遍历 1 到 9, 我们就记这样一个组为 $S_{10}$。根据我们老早提过的记号，我们把 $n$ 记成 $\dots a_3 a_2 a_1$ 的话，那么我们有：$\dots a_3 a_2 0$ 个 &lt;em>个位数不为0&lt;/em> 的组，有 $\dots a_300$ 个 &lt;em>个位数为 0，但十位数不为 0&lt;/em> 的组，有 $\dots a_4000$ 个 &lt;em>个、十位数为 0 但百位不为 0 的数&lt;/em> ……&lt;/p>
&lt;p>注意到上面的分法下每个组在取 $A$ 后都是我们要的 $S_{10}$，我们就能很方便的计算 $S_{10}$ 的个数。假如 $n = 1234$，那么对应的我们要的 $S_{10}$ 的数目就是 $123+12+1 = 136$ 个了。这里值得注意的是一个边界情况，即假如我们的数字是 $9$，$90$，$990$ 这样的情况下，我们的 $S_{10}$ 实际上是 $0+1$，$9 + 1 = 10$ ，$99+9+1 = 109$ 组。如果是单纯统计 $S_{10}$ 组的话，为了解决这个纰漏，我们可以考虑检测第一位数字是否是 $9$，如果是的话就额外加上 1, 不是的话就说明没凑够所以不加。然而我们并不是单纯统计 $S_{10}$ 组，因此我们干脆不管这个边界情况，这一点我们后面再多做讨论。&lt;/p>
&lt;p>能观察到，在 10 进制下我们对 $A(n)$ 遍历 1 到 9 的分组是极为自然的过程。究其原因，这样的便利性是来源于十进制的表达方式。那么，如果要统计 &lt;em>五个一组&lt;/em> 的情况呢？这给了我们尝试 5 进制的理由。我们来试试吧。&lt;/p>
&lt;h3 id="5进制下统计所有的-s-组">5进制下统计所有的 $S$ 组
&lt;/h3>&lt;p>下面我们把 10 进制的数字直接简单地表示出来，而 5 进制的数字则会有个 5 的下标。我们还是把 5 进制下的数字表达为 $\dots a_3 a_2 a_1$。这样一来，10进制下的 $1$ 到 $4$ 就是 5进制下的 $1_5$ 到 $4_5$, 而 $6$ 到 $9$ 就是 5 进制下的 $11_5$ 到 $14_5$ 了。那 十进制下的 $30$，在 5 进制下的表示是什么呢？由于 $30 = 1\times 5^2 + 1\times 5^1 + 0\times 5^0$，其 5 进制表示则为 $110_5$。&lt;/p>
&lt;p>那么 $30!$ 里统共有多少 $S$ 组呢？我们类比上面的做法，我们首先有 $11_5$ 组个位不为 0 的组，其次有 $1_5$ 个&lt;em>十位&lt;/em>不为 0 而个位为 0 的组，一共就是 $12_5$ 即 $7$ 组。如果我们手动统计的话，$30$ 首先除以 $5$ 得到 $6$，另外由于我们的算法会出现一个 $6!$，其 $S$ 组只有一个，这样一来，$30!$ 里一共应该有 $6+1=7$ 个 $S$ 组，结果和前面的算法是一致的。&lt;/p>
&lt;p>我们再来看看 $100!$ 里有多少 $S$ 组。写为 5 进制后它是 $400_5$，那么他就有 $40_5 + 4_5 = 44_5 = 24$ 个 $S$ 组了。而使用古法统计，可以得到其首先是 $20$ 个 $S$ 组，接下来对 $20!$ 而言一共有 $4$ 个 $S$ 组，则一共是有 $24$ 个。结果也是一致的。&lt;/p>
&lt;p>太棒了，我们现在能成功分析出一个数字拥有的 $S$ 组了。然后呢？&lt;/p>
&lt;h3 id="还需要统计余数">还需要统计余数
&lt;/h3>&lt;p>在分析出一共到底有多少 $S$ 组后，我们就知道了 $A(n!)$ 计算式里 $2^k$ 中的 $k$ 了。然而，在拆出来 $S$ 组的过程中，我们还会得到一系列的余数。我们得想办法把这些余数留下来做计算。要怎么做呢？&lt;/p>
&lt;p>我们在十进制下每次除以 $10$ 的时候会得到商和余数，其余数就是右侧最后的一个数字，而商则是去掉最右侧一位数字后得到的剩余部分。这个规则对于 5 进制，甚至于任何进制，都是成立的。这样一来我们就很快能得到所有的余数了，就是它的每一位数字。比如有 5 进制数 $131423_5$，其所有的余数就是 $1,3,1,4,2,3$ 了。这里我们考虑了最左边的 $1$，原因有二：如果只考虑直接的余数的话，最后还是会碰到要乘以最左边一位数字的阶乘；另外，在做进制转换的过程中，我们是要除到结果为 $0$ 的，而最后一次的余数正是最左边的一位数字。&lt;/p>
&lt;p>那么这样一来，我们的算法就完善了。我们先统计出 $S$ 组总共的个数，得到 $k$，然后用 $k$ 模除 $4$ 得到余数，用这个余数 $r$ 计算 $2^r$ 后再乘上每一位余数的阶乘，最后取这个结果的 $A$ 即得到我们要求的 $A$ 了。&lt;/p>
&lt;p>我们尝试在新的算法下计算 $A(13!)$。它的 5 进制表达为 $23_5$，则一共有 $2_5 = 2$ 个 $S$ 组。那么它对应的 $A$ 就有 $A(13!) = A(4^2 \times 5^2 \times 2! \times 3!) = 8$，容易验算，这个结果是没问题的。&lt;/p>
&lt;p>我们再尝试计算一下 $A(20!)$。我们把 $20$ 写为 5 进制后得到 $40_5$，则我们有 $4_5$ 即 $4$ 个 $S$ 组。则我们要的 $A$ 就可以是 $A(20!) = A(A(2^4)\times 4!) = 4$，和我们上面的结果是一样的。我们再试试求 $A(63!)$，由于 $63 = 223_5$，则一共有 $24_5 = 14$ 组 $S$。此时我们要的 $A(63!)$ 就是 $A(A(2^14) \times 3! \times 2! \times 2!) = 6$。我们用 Python 算一下这个值，结果是&lt;/p>
$$1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000$$&lt;p>它的 $A$ 和我们的要求是一样的。好耶！我们成功地找到了一个可行的算法！那么既然是一个算法，我们是不是能写成程序呢？&lt;/p>
&lt;h2 id="用-python-实现一下吧">用 Python 实现一下吧~
&lt;/h2>&lt;p>我们还是选择我们亲爱的 Python。虽然说是胶水语言，但是真的很好用，特别是在处理这种东西的时候，有很多已经内置了的方程。更不必提在 3.13 版本后 Python 的交互式界面好用了很多：支持自动缩进，支持 &lt;code>exit&lt;/code> 退出等等。真的很不错。&lt;/p>
&lt;p>不多废话了。我们开始实现这个算法吧。首先自然是要把 10 进制数字转换为 5 进制。另外，待会儿我们还需要把 5 进制转换回 10 进制，所以一起实现了吧。为了某种 “广泛性“，我们干脆让这样的进制转换支持 &lt;em>任意数字为底&lt;/em> 好了。&lt;/p>
&lt;h3 id="进制转换">进制转换
&lt;/h3>&lt;p>注意到每一位数字就是除法的余数，我们可以让数字依次除以底数，最后把它们反方向拼接起来就可以了。具体实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">change_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">base&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34; Converts a decimal number to its representation in a given base. &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="n">digits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">digits&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">base&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">//=&lt;/span> &lt;span class="n">base&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">digits&lt;/span>&lt;span class="p">[::&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值得注意的是我们这里返回的是字符串，而非数字。因为数字自动是以 10 为底的。为避免我们不想要的运算，我们还是使用字符串的稳妥一些。&lt;/p>
&lt;p>另外我们要把 5 进制数字（的字符串）转换回 10 进制。这点非常简单，实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">to_decimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">str&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">base&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34; Converts a number in string representation from a given base to decimal. &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">digit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">digit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">base&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一来，我们就能自由地在 10 进制和 5 进制之间转换了。当然，为了方便，我们定义 &lt;code>to_penta&lt;/code> 函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">to_penta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">str&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">change_base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="统计-s-组个数">统计 $S$ 组个数
&lt;/h3>&lt;p>我们遇到的第一个比较难的点应该在于如何统计 $S$ 组的个数。我们之前是计算的 5 进制加法之后转换回 10 进制的。然而这样的算法不太适合计算机：它不熟悉怎么计算奇怪进制的加法。好消息是，对于加法而言，我们先加起来后进行进制转换，和先进行进制转换然后加起来是一样的效果。这里我就不证明这一点了。在知道这一点之后，我们就可以很简单地得到 $S$ 组的个数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">num_S&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">str&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="n">acu&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="n">acu&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">acu&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">to_decimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">acu&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们还需要根据这个值来决定 $2$ 的幂次的个位结果。Python 提供了好用的 &lt;code>divmod&lt;/code> 函数方便我们处理这个结果。待会儿我们就用它。而接下来的问题则是把所有的数位的阶乘都乘起来。&lt;/p>
&lt;h3 id="处理阶乘们">处理阶乘们
&lt;/h3>&lt;p>在处理阶乘前，我们可以观察到这样一个神奇的现象：每一位上的数字只有从 $0$ 到 $4$ 五种结果，其中的 $0,1$ 的阶乘都是 $1$, 因此可以不考虑进去；$3!=6$ 的结果尤为特殊，因为它乘以偶数后取 $A$ 都是得到它本身，即若 $x\in \{0,2,4,6,8\}$，则 $A(3!\times x) = x$，然而又因为这个余数肯定得乘上前面 $2$ 的次幂，所以即便在余数中只有 $1$ 和 $3$，它的结果是 $6$, 随后又会被前面 $2$ 的次幂吸收。因此，我们可以不考虑余数中的奇数们，只考虑它们里面的偶数。再之后，$A(2!) = 2$，$A(4!) = 4$，我们可以把功夫全放在这两个数字上。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">res&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">str&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">dig&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dig&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">dig&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="组合起来完成计算">组合起来完成计算
&lt;/h3>&lt;p>最后，我们只需要把上面的几个函数组合一下就好了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">last_nonzero_digit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="n">penta_n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">to_penta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_S&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">penta_n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">resudal_4&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">divmod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="n">A_pow_2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">resudal_4&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">resudal_4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="n">ress&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">penta_n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">A_pow_2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">ress&lt;/span>&lt;span class="p">))[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好，现在只需要运行这个脚本，就能解决我们一开始拿到的问题了。我们要求的是 $2025$，那么 $A(2025!)$ 经过计算得到的结果就是：$2$！太棒了。这个算法还挺快的，几乎是无感计算诶。我试了一下，在我自己的 PC 上进行计算，算 $A(2^{5000}!)$ 大概用了两秒就得到了结果。&lt;/p>
&lt;p>然而，我们的结果对吗？应该是有个答案吧，答案怎么做的呢？&lt;/p>
&lt;h2 id="终章神秘的算法怎么能这么快">终章：神秘的算法，怎么能这么快？
&lt;/h2>&lt;p>我们引入这个问题的时候，就说过知乎上有人发过&lt;a class="link" href="https://www.zhihu.com/question/666502327/answer/18810753693" target="_blank" rel="noopener"
>一个很厉害的回答&lt;/a>。这个算法令人惊讶的简单，不需要算若干次麻烦的除法，只需要算一次模除以 $4$ 就可以了。这个算法是这样的：&lt;/p>
&lt;p>首先写成 5 进制，然后把每一位偶数加起来得到一个结果 $t$，然后把每一位和自己的位数（从0开始）相乘后相加得到 $x$，最后计算一个判别式 $y = (x+t/2) \mod 4$, 如果 $y = 0$ 则说明结果是 $6$，而剩下的情况则是 $2^{y}$ 即可。这个算法写成 Python 程序则为 （借用上面的转 5 进制算法）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">quick_method&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">to_penta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="c1"># index&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">digit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">digit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个算法太简洁了…… 对它的解释写在 &lt;a class="link" href="https://oeis.org/w/images/4/48/AlgLastFinal1.txt" target="_blank" rel="noopener"
>这篇上古网页&lt;/a>里。我实在是燃尽了，看不下去了。不过我认为其基本思路和我的算法应该是差不多的。它应该在求 $S$ 组这一步做出了很大的简化，并且把对余数的处理想办法捏进一个加和里。我也不知道他是怎么做到的。不过这个算法肯定是快的多的，因为它计算 $A(2^{5000}!)$ 是瞬间计算出来的。毕竟，时间复杂度在这里摆着……&lt;/p>
&lt;p>也许某一天我会回来看这个算法的具体实现是怎么做到的吧！希望我会记得回来看。暂且就到这里吧，这个问题还伤了我不少脑细胞来着。&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>其实，这个问题的解决并非一帆风顺。一开始我是在百无聊赖的状态下看到这个问题的，一下子就被吸引住了。这个问题实在是很有趣，而我一开始的思路，正如上面那样，尝试了质因数分解和一些有的没的，手动计算了 $A(20!)$ 来尝试寻找规律之类。然而，那天赶着吃饭，在发现可以以 9 个数字为一组进行操作之后就不再细想了。其实 9 个数字为一组的做法是错误的，错误原因直到后来我已经动笔开始写这篇文章的时候，我才后知后觉。好在很快意识到了问题，把 $5$ 这个绊脚石从脚边踢开后就能很好地进行计算了。&lt;/p>
&lt;p>事实上，我在计算时一直在用最后给出的这个 &lt;code>quick_method&lt;/code> 做结果对照。令人欣喜的是，结果是没问题的，我的算法设计顶住了 &lt;em>没有答案&lt;/em> 的压力。毕竟，从最后的这个答案上，能得到的有效信息几乎只有 “记得使用 5 进制”。很难反推出来的啦，这套算法。当然，关于这个问题，我的终极目标当然是吃透这个算法究竟是怎么生效的。不过这也已经是后话了。&lt;/p>
&lt;p>很明显这个问题是和数论强相关的，尤其和取模运算有很大的关系。然而，这里并没有深究，主要原因一个在于进行进制转换已经很麻烦了，没必要介绍太多数论的内容， 另一个也是我自己的问题：我不会数论，我讲个毛呀。因此，本着有啥写啥，用啥写啥的精神，最后只写出来这么个半吊子。希望看到这篇文章的你感觉还算有点意思吧。&lt;/p>
&lt;p>那么最后，一如既往地，祝您身心健康，工作顺利，生活愉快。&lt;/p></description></item><item><title>微积分的符号</title><link>https://a-moment096.github.io/p/%E5%BE%AE%E7%A7%AF%E5%88%86%E7%9A%84%E7%AC%A6%E5%8F%B7/</link><pubDate>Thu, 24 Jul 2025 15:16:10 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%BE%AE%E7%A7%AF%E5%88%86%E7%9A%84%E7%AC%A6%E5%8F%B7/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%BE%AE%E7%A7%AF%E5%88%86%E7%9A%84%E7%AC%A6%E5%8F%B7/Postscript.png" alt="Featured image of post 微积分的符号" />&lt;p>&lt;em>数学的一大特征大概就是多种多样的符号了吧。提到数学，大家总是能想起各种各样的公式，即便在我心目中，物理也许更能用各式各样的公式凸显自己的高深莫测，然而作为一种逻辑严密的学科，依旧少不了用各种符号来代指各种数学对象。本文就 &lt;strong>微积分&lt;/strong> 这一个子方向，浅谈这些风格迥异的记号，也方便接触不同领域的文献。&lt;/em>&lt;/p>
&lt;p>&lt;em>最近很喜欢橘星（Orangestar）的这首 《Postscript》，夏背画的 MV 也很好看。所以就都放上来吧~ 可惜这首歌是要 VIP 的，想畅听的话可以试试&lt;a class="link" href="https://www.bilibili.com/video/BV1Qf421q7RA" target="_blank" rel="noopener"
>B站链接&lt;/a>&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=2603846010" theme="#2980b9" loop="none">&lt;/meting-js>
$$
\gdef\d{\space\mathrm{d}}
\gdef\p{\partial}
\gdef\Del{\nabla}
\gdef\R{\mathbb{R}}
\gdef\pfrac#1#2{\dfrac{\p #1}{\p #2}}
\gdef\ddfrac#1#2{\dfrac{\mathrm{d} #1}{\mathrm{d} #2}}
$$&lt;h2 id="积分符号也许是混沌善">积分符号：也许是混沌善？
&lt;/h2>&lt;p>虽然微积分这门学科，从逻辑上讲是由导数和微分作为引入更合理，这一点从 &lt;em>微积分&lt;/em> 的名称中也许也能略窥一二。然而，由于我们主要是来聊聊微积分中的符号，而积分的符号相对而言会更简单一些，因此我们先从它开始谈起。&lt;/p>
&lt;h3 id="单个积分符号">单个积分符号 $\int$
&lt;/h3>&lt;p>由莱布尼茨引入的 $\int$，它几乎是最常见的积分符号了，其源自拉长的字母 $S$。当它孤零零地出现时，常常代表着求的是表达式的不定积分，即求表达式的原函数。当需要给定一个区域时，习惯上给一元函数的定积分写上上下限来表达积分的区域。而这个符号也不一定只用于一元函数：它可以表示 &lt;em>曲线积分&lt;/em>，而且在表达一般情况下的积分时，也可以使用该符号。此时积分区域是一个一般意义的集合，放在积分符号的下标来表示积分区域。&lt;/p>
&lt;p>来几个例子吧。比如我们人见人爱的普通不定积分：&lt;/p>
$$
\int f(x) \d x,
$$&lt;p>它就是说在尝试求 $f(x)$ 的原函数是什么，即尝试找到一个 &lt;strong>函数族&lt;/strong> $F(x)$ 使得其导函数为 $f(x)$。而下面则是一个定积分的例子：&lt;/p>
$$
\int_0^{\pi} \sin (x) \d x,
$$&lt;p>它是在求 $\sin (x)$ 在区间 $(0,\pi)$ 的积分。我们也可以说是在区间 $[0,\pi]$ 上的积分，这取决于你对积分的看法，由于 $\sin(x)$ 的连续性，这两个积分结果是等价的。我们抓住 &lt;em>一维&lt;/em> 这个特点，从而可以考虑对 &lt;em>一维流形&lt;/em>（天哪真的可以这么说吗），也就是一般的曲线，进行积分：&lt;/p>
$$
\int_l f \d s,
$$&lt;p>这里的 $l$ 自然表示的就是积分区域，一条曲线，而 $\d s$ 就是积分的所谓 &lt;em>线元素&lt;/em>了。具体的计算方式我们这里就不再提出。由于曲线是一维的（应该是叫内禀维度吧？），我们可以把在这条曲线上的积分直接看作是单纯的参数函数的积分，因此使用这样的积分符号完全是合理的。我们这里埋一个小坑，即为什么用了 $f$ 而非 $f(x)$ 或者 $f(s)$ 之类的东西作为被积函数。我们以后再谈这个问题。&lt;/p>
&lt;p>而当你有一个说不清是几维的函数，或者是一个一般意义下的多元函数（定）积分时，你也会使用这个积分符号，用法如：&lt;/p>
$$
\int_{\Omega} f({\bf x}) \d^n {\bf x}
$$&lt;p>这就是在说，给一个 $n$ 元函数 $f({\bf x})$ 进行积分，积分区域为 $\Omega$。这里有几个要点：首先，出现在后面表明被积分变量的 $\d^n {\bf x} $ 应该是&lt;/p>
$$
\d x_1 \wedge\mathrm{d} x_2 \dots \wedge\mathrm{d} x_n
$$&lt;p>的缩写。我们暂且按下 “$\wedge$” 这个符号不表，上面这串的含义是积分区域 $\Omega$ 的一个微分元素。从稍微物理一点的角度去讲，它代表着一个微小体积。另外，$\Omega$ 一般我们认为它是一个开集合：&lt;/p>
$$
\Omega \subseteq \R^n .
$$&lt;p>不过，在不那么严格的语境下，我们可能会考虑使用 $\d v$ 来代表一个 &lt;em>体积元&lt;/em>，用 $V$ 指代积分区域。这样一来，我们可以将这个积分像考虑 “求面积” 那样类比到 “求体积” 或者 “求质量” 上，方便理解。作为多元函数，其中的 ${\bf x}$ 一般被理解为是位置向量，这样的方式更现代化一些，不过即便理解为是依赖 $n$ 个元素而非依赖一个 $n$ 维向量，也是可以的。结论上不会有什么差别。&lt;/p>
&lt;p>关于这个符号，我们先暂时到这里，因为积分符号还有另外挺常见的几个：&lt;/p>
&lt;h3 id="重积分符号与环积分符号">重积分符号与环积分符号
&lt;/h3>&lt;p>我们常常还能见到多重积分的符号，比如 $\iint$，$\iiint$ 等。有时还能见到这种中间带一个小圈的积分符号，即代表对封闭区域积分的 $\oint$，$\oiint$ 等。我们先看看重积分。&lt;/p>
&lt;p>代表重积分的符号相对而言是含义比较清晰的，因为看上去有几个 $\int$ 就代表了是几重积分。由于对高维空间不再有 &lt;em>区间&lt;/em> 这个概念了，所以一般而言，重积分的积分区域都是直接写在积分符号下方，用一个符号表示出来。比如&lt;/p>
$$
\iint\limits_{A} f(x,y) \d x\wedge\mathrm{d} y ,
$$&lt;p>其中的 $A$ 就代表了一个二维积分区域。有些地方还会把积分区域直接通过不等式表达出来写在积分符号的下方，比如&lt;/p>
$$
\iint\limits_{\substack{0\lt x\lt 1\\ y\gt x}} f(x,y) \d x\d y
$$&lt;p>就是说这个函数的积分区域是一个小小的直角三角形。不过我个人是不太喜欢这种表达的，看上去很凌乱。&lt;/p>
&lt;p>需要说明的是，重积分 $\neq\;$ 积分多次，至少不能直接画上等号。然而吧，在一般的应用过程，没人会在意二者等价性的证明的…… 甚至于，即便你省略楔积符号（即那个 $\wedge$），甚至看作乘法，都没人会管的。我们后面再吐槽吧。&lt;/p>
&lt;p>封闭区域的积分其实没什么特别的，就是在提醒读者，这个积分区域是封闭区域。这里所说的 &lt;em>封闭&lt;/em> 应该理解为 “图形是闭合的”，区别于数学上的 &lt;em>闭区间&lt;/em> 的概念。按照比较 nerd 的说法，这个封闭应该是说该图形是某个图形的边界。Anyway，直观来看就是说是一个圈，或者一个气球，那样的东西（大概）。比如 $\oint$ 就是说积分的区域应该是闭合曲线，而 $\oiint$ 就是一个闭合的曲面，就像气球那样。对应的，积分元素也是线元或者面元了，这里就不再赘述。&lt;/p>
&lt;h3 id="是积分但不是拉长的">是积分，但不是拉长的 $S$
&lt;/h3>&lt;p>除了上面常见的，使用拉长的 $S$ 来指代积分以外，还有另一条不怎么常见的分支，即用算符去指代积分，即用 $D^{-1}$ 这样一个符号来突出积分是求导的逆运算&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>（自然， $D$ 就被用作求导的算符了）。这样的记号也许在偏向代数的学科中会见到吧，或者是在微分方程中。毕竟这个符号非常简洁，且比起 $\int$，更能让人接受它是一个算符。事实也确实如此：积分这个东西，就是可以理解为输入一个函数后输出一个实数/函数族 （取决于定积分还是不定积分）。关于这个符号，我们就先只聊到这里。&lt;/p>
&lt;h3 id="没有-对吗">没有 $\d x$，对吗？
&lt;/h3>&lt;p>我想近乎所有初学微积分的人，都会有这样的一个疑问：$\int$ 还不够说明这个东西是个积分吗？为什么非得要后面 $\d x$ 这样一个尾巴！？然后随着后续的学习，比如换元法，多元积分，以及见识过不是被积变量出现在函数中的情况后，从心理上就接受了这样的写法。毕竟，指明这个积分是对谁做的积分，不也挺好？然后把只有 $\int$ 而没有后面的 $\d x$ 的写法认为是一种简写。这近乎是大多数人对积分符号的看法了吧。&lt;/p>
&lt;p>但是，我们能合法合规地不要后面的 $\d x$ 吗？毕竟，它是微分呀！为什么非要把微分和积分符号放在一起？这个问题也许在勒贝格积分下或者在微分流形理论下能得到合理的答案，但是倘若我们只是讨论黎曼积分呢？&lt;/p>
&lt;p>好消息是，&lt;a class="link" href="https://www.bananaspace.org/wiki/%E8%AE%B2%E4%B9%89:%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90" target="_blank" rel="noopener"
>于品老师的数学分析讲义&lt;/a>里就没有使用传统的 $\int f(x) \d x$ 的记号，而是采用 $\int f$ 作为积分的记号。这里是这么做的：考虑 $\int_I$ 是一个定义在 &lt;strong>黎曼可积函数集合 $\mathcal{R}(I)$&lt;/strong> 上的，到实数域上的映射。那么对于任意一个黎曼可积函数 $f \in \mathcal{R}(I)$，我们都可以合法地写出 $\int_I f$，并称其为 $f$ 的积分。&lt;/p>
&lt;p>可惜，我们不计划在这里深究这些技术上的细节，只是介绍一下这些数学符号。不过，感兴趣的话，于品老师的这份讲义写的很不错，很值得一看。关于这部分，可以参考 &lt;a class="link" href="https://www.bananaspace.org/wiki/%E8%AE%B2%E4%B9%89:%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/Riemann_%E7%A7%AF%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener"
>18. Riemann 积分的定义&lt;/a>。除了于品老师的教材这样处理之外，Terence Tao （陶哲轩）所著的 &lt;em>Analysis&lt;/em> 也采用了这种不在积分中使用 $\d x$ 的做法。感兴趣的话也可以看一看。&lt;/p>
&lt;h2 id="导数混沌恶">导数：混沌恶！
&lt;/h2>&lt;p>谈完形式比较符号比较简单的积分，我们再来看看众说纷纭，略显混乱的求导符号们。混乱的原因主要是因为，很多数学家都发明了自己的求导符号。因此，干脆我们这里就以不同的数学家为轴，介绍一下这些符号。&lt;/p>
&lt;h3 id="莱布尼茨无心的发明神秘的隐含">莱布尼茨：无心的发明，神秘的隐含
&lt;/h3>&lt;p>我们先看由莱布尼茨引入的记号，&lt;/p>
$$
\ddfrac{f(x)}{x},
$$&lt;p>对高阶求导则是&lt;/p>
$$
\ddfrac{^nf(x)}{x^n}.
$$&lt;p>这个记号也许是高数中最令人熟悉的记号了，它明确地指出了上面的函数对下面的自变量求导，以及求导的次数。它还很好地捕捉了求导与微分的关系，这一点大概是莱布尼茨一开始没有料想到的吧。不过，我们也不太能直接把求导解释为 “一个东西，除以另一个东西”，即便很多定理/定律都在这样的解释下还能正常工作，但还是不应该这么做。&lt;/p>
&lt;p>然而，我们当然可以用这个方法来助记，不是吗？比如复合函数 $g(f(x))$ 的导数，用链式法则就能得到：&lt;/p>
$$
\ddfrac{g(f(x))}{x} = \ddfrac{g(f(x))}{f(x)} \ddfrac{f(x)}{x},
$$&lt;p>或者我们采用更加“阅读友好”的形式，令 $f(x) = y$，则有：&lt;/p>
$$
\begin{align*}
\ddfrac{g(f(x))}{x} &amp;= \ddfrac{g(y)}{x} \\
&amp;= \ddfrac{g(y)}{y} \ddfrac{y}{x} \\
&amp;= \ddfrac{g(y)}{y} \ddfrac{f(x)}{x},
\end{align*}
$$&lt;p>不得不说，真的很像单纯地把除法算式拆成两个除法相乘。&lt;/p>
&lt;p>然而这个记号也许会引起这样一些误会：为什么不是 $\d f(x) ^n$ “除以” $\d x^n$？它和微分之间究竟有什么联系？为什么是 $\d x^n$ 而非 $\d^n x$？在我学习微积分时，这也是一个困扰了我很久的问题。&lt;/p>
&lt;p>为了解释这个问题，我们首先先回答为什么前面讲到：为什么不能把求导解释为 “一个东西除以另一个东西”。你可能见过这样的求导记号：&lt;/p>
$$
\ddfrac{}{x} f(x)
$$&lt;p>这同样表示对 $f(x)$ 的求导，而且也许是最符合 “严格” 的要求的记法。因为这个符号中，我们能更明显地看出 $\ddfrac{}{x}$ 是一个整体！而且我们还能更好地描述这个符号在做什么：我们对一个函数 $f(x)$ 进行了求导的操作（左边作用上 $\ddfrac{}{x}$）。从这个角度，为什么高阶导数是 $\ddfrac{^nf(x)}{x^n}$ 也能很好地解释了，因为我们可以写成：&lt;/p>
$$
\ddfrac{^nf(x)}{x^n} = \ddfrac{^n}{x^n} f(x) = \left(\ddfrac{}{x}\right)^n f(x),
$$&lt;p>也就是我们对一个函数 $f(x)$ &lt;em>多次作用上&lt;/em> $\ddfrac{}{x}$。&lt;/p>
&lt;p>实际上，这已经是从 &lt;strong>算符&lt;/strong> 的角度来解释这个过程了。也正是因为 $\ddfrac{}{x}$ 是一个完整的算符，我们不能把它单独拆开，表示成两个微分相除。这不是唯一的一个算符表示方法，然而其细节丰富，在需要展示所有的运算细节的时候，我会很喜欢使用这个符号。但是我们也不是什么时候都需要展示所有的细节，这时候莱布尼茨的符号就显得很啰嗦了。这就引出了另一个很受欢迎的求导记号：拉格朗日记号。&lt;/p>
&lt;h3 id="拉格朗日简洁的美">拉格朗日：简洁的美
&lt;/h3>&lt;p>由拉格朗日引入的记号 $f'(x)$，$f''(x)$ 以及 $f^{(n)}(x)$ 同样是被广泛应用。这种记号在受欢迎程度上几乎与莱布尼茨的记号平分秋色，但拉格朗日记号胜在其形式简洁明了。然而，由于拉格朗日的记号太深入人心，导致假如希望给一个和 $f$ 相关，但实际上不同的函数一个记号，就不可能考虑 $f'(x)$ 这样已经广泛接受为导数的符号了，只能考虑再上面加小帽子：$\hat{f}(x)$，或者加横杠：$\bar{f}(x)$，等等。&lt;/p>
&lt;p>拉格朗日的记号最常见到的地方大概就是各类微分方程了。由于微分方程中，求导的变量通常都是很明确给出的，因此与其采用莱布尼茨那样的符号，拉格朗日的符号更容易书写也不会引起歧义。此外，在上下文明确的前提下，这个符号写起来也确实是很方便。如果要我给别人解释一个包含导数，但又不太需要太多导数的细节的东西，我会比较乐意写这个记号。然而，如果是写文的话，可能这个记号还是会往后排一排吧。&lt;/p>
&lt;p>说到简洁，拉格朗日的记号确实不错，但不是唯一的一个，然而它就不那么幸运了。&lt;/p>
&lt;h3 id="牛顿物理的传承">牛顿：物理的传承
&lt;/h3>&lt;p>作为与莱布尼茨共同开创微积分的数学家，牛顿的记号就显得有点小众了。他使用点来代表求导，如 $\dot{f}(x)$ 代表一阶导，$\ddot{f}(x)$ 代表二阶导。但是这种记号没有一个很好的表示 $n$ 阶导的方法，高阶导也显得异常臃肿：单纯地堆砌点号。一些老的文献中通常能看到函数上堆满了点，想确定是几阶导数还需要一个个数一下。相比之下，拉格朗日的做法就聪明的多了，直接用一个数字代表，非常简单明了。&lt;/p>
&lt;p>不过，由于牛顿在近现代物理领域中近乎奠基人的地位，这个记号在物理学或与之相关的领域中也依旧被广泛应用。现在人们延续了牛顿引入这个记号时所设想的含义：对时间求导（也就是牛顿创立微积分时所说的 &lt;em>流数&lt;/em>）。一个点就是对时间求一阶导，两个点就是二阶导。由于物理领域不太常遇到对时间求高阶导，这样的记号也显得还不错。&lt;/p>
&lt;p>举个例子来讲，物理中常用到的变分法需要欧拉-拉格朗日方程中，就有略显奇葩的做法，即对变量的导数再求导。具体还可以参考之前写的关于&lt;a class="link" href="https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-i/#euler-lagrange-方程" >欧拉-拉格朗日方程的简介&lt;/a>的内容，或者这篇&lt;a class="link" href="https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/" >关于变分法的内容&lt;/a>。比如说有这样一个力学体系，它的状态可以由体系内粒子的位置以及其速度来决定。此时我们可以写出其拉格朗日量：&lt;/p>
$$
L = L(q,v,t),
$$&lt;p>而使用了牛顿的记号的话，就可以写作如下的形式：&lt;/p>
$$
L = L(q,\dot{q},t),
$$&lt;p>这样能很好地体现位置和速度的关系。最重要的是，相比于用 $\ddfrac{q}{t}$ 或者 $q'$ 这样的写法，这样的写法能很好地表达它就是对时间求导的关系。另外，也能让欧拉-拉格朗日方程的表达式变得很简洁，即可以写成下面的形式：&lt;/p>
$$
\frac{\partial L}{\partial q}-\frac{\mathrm{d} }{\mathrm{d} t}\frac{\partial L}{\partial \dot{q}} = 0.
$$&lt;p>只能说牛爵爷心是好的，后面数学家/物理学家们也给执行好了。&lt;/p>
&lt;h3 id="欧拉算符化求导">欧拉：算符化求导
&lt;/h3>&lt;p>另一位大数学家欧拉也引入了一个记号，使用 $D$ 代表对函数的求导。这也就是上面所说的，积分算符，$D^{-1}$，的逆算符了。它具有算符的特质，如求一阶导就是 $D f$，二阶导就是 $D^2 f$，而高阶导自然就记为 $D^n f$。也正是由于这样算符化的特点，这个记号现在在泛函分析领域中被广泛应用。&lt;/p>
&lt;p>另外，借助这样的记号，我们甚至可以对求导算符进行一些代数的操作。比如也许我们熟知的二阶常微分方程，就可以用算符的形式进行有理有据的 “助记”。例如：&lt;/p>
$$
ay'' + by' + cy = 0
$$&lt;p>这样的二阶齐次线性微分方程，就可以拆成算符的形式：&lt;/p>
$$
(aD^2 + bD + c)y = 0,
$$&lt;p>这提取出来的算符形式，和所谓的特征方程是否有几分神似？没错，求解这个微分方程实际上就是在求这个括号内的算符的本征函数（类比本征值）。&lt;/p>
&lt;p>围绕这个算符，我们甚至可以衍生出很多别的很有意思的讨论，比如量子力学中所谓的 “对易”，或者是讨论 “位置与动量的关系” 等等。B站上有人搬运了关于 &lt;a class="link" href="https://www.bilibili.com/video/BV1CdNDz1EcB/" target="_blank" rel="noopener"
>微分的导数&lt;/a> 的视频，挺有意思的，里面涉及到一些把导数看作算符的观点，感兴趣可以看一下。另外，查阅 &lt;a class="link" href="https://en.wikipedia.org/wiki/Differential_operator" target="_blank" rel="noopener"
>维基百科&lt;/a>，可以看到还有一种表达算符的写法：$\partial_x$。这种写法偶尔会在偏微分方程中见到，不过总归是不太常见，也可能是我很少遇到微分方程的缘故吧？&lt;/p>
&lt;h3 id="雅可比多元函数与矩阵">雅可比：多元函数与矩阵
&lt;/h3>&lt;p>然而，看过上面的几个记号，竟然没有一个考虑过多元函数的情况。针对这个问题，首先引入符号的是雅克比，他引入四种记号来表示不同的导数：&lt;/p>
&lt;ul>
&lt;li>对于偏导数，使用 $\pfrac{f(x,y,\dots)}{x}$，$\pfrac{^nf(x,y,\dots)}{x^{m}\p y^{n-m}}$ 这样与莱布尼茨记号类似的记号；&lt;/li>
&lt;li>为简记上面的记号，引入了 $f_x = \pfrac{f(x,y,\dots)}{x}$，$f_{xy} = \pfrac{^2f(x,y,\dots)}{x\p y}$ 这样的记号；&lt;/li>
&lt;li>为了表达向量值函数的导数，引入了雅克比矩阵与雅克比行列式，来指代一阶导数。多元函数的雅克比矩阵的记号为 $\mathbf{J}_\mathbf{f(x)} = \dfrac{\p(f_1,\dots,f_m)}{\p(x_1,\dots,x_n)}$；&lt;/li>
&lt;li>为了表达多元函数的二阶全导数，引入了黑塞矩阵，记号为 $\mathbf{H}_f$，其矩阵元素为 $(\mathbf{H}_f)_{i,j} = \pfrac{^2f(x)}{x_i\p y_j}$。&lt;/li>
&lt;/ul>
&lt;p>这些符号极大地丰富了对多元函数的表达，可以说没有这些记号，多元函数的研究光写文字都得好久。而且最重要的是，&lt;strong>矩阵&lt;/strong> 的形式很好的说明了求导这个操作的线性性。当我第一次知道，二元函数的全导数是一个矩阵，且表达的是一点的切面的时候，是有点被震撼到的。具体内容可以参考大名鼎鼎的 &lt;em>Baby Rudin&lt;/em>，也就是 Walter Rudin 所著的 &lt;em>Principles of Mathematical Analysis&lt;/em>。&lt;a class="link" href="https://a-moment096.github.io/p/baby-rudin-%E8%AF%BB%E5%90%8E%E6%84%9F/" >我就是从这本书知道这点的&lt;/a>。&lt;/p>
&lt;p>另外，就像上面所说的，莱布尼茨的记号有对应的算符版本，雅克比的这些记号也是有自己的算符版本的，就是写作 $\pfrac{}{x}$ 的形式。这样的形式的优点类似与莱布尼茨记号的方式，我们这里不再多提。不过值得一提的是，由于微分流形/微分几何中对高维几何体与微积分之间联系的研究，这一保留了算符性质的表达偏导数的符号被这两个学科大量地应用，甚至已经不仅仅用以表达单纯的偏导数了。比如从偏导/方向导数中抽象而来的 &lt;em>切向量&lt;/em>，就直接使用了这样的偏导数记号来表示了。&lt;/p>
&lt;h3 id="也许是国内教材干的但是很无奈">也许是国内教材干的？但是很无奈……
&lt;/h3>&lt;p>多元函数在微积分中的研究，不仅仅是多了几个依赖的变量这么简单。考虑多元的复合函数的情况，我们在对多元函数进行求（偏）导时必须考虑所有的变量，这就给多元函数的求导引入了极大的复杂性，也正因如此，不注意求导过程中的记号将会引起很大的歧义。&lt;/p>
&lt;p>比如有这样一个函数：$f(u(x,y),x,y)$，这里 $x$ 与 $y$ 独立，而 $u$ 依赖这两个变量。现在想求 $f$ 对 $x$ 的偏导数，应该怎么做呢？由多元函数的求导法则和链式法则，我们应该写：&lt;/p>
$$
\pfrac{f(u(x,y),x,y)}{x} = \pfrac{f}{u}\pfrac{u}{x} + \pfrac{f}{x}
$$&lt;p>等一下，这对吗？如果来个初学者尝试写这个问题，会不会出现把两边的 $\pfrac{f}{x}$ 直接给消掉，最后得到一个 $\pfrac{f}{u}\pfrac{u}{x} = 0$ 的方程？这明显是有问题的，而这样的歧义主要出现在，我们尝试对多元函数求导时，首先是 &lt;strong>对位置&lt;/strong> 求导的，而非对 &lt;strong>变量&lt;/strong> 求的导。所以，上述等式第二个部分应该是想表达，这个函数需要对第二个位置求偏导才对。&lt;/p>
&lt;p>为了解决这样的歧义，也许是国内教材特供吧，我们会用 $f'$ 带上下标数字来表示 “对几号位置求导”。比如写 $f'_1(u(x,y),x,y)$ 来代指对 “一号位置” 求导。有时候，可能还会把上面这一撇省略掉。这样一来，上面的算式就能写成：&lt;/p>
$$
\pfrac{f(u(x,y),x,y)}{x} = f'_1 \pfrac{u}{x} + f'_2\pfrac{x}{x} = f'_1 \pfrac{u}{x} + f'_2
$$&lt;p>这样也算是能解决问题吧。不过其实更好的方法是区分开函数和变量，比如一开始给函数记为：&lt;/p>
$$
\begin{align*}
w = f(g(x,y),x,y)\\
u = g(x,y)
\end{align*}
$$&lt;p>并把偏导写为：&lt;/p>
$$
\pfrac{w}{x} = \pfrac{f}{u}\pfrac{u}{x} + \pfrac{f}{x},
$$&lt;p>这样也能有效避免歧义，但是对这个过程的解释就会变得比较复杂。我们要先明确一点，我们在进行求导时，有两层求导：&lt;/p>
&lt;ul>
&lt;li>对 &lt;em>函数本身&lt;/em> 求导，求的就是这个函数对某个变量的导数。如这里的 $\pfrac{w}{x}$ 或者 $\pfrac{u}{x}$；&lt;/li>
&lt;li>对 &lt;em>函数法则&lt;/em> 求导，实际上是在套求导的公式，是纯粹形式上的求导。比如这里的 $\pfrac{f}{u}$ 和 $\pfrac{f}{x}$。&lt;/li>
&lt;/ul>
&lt;p>当我们应用求导法则时，我们的目的是对函数本身进行求导，而计算过程则是机械地运用纯符号的填空题法则，来把内容填进去。然后在具体计算时，尽可能不展开表达式，比如计算 $\pfrac{f}{u}$ 的时候就将 $x$ 和 $y$ 作为非变量进行计算，而在计算 $\pfrac{f}{x}$ 的时候就把 $u$ 和 $y$ 作为非变量进行计算。&lt;/p>
&lt;p>但是总的来说，还是非常混乱了……&lt;/p>
&lt;h3 id="小结一下吧">小结一下吧
&lt;/h3>&lt;p>可以看到，导数的符号，真的很混乱。每个领域几乎都有自己的写法。稍不留神可能就会引起歧义（说的就是你，多元求导）。也许在讨论多元函数微积分前，最好先规定好一套无歧义的符号标准？那做题怎么办呢？很难受了…… 混沌恶，当之无愧！&lt;/p>
&lt;h2 id="微分记号中立善">微分记号：中立善
&lt;/h2>&lt;p>看了上面这些令人头晕的符号，我们还是来看点轻松的内容吧。微分记号几乎是大家一致认同的符号之一了，都选择用一个简单的 $\d\ $来表达微分……&lt;/p>
&lt;h3 id="正体-vs-斜体">正体 VS 斜体
&lt;/h3>&lt;p>等一下，真的如此吗？这不是正体的 $\d\ $ 吗？为什么很多地方（包括维基百科）都是直接用的 $d$ 呢？&lt;/p>
&lt;p>这又是一个令人抓狂的故事了。实际上，很多地方的数学符号，都是应该写作正体的。比如三角函数，应该使用 $\sin$，$\cos$，$\tan$ 这种。而 $sin$，$cos$，$tan$ 这样的写法则是不规范的；微分算符也不例外，$\d\,$ 应该是更加规范的写法。然而 AMS 出手了：在 AMS 的规范中，出现微分的地方是应该写成 &lt;em>斜体&lt;/em> 的！所以你可以看到很多地方的写法，都是遵从 AMS 规范写的斜体 $d$ 而非正体的 $\d$。&lt;/p>
&lt;p>不过还是有作者不同意这种写法的。比如著名的 Zorich 的 &lt;em>Mathematical Analysis&lt;/em> 中就采用了正体的写法。所以这个符号也许主要还是看作者的想法吧。当然，你也可以看出，我是支持正体写法的。毕竟，斜体的 $d$，更像一个变量，不是吗？&lt;/p>
&lt;h3 id="微分能直接乘吗">微分能直接乘吗？
&lt;/h3>&lt;p>另外可能略有歧义的地方，在于 “微分到底能不能相乘” 这个点。这个问题也许主要来自于积分那边：我们经常可以看到把一个重积分写成对一个函数积分多次的形式。比如也许你经常见到：&lt;/p>
$$
\iiint\limits_{V} f(x,y,z) \d v = \int_{x_1}^{x_2} \int_{y_1}^{y_2} \int_{z_1}^{z_2} f(x,y,z) \d x \mathrm{d} y\mathrm{d} z
$$&lt;p>这样的写法。它没什么问题，但是重点在于，写下面的样子就不是很严谨了：&lt;/p>
$$
\iiint\limits_{V} f(x,y,z)\d x \mathrm{d} y \mathrm{d} z.
$$&lt;p>这是因为，一个多元函数是不能匹配上一个一维的微分元素的。这样的写法略有牛头不对马嘴的味道。那么正确的写法是什么呢？应该采用我们上面对积分符号的介绍时用到的 &lt;em>楔积&lt;/em> 记号，即：&lt;/p>
$$
\iiint\limits_{V} f(x,y,z)\d x \wedge\mathrm{d} y\wedge\mathrm{d} z.
$$&lt;p>这个楔积是何许人也？我们不过多介绍，但是可以说的是，楔积是微分之间的一种运算，能把低阶的微分组合起来，使它成为高阶的微分。像这里所做的，把三个微分用楔积联系起来，得到的就是一个三阶的微分。这样，就可以和一个三元函数相匹配，并进行三重积分了。如果对这个问题感兴趣，可以参考数学分析教材或者微分流形的教材。上面会对 “微分到底是什么” 有从代数层面的详细的解释。&lt;/p>
&lt;p>然而你要是问我，平时在不那么严谨的语境下，怎么表达一个多重积分？那我可能也是会偷懒省掉这个楔积符号的。毕竟，上下文说明了一切嘛，要相信读者的阅读能力，不是吗？（逃）&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>首先想说的，是感谢群友 &lt;a class="link" href="https://github.com/Har-W" target="_blank" rel="noopener"
>Harviiiii&lt;/a> 为本文提供的意见和建议。谢谢你~！&lt;/p>
&lt;p>这篇短文是我在学习有限元方法时遇到的方程带来的问题。具体的内容我已经记不太清了，但是大概就是对某个符号产生了疑惑，然后就像这样，打破砂锅问到底了。其实说实在的，很少会有人对符号，特别是工程上常用的微积分的符号有这么大的疑惑，或者对其严谨性有这么高的要求的。毕竟当它是 “微积分” 而非 “分析学” 的时候，数学就更像是一种工具，好用才是第一要务。&lt;/p>
&lt;p>然而探索这些符号的过程也是挺有意思的吧，而且说不定也许有审稿人会因为我的符号使用比较规范而高看我一眼呢？哈哈哈。&lt;/p>
&lt;p>另外要补充的是，实际上这篇文章刻意隐藏了一个很大的坑，不知读到这里的您是否注意到了。那就是：到底那个符号是函数？比如 $y = f(x)$，这个或许初二还是初一就学到了的表达式里，究竟哪个部分是所谓的函数？$y$？$f$？$f(x)$？我们到底应该怎么写一个函数的微分/积分？而且，说到底，&lt;em>函数&lt;/em> 这个概念，貌似也有很多不同的观点吧？是一般的映射？是特殊的映射？是 函&lt;strong>数&lt;/strong>？&lt;/p>
&lt;p>OMG，这个话题说实在的，又能给我水一篇博客了。所以，我们有缘再见吧，说不定关于 &lt;strong>函数&lt;/strong> 这个数学中司空见惯的对象的杂谈很快就会写出来呢？&lt;/p>
&lt;p>那么最后，一如既往地，祝您身体健康，身心愉悦，度过美好的一天~&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>积分的逆运算是什么呢？这需要看是什么积分：如果是不定积分，那应该就是求导运算了；而如果是指定积分的话，则应该是微分运算了。我们这里不多纠结这个问题，也许以后会填上这个坑？&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>蛇年，Snake Lemma！</title><link>https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/</link><pubDate>Thu, 27 Feb 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E8%9B%87%E5%B9%B4snake-lemma/Post%20Shelter-Inaba%20Kumori.png" alt="Featured image of post 蛇年，Snake Lemma！" />&lt;p>&lt;em>看了好多证明蛇引理的视频，我也来试试~ 蛇年到了，重在参与嘛&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://twitter.com/NKNK_NGRMS" target="_blank" rel="noopener"
>ぬくぬくにぎりめし&lt;/a> 太太， 为 &lt;a class="link" href="https://space.bilibili.com/26040194" target="_blank" rel="noopener"
>稲葉曇&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1jS4y1y7Yf/" target="_blank" rel="noopener"
>ポストシェルター&lt;/a> (Post Shelter)的曲绘。支持正版，就只有30秒试听了（）&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=1921984877" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="写在最前">写在最前
&lt;/h2>&lt;p>本命年到啦~！作为一个代数爱好者（自称，其实是名词党），最近在B站看到了很多的关于怎么证明蛇引理（Snake Lemma）的视频，比如&lt;a class="link" href="https://www.bilibili.com/video/BV1FZFNezE6D" target="_blank" rel="noopener"
>这个视频&lt;/a>。以前在自学代数的时候也遇到过这么个引理，但是看到这个部分的时候已经人快晕了（大概就是看完这个之后就抛弃了那本书吧，&lt;em>Algebra: Chapter 0&lt;/em>），所以几乎等于没学过。这次看到这么多关于蛇引理的视频，自然是学习一下，这里也做一个记录吧。在本文中你将看到：&lt;/p>
&lt;ul>
&lt;li>你在说些什么？&lt;/li>
&lt;li>这么简单的前置竟然也要？&lt;/li>
&lt;li>你这里跳步了吧？&lt;/li>
&lt;li>就算我证的不好，我证的很搞笑也不行吗？&lt;/li>
&lt;/ul>
&lt;p>之类的高血压时刻。为了您的身心健康，如果你打算认真了解蛇引理的话，我还是不建议你深究这篇文章。当然，如果你是找乐子的话，我希望这篇文章能带给大家笑容。这篇文章的面向读者应该对最基础的代数有了解，比如集合啊，函数啊之类的，如果会线性代数就更好了，别的东西会中途提到，毕竟是名词党写的文章，当然起点会很低的吧（笑）。话不多说，开始吧。&lt;/p>
$$
\gdef\Ker{\operatorname{Ker}}
\gdef\Coker{\operatorname{Coker}}
\gdef\Img{\operatorname{Im}}
$$&lt;h2 id="简单介绍">简单（？）介绍
&lt;/h2>&lt;p>蛇引理究竟是什么呢？这是一个代数学定理，简单来讲，它做的事情和很多代数学定理一样：从已有的两个东西来创造出新的东西。比如，如果我们有一个集合以及集合上的等价类/等价关系，我们就可以构建出来一个商集；给定一个群以及它的正规子群，我们就可以构建出商群；把两个空间 $\mathbb{R}$ 叉乘起来（笛卡尔积），我们就得到了 $\mathbb{R}^2$。&lt;/p>
&lt;p>那么蛇引理是针对什么样的代数对象呢？这里就要尝试引入我们的第一个概念：正合列 (Exact Sequence)&lt;/p>
&lt;h3 id="正合列但是先别急">正合列，但是先别急
&lt;/h3>&lt;p>正合列，同调代数中的重要对象，是由链复型添以特殊的条件而产生的。链复型又是什么？链复型是一系列的交换群或者模通过同态连接起来，且相邻两个同态的复合为0。&lt;/p>
&lt;p>也许你要说：天哪你在说什么鬼东西，这都是啥啥啥呀。既然我们假定读者只拥有最基础的代数知识，我们就从最基础的开始介绍吧。名词党最喜欢的名词介绍环节，启动！&lt;/p>
&lt;h4 id="群交换群">群，交换群
&lt;/h4>&lt;p>上面说链复型是由交换群或者模带上同态构成的，为了简单，我们就不介绍模 (Module) 了，专注于交换群。&lt;/p>
&lt;details>&lt;summary>但是模是什么？我要看口牙！&lt;/summary>如果有人讲模之类的话，可以认为就是一个差一点的线性空间，它就差在标量不再是数域中的元素了，而是环 (Ring) ，一种乘法可能没有逆元的神奇代数结构，里面的元素。这里指出，环想要变成域（有的地方管域叫体，英文都是 Field）的话只需要让环满足交换律，并且它的每个非 0 元素都有乘法逆元就好了。&lt;/details>
&lt;p>那么交换群，或者从头来讲，群，又是什么呢？有人会讲：群就是对称！有对称，就有群！挺好的，但是对称这种几何元素偏偏要符号化成群元素，这一步我倒是走了蛮久的。我们速通嘛，就说简单一点，尽可能地不丧失严谨性吧。群 (Group)，最为代数学中几乎是最基础的代数结构，和其余的许许多多数不清的代数结构类似，遵循这样的特点：&lt;/p>
&lt;ol>
&lt;li>从集合而来。它的 “底下” 一定是一个集合。这样我们就可以讨论这个代数对象中的元素了。&lt;/li>
&lt;li>它的内部有一个或者多个 “运算”。我们可以想象我们早已熟悉的乘法。既然是运算，我们对这么个东西有这样的要求：
&lt;ol>
&lt;li>首先运算是两个元素同时参与的。相乘的总是（起码）两个数。注意不一定非得是不一样的数哦。&lt;/li>
&lt;li>两个元素经过运算之后应该得到一个元素。两个数相乘之后给出的也是一个数字。&lt;/li>
&lt;li>这点不太明显，但是我们的运算总是应该从这个集合来，到这个集合里去。比如 $1\times 1\neq\mathrm{苹果}$。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>这样就可以有一个（很基础的一些）代数结构啦。而我们的群，也正是这样的一个代数结构。不过它还有这样的特点：&lt;/p>
&lt;ol>
&lt;li>群的运算必须要是可以结合的。这意味着如果 $abc \neq (ab)c \neq a(bc)$，那它就不是群。（天啊真的有这样的神经结构吗）&lt;/li>
&lt;li>群的运算&lt;strong>不需要&lt;/strong>是交换的。其实不交换的东西很常见，例如我们要先穿袜子再穿鞋，这肯定和光脚穿鞋后再套个袜子是不一样的啦。学过线性代数的朋友应该更有体会：矩阵乘法是不交换的。&lt;/li>
&lt;li>群得有单位元。何谓单位元？这不是元素吗？这里的单位元是和运算强相关的，说的就是群里的任何元素和这个单位元做运算之后一定得到的是它们自己。&lt;/li>
&lt;li>群中元素都得有逆元。没错，这里逆元的概念也是和运算相关的。所谓 “逆”，就是要把一个元素 “逆转” 回单位元。可以想象单位元就是某个出发的位置，每个元素都代表着某个让你移动的方式。而某个元素对应的逆元，就像你移动之后让你移动回原点的移动方式。能走出去，也得能走回来。就是这样。&lt;/li>
&lt;/ol>
&lt;p>其实上面的这些内容，经过一些整理的话就可以变成比较严格的群的定义了。然而严格定义谁都能查，这里也就偷个懒啦~ 这里指的指出的是，群上的运算我们一般就叫它乘法。而且在代数的语境下，很多运算我们都叫它乘法！所以在讨论代数结构中的乘法时要注意上下文哦~&lt;/p>
&lt;details>&lt;summary>所以群的对称意义究竟在哪？&lt;/summary>
&lt;p>我们讲，集合中的元素位置其实是无所谓的，比如集合 $\{1,2\}$ 和集合 $\{2,1\}$ 是一模一样的。那么，群的对称的意义，就在于群中的元素有两重含义：集合内的一个小不点，以及代表了如何操作这个集合的一个符号。&lt;/p>
&lt;p>我们提到过，群的运算是需要满足上面一大堆条件的。这些条件指向了这样的一个神奇的结果：两个群中的元素相乘，我们可以有意识地将其中一个元素作为操作方式，将另一个元素看作群中茫茫多（或者很少，也许）元素中的某个元素。而这样的运算结果又是群中的某一个元素。&lt;/p>
&lt;p>然后我们再想象这样一副图景：桌子上有一副扑克牌，每一张都分开放，放的很整齐。现在你尝试把这些扑克牌重新排列，这个排列方式取决于你开始重排前看到的第一张牌。在重新排列时，你肯定需要一张一张地取，取到之后会根据你看到的第一张牌来思考应该把它放在哪里，最后你就把它放在了对应的位置。在重复54遍 “取-看-放” 的过程之后，你会惊奇地发现：天哪，竟然又得到了一副扑克牌（？）&lt;/p>
&lt;p>你可能觉得这个发现很无聊，但是这就是对称：在某种操作下又回到自身了。你也许会说：不！位置变了！但是还记得吗？集合中元素位置是无关紧要的。我们这里其实就是在讲群对自身的作用。那么群可以对别的集合进行作用吗？当然！只要某个作用方式满足群的条件，也就是说如果你先做了一个操作，又做了另一个操作（这样就操作两次了，对应群中的两个元素相乘）这俩操作实际上也是你可取操作的一种（群中元素运算后依旧在群里），以及别的条条框框，那么实际上你就是在对这个集合进行着群作用。&lt;/p>
&lt;p>群中蕴含的对称，不在于群自己，而在于它能操作的对象。笨笨的我花了好久才明白这个道理 QAQ。&lt;/p>
&lt;/details>
&lt;hr>
&lt;p>太棒了！群是什么，已经狠狠地理解了！那么交换群？诶！交换群一定是运算能满足交换律了吧！&lt;/p>
&lt;p>是的，答案就是这么简单，且无聊。交换群 (Commutative Group，又称阿贝尔群 Abelian group，为了纪念伟大的挪威代数学家阿贝尔)，就是能交换 (Commutativity) 的群 (Group)。你也许会对交换群感到失望，但是代数岂是如此无聊之物！？这一切的原因，其实是：我们还没有引入同态 (Homomorphism)。&lt;/p>
&lt;details>&lt;summary>交换群和普通群还是有区别的吧？&lt;/summary>
&lt;p>当给一个普通的群赋予交换性时，它身上所多出来的性质远不止交换性这一条。交换性赋予群的不止表面看起来的两个元素可以交换，更重要的是，给交换群内的结构更加严格的限制。比如后面会提到的，交换群的子群全都是正规子群，因此对于任何一个交换群的子群，都可以用来被模除掉而形成一个子群。&lt;/p>
&lt;p>交换群太特殊了，以至于人们给它划定了一个特别的范畴：阿贝尔范畴（Abelian Category）。事实上，交换群甚至子集就是一个模（也就是我们在介绍蛇引理时一开始所提到的那个代数结构）。然而我们这里不计划过多地介绍交换群有多么特别，而是将目光放在交换群上面所定义的运算。更具体地说，是交换群上面定义的运算的符号，以及相关的记号。&lt;/p>
&lt;p>我们前面提到，群里定义的运算被称为 “乘法”。这是个很有趣的名字：为什么我们叫它乘法？我们熟悉的乘法，比如在 $\mathbb{R}$ 上的乘法，也就是实数乘法，或者在线性代数里我们知道的矩阵乘法，和这里的 “群乘法” 之间有什么样的关系呢？我们指出：实数在作为集合的条件下，赋予我们已经熟悉的乘法后，得到的就是一个群；而线性代数中的矩阵乘法，在将所有的 $n\times{n}$ 方阵看作一个集合时，赋予矩阵乘法后也能形成一个群。&lt;/p>
&lt;p>然而实数乘法和矩阵乘法是有区别的：实数乘法满足交换律，而一般的矩阵乘法并不满足交换律。因此，实数乘法实际上构成了交换群。不过由此我们也可以看到，无论是否满足交换律，我们经常给这样满足若干条件的运算起一个 “乘法” 的名字。这也是群运算一般被称为 “乘法” 的原因。&lt;/p>
&lt;p>但是，不论是实数，还是矩阵，甚至所整数集合、向量等等，它们都有这样的一个运算，我们更加熟悉，且常常称之为 “加法”。这些运算和乘法相比有什么样的特点呢？它们中的一些，在不谈所谓 “交换律” 时，其实和乘法是类似的。然而，在考虑矩阵的加法和乘法时，区别立马就显现了出来：&lt;em>矩阵的加法是满足交换律的，而乘法不满足交换律&lt;/em>。那么我们就这样规定：一般群（或者不满足交换律的群）的运算就称为乘法，而交换群上的运算则称为加法。从记号上来看，我们这里做一个小表格，方便更直接的对比。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">项目&lt;/th>
&lt;th style="text-align: center">一般群&lt;/th>
&lt;th style="text-align: center">交换群&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">运算&lt;/td>
&lt;td style="text-align: center">乘法&lt;/td>
&lt;td style="text-align: center">加法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">记号&lt;/td>
&lt;td style="text-align: center">ab&lt;/td>
&lt;td style="text-align: center">a+b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">左陪集&lt;/td>
&lt;td style="text-align: center">aH&lt;/td>
&lt;td style="text-align: center">a+H&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">单位元&lt;/td>
&lt;td style="text-align: center">1&lt;/td>
&lt;td style="text-align: center">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">交换律&lt;/td>
&lt;td style="text-align: center">不满足&lt;/td>
&lt;td style="text-align: center">满足&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这里要提出的是，上面的区别在不考虑交换性的情况下，仅仅是记号的区别。事实上，如果你愿意，完全也可以使用乘法记号，不过这就需要在文中特别标注出来就是了。&lt;/p>
&lt;p>最后，这里引出这样一个观点：抽象代数，如研究群、环、域、模的代数结构性质的这些内容，在理解这些代数结构的过程中，最好的例子有两个：一是整数极其衍生结构；二是线性空间以及其上面的矩阵。当然，只是私货而已，如果有什么问题还请见谅。&lt;/p>
&lt;/details>
&lt;h4 id="同态同构等价关系">同态，同构，等价关系
&lt;/h4>&lt;p>首先，代数中［Homo-］的词头其实很常见（？）。这是代表着两个东西之间一定有什么相同的地方。而同态，正是指出了两个代数结构之间相同之处的东西。请注意这里用到的是 &lt;em>代数结构&lt;/em> 而非 &lt;em>群&lt;/em> 或者 &lt;em>交换群&lt;/em>。同态广泛地存在于代数学中，到处都是同态。那么同态是什么呢？其实你早就见过了。对于 &lt;em>集合&lt;/em> 这个最基础的代数结构而言，同态就是 &lt;em>函数&lt;/em>，或者说 &lt;em>映射&lt;/em>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。既然函数是对于集合而言特殊的同态，那么对于群而言，特殊的同态是什么呢？很可惜，没有一个特别的名字，或者大家就直接叫群同态了。然而群同态确实是有其特殊之处的。我们稍后再细讲这种特殊点在哪，以及何来的“同”一字。&lt;/p>
&lt;p>回忆我们很熟悉的集合上的函数，它有这样的特点：&lt;/p>
&lt;ol>
&lt;li>函数必须要有定义域，它是一个 &lt;em>集合&lt;/em>，且这个集合里的每个元素都能被函数处理（作用）。不能说有个定义域的元素不能被函数吃掉，那就礼崩乐坏了。函数是不会剩饭的。&lt;/li>
&lt;li>函数必须要有陪域。他也是一个 &lt;em>集合&lt;/em>。请注意这里不是说不是值域，而是陪域。值域是函数能吐出来的东西组成的集合，而陪域则是函数吐出来的东西一定会存在的集合。所以，很自然的，会有一些陪域上的元素不会有任何定义域上的元素去对应。&lt;/li>
&lt;li>定义域中的每个元素 &lt;em>能且只能&lt;/em> 对应陪域上的一个元素，而陪域上的元素可以有0个，1个或者很多个定义域上的元素对应。这就像投篮，球可以投不中，可以一个球一个框，也可以很多球进一个大框里，但是不能一个球同时进两个框。&lt;/li>
&lt;li>判断两个函数是否相等（没错，函数作为数学对象是可以判断是否与另一个相等的）的铁则是：定义域相同，陪域相同，定义域上的每个元素通过两个函数作用后得到的结果总是一样的。也就是说，要检测函数的三个要素都是一样的。表达式也许会骗人，但 &lt;em>函数的定义&lt;/em> 永远是诚实的。&lt;/li>
&lt;/ol>
&lt;p>天啊我怎么又讲了一遍函数是什么？原因是：函数，作为同态的一个例子，自然就包括了同态的许多特点。然而同态还有一个重要的特性，也是被冠以 “同” 字的原因：同态必须保持结构！我们没有在集合中看到这样的特点，是因为集合里什么结构都没有。也许有人说：集合里的元素都是有名字的呀？什么 1 啊 2 啊的，这不就有结构那样的东西了嘛。这里要明确的是：集合里这些看似特殊的元素，它们的特殊性全都源自于我们为了能区分它们所给的，甚至就是为了能数清楚这些元素，不至于把它们搞混。So，集合真的很单纯，它上面的结构都是后面赋予的。当然，你也可以说 “没有结构” 也是一种结构，因为 &lt;em>函数不会把集合变成别的什么不是集合的东西&lt;/em>，保持了 “没有结构” 的特点（结构）。&lt;/p>
&lt;p>哦，好，但是说了一圈，到底怎么保持结构？群同态到底是什么样的？观察上面函数的特点，我们提炼一下：&lt;/p>
&lt;blockquote>
&lt;p>同态要有来有去，且来去都是同一类东西，不能来去之后东西不一样了。这说明 &lt;em>同态不会给对象添加或删去任何结构&lt;/em>。&lt;/p>&lt;/blockquote>
&lt;p>就是说，群同态只能连接两个群。或者，&lt;em>一个群上如果作用了一个群同态，那么它就必须给出一个群&lt;/em>。这点对于其他所有的代数结构都是一样的。&lt;/p>
&lt;p>还是一头雾水？是不是觉得随便哪个集合上的函数都能在集合变身成函数后也跟着变成同态？没关系，就群同态而言，我们其实可以写出群同态需要满足的特点（多亏了运算的存在）。&lt;/p>
&lt;blockquote>
&lt;p>设有两个群 $G$ 和 $H$，它们之间有个从 $G$ 到 $H$ 的群同态 $\varphi$。我们记群 $G$ 的运算为 $\times_G$，记群 $H$ 的运算为 $\times_H$，群 $G$ 中有俩元素 $g_1$ 和 $g_2$。这样一来，由于 $\varphi$ 是群同态，有：&lt;/p>
$$\varphi(g_1 \times_G g_2) = \varphi(g_1) \times_H \varphi(g_2)$$&lt;/blockquote>
&lt;p>而且它有一个很神奇且重要的特点：群同态只能把一个群的单位元映射到另一个群的单位元。这点乍看很神奇甚至不可思议，但是经过简单的证明就可以得到这样的结论了。这也是为了保持群的结构而对群同态做出的一个很强的限制。这也说明了，代数结构越是复杂，同态的限制就会越大。&lt;/p>
&lt;p>最后我们讲一种特殊的同态（或者态射，我们这里不区分两者，后面在范畴部分会做出说明），它需要有一个态射作为基础。我们设有这样的一个态射 $f:\\,A\to B$，且在 $A$ 中有一个保持原有 $A$ 结构的子结构 $A'$，在集合层次上则为包含关系。此时我们就可以定义所谓的 &lt;em>限制&lt;/em> （Restrict），就是把定义域从 $A$ 换到了其子结构 $A'$ 上而已。它的记号为：$f|:\\, A'\to B$。&lt;/p>
&lt;hr>
&lt;p>我们接下来介绍同构 (Isomorphism)。它在集合函数中的对应就是所谓的一一对应函数了。回忆所谓的单射和满射，单射说一个萝卜一个坑，满射说值域就是陪域。而同时满足这两个条件的话，这个函数就是一一对应的函数啦。我们立刻使用一些新词来讲这些事情，因为函数（映射）是集合间的同态嘛。&lt;/p>
&lt;p>同态中有单态 (Monomorphism)，也有满态 (Epimorphism)。而同时满足这两点的，即为所谓的同构了。它们的要求和集合函数是一模一样的。然而还有别的定义方法，使用态射的逆（啊没错它们都是态射但是这就留到范畴论再说吧）即可定义同态的单或满。回忆之前学过的逆函数这一存在，一个函数的逆函数再作用到函数的话就会变成恒同映射（把一个元素映射到它自己）。这是一种双边逆，更常见的情况则是一个态射只有左逆或者只有右逆。&lt;em>我们称有左逆的态射为单态，有右逆的态射为满态，有双边逆的则为同构&lt;/em>。这个我们不证，有兴趣可以挑一些例子看看。请把重点放在 “能不能找到原来的元素” 以及 “如果能找到原来的元素，那么一定会如何”，并注意函数的复合是从右到左的。&lt;/p>
&lt;p>这里顺带提出原像（Inverse image）的概念。原像是和某一个陪域中的元素，以及一个态射相关的。它本身是一个集合，记录了所经过该态射后能得到该陪域中元素的所有定义域中的元素。它的记号以及形式化的表达是：若存在一态射 $f\vcentcolon\space A\to B$ 以及 $b\in B$，则 $b$ 在 $f$ 下的原像记为 $f^{-1}$，定义为：&lt;/p>
$$
f^{-1}\vcentcolon=\left\{\space a \space \vert\space\forall a \in A, f(a) = b\space\right\}.
$$&lt;p>那么这样一来，单态则是所有陪域上元素的原像只能是空的或者只能有一个元素的态射，而满态则是所有陪域上的元素都有非空原像的态射。利用这个概念，同构还可以定义为所有陪域上元素的原像有且只有唯一一个元素的态射。&lt;/p>
&lt;p>同构从字面意思来理解，是 “保持结构” 的映射。可是之前还说同态是保持结构的映射，这两个区别在哪里？事实上，同构比同态要求高多了。同构要求的是 “构造完全相同”，而同态则只要求 “是同一类东西，不会多结构，也不会丢结构”，却可以修改这个结构。比如，同态可以让一个大群变成一个小群，搞得里面的每个元素以前有更丰富的运算结果，结果到了小群里好多元素被捏在一起了，这些丰富的结果也就没了。而同构会很严格地将一个群变成另一个大小一模一样的群，它们结构的丰富程度或者精细程度是一模一样的。在只关心群这个整体以及它怎么与其他群发生转变，完全不关心群内部元素有什么特别之处时，我们可以说，&lt;em>同构的两个群，它们在同构意义下可以被视作是相同的&lt;/em>。顺带一提，集合的同构就是映射到元素个数相同（集合的势相等）的另一个集合。这也是个大坑，感兴趣可以搜 Schröder–Bernstein 定理或者伯恩斯坦定理。&lt;/p>
&lt;p>对于群而言，群的同态会把群的一个或几个元素捏在一起形成新群的一个元素。同态是创造新群的一个重要方式。但是假如我们考虑 &lt;em>把几个元素捏在一起形成一个新的元素&lt;/em> 实际上意味着 &lt;em>对原来的群中的元素进行分类&lt;/em>，那我们就会形成很有趣的结构，商群 (Quotient Group)。我们不会深入这部分，但是这个思想是极其重要的，因此我们需要介绍另一个概念：等价关系与等价类。&lt;/p>
&lt;hr>
&lt;p>小学数学，甚至幼儿园数学，经常会遇到这样的题目：把一堆苹果分成若干份，每份有几个苹果；把苹果平均分成若干份，最后剩下几个苹果。这样的题目是为了让孩子熟悉除法，而我们这里则要指出，这就是除法，或者所谓的 “商” 所代表的含义。而我们在分苹果时所做的事情，就是在对苹果分类。&lt;/p>
&lt;p>我们要如何进行分类呢？特别是对一堆苹果而言，分成堆时我们做了什么？也许我们有某个标准，也许就是简单的 “我乐意”，但分成堆的过程中每个苹果最终都有属于自己的一堆。假如我们要分成三堆，那么我们完全有理由将三堆起不同的名字，比如：科比，牢大，曼巴。这样一来，每个苹果就都有了一个属性，一个标签。而苹果之间有什么关系吗？有的。我们观察同一堆的苹果，如牢大这堆，会发现这样的（显而易见）的特点：&lt;/p>
&lt;ol>
&lt;li>一个属于牢大的苹果，那么他就属于牢大（？）&lt;/li>
&lt;li>如果一个苹果在牢大里，另一个苹果也在牢大里，那么它们俩就都在牢大里，不论进入牢大这堆的顺序&lt;/li>
&lt;li>如果苹果A和苹果B都在牢大里，苹果B和苹果C也在牢大里，那么苹果A和苹果C就一定在牢大这里。&lt;/li>
&lt;/ol>
&lt;p>不论分类手法如何，不管分类标准怎么样，上面这三条总是成立的。而在分好之后，对任何人都可以只宣称这堆苹果属于哪一堆，不用管它具体怎么样了。有人问这个苹果是哪个，都可以回答这个苹果是从科比或者牢大或者曼巴这堆里取出来的。&lt;/p>
&lt;p>还是一头雾水？上面的例子是想说明这样的一件事：只要你选了，那就会形成一个标准，这个标准内的每个成员都会接受这样的束缚，而这个约束是有 &lt;em>自反性&lt;/em>，&lt;em>反身性&lt;/em> 和 &lt;em>传递性&lt;/em>的。这些性质就刻画了一个 “关系”，称为 &lt;em>等价关系&lt;/em>。我们刚刚用分好的类来说明这类关系一定存在，而反过来讲，根据这样的关系，也一定能进行这样的分类。最后分出来的 “每一堆”，我们就称为等价类。&lt;/p>
&lt;p>分类是代数学中另一个极为重要的话题。有一些出色，重要且惊艳的研究正是建立在这样的分类问题上的，比如传说中的 &lt;em>有限单群分类&lt;/em>，洋洋洒洒几千字的论文将整个单群分类问题整的明明白白。分类如此重要的原因还在于帮助我们创造新的代数结构，也就是所谓的 &lt;em>商&lt;/em>。比如使用同态对群进行划分则会涉及著名的 &lt;em>群同构基本定理&lt;/em>，描述了用同态下的等价关系创造出的商群有什么样的信息。&lt;/p>
&lt;p>我们这里先不深入介绍商群，因为它将涉及到子群 (Subgroup)，陪集 (Coset)，正规子群 (Normal subgroup) 等概念，太啰唆了。这里只指出商群的记号为 $G/H$，其中 $G$ 和 $H$ 都是群，且 $H$ 是 $G$ 的正规子群。这个商群的元素是这样的：每个元素都是一个集合，这个集合内是群 $G$ 中的元素，并且这些群 $G$ 中的元素都相互等价，而这个等价关系则由群 $H$ 这样确定：元素 $a$ 和 $b$ 等价由 $a^{-1}b \in H$ 决定。换句话说，我们根据群 $H$ 制定了元素的分类标准，把分好类后的每个 “元素堆” 作为商群中的每个元素。能分多少堆，商群就有多少个元素。&lt;/p>
&lt;p>要注意的是由于等价关系，商群中每个元素（也就是 $G$ 中元素的集合）里都可以选出唯一的一个 $G$ 中元素来代表。那么既然如此，我们就使用在代表元的头顶加个尖尖的东西来代表这个集合了。比如有一个等价类 $A$ 中有一个元素 $a$，此时我们就可以用这个元素 $a$ 来代表这个等价类 $A$：$\hat{a} = A$。这个记号还是比较重要的，所以这里提前介绍一下。&lt;/p>
&lt;p>太棒啦！感觉智慧满大脑了~ 但是这么多前置了，和蛇引理有关系吗？还有多少前置需要呢？答案令人振奋呀：还有一节就好了！我们已经明白了同态是什么样的，交换群又是啥，商群里的元素怎么确定，有什么样的特点。我们只需要再看一看最后两个和同态有千丝万缕联系，作为 “群同构基本定理” 中的 C 位的两个特殊的代数对象，核 (Kernel) 与像 (Image)，就可以开始一窥蛇引理的神秘了~。&lt;/p>
&lt;h4 id="核与像">核与像
&lt;/h4>&lt;p>核的概念其实很简单，它高度依赖于同态，本身是一个特殊的集合（我们先看它单纯的集合结构）。它是同态的定义域上所有能被对应到陪域的 &lt;em>零元素&lt;/em> 的元素，记号为 $\Ker$。假设有某个同态 $\phi$，那么在这个同态下的核就记为 $\Ker\phi$。这里的零元素应该是代数结构中普遍存在的单位元，而称为零元素的主要原因是因为对我们即将研究的许多代数结构而言，它们上面的结构实际上是交换的。交换的运算我们会叫它们 &lt;em>加法&lt;/em>。而我们熟悉的加法的单位元就是 $0$。&lt;/p>
&lt;p>我们上面只说了核底下依赖的集合是怎样选取的，然而由于同态的性质，核上经常都会有额外的代数结构。这一点很容易确定：对群而言，单位元自己本身就是一个平凡群，其上的唯一运算就是单位元和单位元进行运算之后得到单位元自己。那么既然单位元是一个群，由同态的要求，我们马上就可以得知，群同态的核很自然地就拥有群结构。不但如此，我们在此不加说明地断言：群同态的核总是群的定义域的一个正规子群！而有了正规子群，我们马上就可以讨论定义域的群商去这个同态的核所得到的商群了。事实上，群同构基本定理中就和同态的核关系非常密切，且经常使用核来构造商群。&lt;/p>
&lt;p>对于核而言，我们还想提到这三点：首先核一定是依赖于某个同态的，没有同态是没有办法讨论核的。从它的记号就可以看出，我们选择使用 $\Ker$ 记录同态的符号而非其定义域，然而也请切记核作为集合而言一定是定义域的子集。&lt;/p>
&lt;p>其次想要提到的是核在 &lt;em>同调代数&lt;/em> （也许也不是？）中的意义：核衡量了同态的性质，告诉了我们一个同态距离单态究竟有多远。这是由于这样的定理：&lt;em>核中的元素只有一个（也就是单位元）当且仅当同态是单态&lt;/em>。那么如果核越大，同态距离单态就越远了；核越小，同态就越像单态。&lt;/p>
&lt;p>最后一点也许会复杂一些，我们想提到的是：群同态的核由于一定是正规子群，而正规子群又一定能够被商掉。考虑我们上面提过的构造商结构的过程：被商的集合/结构是作为一个选择方式出现，而这个选择方式就是这个结构中的所有元素都被视为同一个元素。我们进行这样的猜测：这样用核来构造的商群中的元素，每个元素都是一个集合，而这些集合与核是相似的：它们都有同样的大小。幸运的是这样的猜测是成立的。最后也不卖关子了：商群中的元素就是正规子群的陪集，而每个陪集的大小都是相等的。所谓的陪集就是把群里面的子群用某个元素乘一下（移动一下）。这里说 “集” 有两个层面，一是我们不计划赋予它别的结构，他们就作为集合存在于商群；二是我们没法赋予群结构，除了最平凡的那个正规子群。更一般的陪集是没有办法满足单位元要求以及逆元要求的。&lt;/p>
&lt;p>核真的很重要，所以我们聊了许多。不过这主要是由于核与商群之间重要的联系。有了这样的铺垫，我们理解像将会更迅速：像也是一个子群，但不是更特殊的正规子群。&lt;/p>
&lt;hr>
&lt;p>像我们早就熟悉了，就集合层面而言，就是值域 “更代数”的一个名字。而同样由于同态的存在，像也一定是一个群。但是不同于核，像并不总是正规子群。这真是一个悲伤的故事，我们不能再愉快地构造商群了。也许你之前幻想着，既然核可以衡量同态与单态的距离，是不是像也可以衡量同态与满态的距离呢？因为很显然可以看到，像越大越可能是满态，像与陪域相同那就是满态了。然而很可惜，我们不用这种方式。&lt;/p>
&lt;p>但是我们有三个好消息：第一条是，虽然像不是个正规子群，但是我们依旧可以用像构造商结构！第二条则是，虽然像不能衡量同态的信息，但是它构造的商结构可以！我们还给它一个特别的名字：余核 (Cokernel)。第三条则是，我们其实要研究的是交换群，而对交换群而言，所有的子群都是正规子群的！这样一来，前面讲的商结构也就可以是商群啦。&lt;/p>
&lt;details>&lt;summary>子群，商群，陪集，商结构，到底是怎么回事？&lt;/summary>
&lt;p>在讲商群时，终究还是无法避免陪集的概念。陪集和商群之间到底是什么样的关系？陪集之间又有什么样的联系？陪集到底是什么样子的东西？&lt;em>商&lt;/em> 究竟是什么？我们讲了这么久的子群，正规子群，它们到底都是啥？这里我们斗胆写一写吧。&lt;/p>
&lt;p>先看看子群吧，其实子群的概念很简单：一个群的子群，实际上就是子集加上原群的运算。这样一来，子群的单位元一定就是原群的单位元，而子群的运算就是原群的运算了。这个还是相对比较简单的一个概念，麻烦的是所谓的正规子群。而为了讨论正规子群，必须要讨论所谓的陪集。我们把陪集往后放一放，先讲商群中的元素们：陪集。&lt;/p>
&lt;p>我们已经提到，商群就是对群按照其正规子群的需求进行分类从而得到的一个更小的群。这个更小的群里面是一个个的陪集，我们讲陪集中的元素都是相互等价的，因此，这个更小的群里的元素虽然都是集合，但是完全可以从每个集合中取一个元素来代表这个集合（由于等价关系），这个元素就被称为代表元。所以你可能会见到商群中的元素是用一个个原群中的元素带上标记构成的。但是还请记住，商群中的元素始终都是集合，也就是陪集。&lt;/p>
&lt;p>我们再谈谈陪集。陪集是这样一个集合：它必须依赖一个群里的元素，以及这个群的一个子群。我们记较大的群为 $G$，它的子群为 $H$。那么我们取 $G$ 中的一个元素 $g$ 之后，再和子群 $H$结合一下，就得到了所谓的陪集了。具体是这样的：&lt;/p>
&lt;ol>
&lt;li>还是先提醒：$H$ 是住在 $G$ 里面的，它们拥有一模一样的运算，所以 $G$ 中的元素是完全可以与 $H$ 中的元素运算的。&lt;/li>
&lt;li>我们从群 $G$ 中取出一个元素 $g$。这个元素是任意的，只要在 $G$ 里就好。然后还要把 $H$ 中的元素一个一个地取出来，准备进行运算。我们要取出所有 $H$ 中的元素，不遗漏不重复。&lt;/li>
&lt;li>用 $g$ 和 $H$ 中的元素依次进行运算。在做运算时，我们先把 $g$ 放在 $H$ 中元素的左边。最后得到的结果放在一个篮子里（或者框里，也可以）。&lt;/li>
&lt;li>最后检查这个框子，我们给它贴上标签：$gH$。这个框就是我们想要的陪集，准确地说是 $H$ 在 $G$ 中元素 $g$ 作用下的 &lt;em>左&lt;/em> 陪集。&lt;/li>
&lt;/ol>
&lt;p>自此，我们便成功得到了一个左陪集。如果在进行运算时将 $g$ 放在 $H$ 的右边，则称之为右陪集，记号也变为 $Hg$。注意到陪集中的元素一定是在 $G$ 中的元素，我们自然好奇：陪集内元素有什么样的特点呢？我们回顾上面的内容：陪集内元素相互等价，等价关系为 $a^{-1}b \in H$。我们来看看是怎么回事。我们更多地关注左陪集，右陪集是类似的思路。&lt;/p>
&lt;blockquote>
&lt;p>证明：$a^{-1}b \in H$ 当且仅当 a 与 b 等价，亦即 $aH = bH$。&lt;/p>
&lt;p>首先，$a$ 与 $b$ 都一定属于各自的陪集，因为 $H$ 是一个群，群里有单位元，则陪集 $aH$ 中肯定有 $a$，$bH$ 中也肯定有 $b$。&lt;/p>
&lt;p>既然 $a^{-1}b \in H$，那肯定就有一个元素 $h$ 就是 $a^{-1}b$。由于乘法逆元的性质，我们给两边左乘 $a$，就有了 $b = ah$。回忆 $H$ 在 $a$ 的左陪集的定义，这就说明了：$b$ 也是 $aH$ 中的元素。&lt;/p>
&lt;p>此时我们想到，既然 $H$ 是一个群，$h$ 在 $H$ 里了，那 $h^{-1}$ 也肯定在里面。我们就给 $b=ah$ 的右边同时乘以 $h^{-1}$，就有得到了：$a=bh^{-1}$。这同时也说明了 $a$ 也是 $bH$ 中的元素。这样一来，我们就证明了 $aH = bH$，因为我们的 $a$, $b$ 是任意选择的 $G$ 中元素，这样的任意性保证了不会选取特殊的点。&lt;/p>
&lt;p>其次，当 $aH = bH$ 时，有这样的情况：$a$ 与 $b$ 相等，则结论自然；若是 $a$ 与 $b$ 不相等，这时由于群乘法的封闭性，一定要有一个 $h$ 满足这样的关系：$ah = b$。现在我们视线移向群 $G$ 后，便可以同时左乘 $a^{-1}$，这时就得到了我们想要的结论。至此，我们证明了这样的选择方式确实是构成了一个等价关系。&lt;/p>&lt;/blockquote>
&lt;p>最后我们关注陪集间的关系：左陪集是不一定等于右陪集的。这点如果能恒成立的话，那么这个群 $H$ 就一定是一个正规子群。另外，群 $H$ 的所有左陪集都有同样的大小。这一点的理由是：左乘群 $g$ 中的元素这个动作总是可逆的，再左乘回 $g^{-1}$ 就可以了。这样一来，左乘 $g$ 就实际形成了一个集合间的双射，也就是所谓的同构。它保证了元素个数相同。也正因如此，用左乘 $a$ 定义的 $H \to aH$ 就保证了 $H$ 与 $aH$ 的元素个数相同了。由于 $g$ 是任意选取的，所以任意的左陪集都有相同个数的元素了。这个结论对右陪集而言也是显而易见的。&lt;/p>
&lt;p>另外我们提一下记号的问题。对于使用乘法记号的群而言，由于我们的子群本身就是一个群，所以一定有一个单位元。而根据左陪集的形态，我们就知道了：每个左陪集中一定有一个元素，这个元素就是子群 $H$ 的单位元乘上我们左陪集所左乘的元素。简单来说，如果有一个左陪集 $gH$，那么这个左陪集里面就一定有一个元素 $g 1_H$。而既然左陪集中每个元素之间都是等价的，我们很自然地就可以使用这个元素来代表这个左陪集。至于记号，我们上面已经介绍了：$\hat{g}$ 就可以代表 $gH$。诶？那假如我用单位元去左乘以这个子群，得到的就是？没错，就是子群本身形成的陪集。而这个特殊的陪集在我们下面定义的商群乘法下自然就是我们需要的单位元了。&lt;/p>
&lt;p>我们定义正规子群为左陪集等于右陪集的子群。在这个定义下，很明显就可以看出，满足交换律的交换群里没有不正规的子群了，因为很轻易地就得到了左陪集等于右陪集，只需要把交换律下放到陪集内元素的计算过程中即可得到。那么对于交换群/阿贝尔群而言，陪集的记号是什么样的呢？我们很轻易就可以类比出来：既然乘法记号的群是用一个元素左乘子群得到左陪集，那么加法记号的群就用一个元素加上一个子群得到这个子群的陪集即可。同样，我们可以使用这个加上去的元素来代表这个陪集，方法也是在上面戴个小帽子。&lt;/p>
&lt;p>有了正规子群，我们就可以愉快地进行商群的构造了。然而，为什么必须是正规子群呢？不能商去一般的子群吗？答案藏在商群运算的合理性中&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>为了尝试从普通的子群构造商群，我们取子群的左陪集们然后就可以形成一个集合了。这个集合内的每个元素都是子群的左陪集。现在我们希望给这个集合上面添加运算。由于左陪集的元素是形如 $gH$ 这样的，所以我们自然希望 $g_1H \cdot g_2H = (g_1g_2)H$，也就是可以直接借用我们在群 $G$ 或 $H$ 中已经有的乘法了。这样定义的乘法满足了群运算的所有性质。然而，定义这个乘法不能靠我们一厢情愿，我们得检查定义的是否合理，即设 $a, a' ,b$ 是满足了 $aH = a' H$ 的任意的 $G$ 中的元素，我们要有 $(aH)(bH) = (ab)H = (a'b)H = (a'H)(bH)$。&lt;/p>
&lt;p>根据陪集定义，我们取任意的 $h_1$, $h_2$ 以及由它们决定的某个 $h_3$，则有 $ah_1bh_2 = a'bh_3$。由于 $aH=a'H$，根据之前的论述，我们指导一定有某个 $h_4$ 满足 $a = a'h_4$。我们带入前面式子，有 $a'h_4h_1bh_2 = a'bh_3$。根据群乘法可逆的条件，有 $h_4h_1bh_2 = bh_3$，我们再把 $h_2$ 的逆乘到等式右边，根据 $H$ 中乘法封闭性，就有：$h_5b=bh_6$。由于我们的 $h_1$，$h_2$ 是任意的，$a$，$b$ 也是任意的，所以 $h_3$ 和 $h_4$ 也不受额外条件的束缚，进而 $h_5$ 与 $h_6$。再回忆我们的左陪集和右陪集的定义，因此我们可以认为：为了满足我们的乘法条件，则必须要有 $Hb = bH$，这正说明了 $H$ 必须是正规的。至此，你应该已经发现：为满足运算的合理性，子群 $H$ 必须是正规子群。&lt;/p>
&lt;p>我们也可以这样理解。取 $G$ 中的任意两个元素 $g_1$与 $g_2$，再取 $H$ 中任意的两个元素 $h_1$ 与 $h_2$，我们要保证 $g_1h_1g_2h_2 = g_1g_2h_3$，其中 $h_3$ 可以是某个由计算过程得到的一个 $H$ 中的元素。要想把 $g_2$ 往左挪过去和 $g_1$ 凑成一对儿的形式，我们必须要让 $g_2$ 和 $h_1$ 存在某种形式的 “交换律”，这样的交换律必须保证 $g_2$ 还是 $g_2$，$h_1$ 则必须还是 $H$ 中的元素。但是，很可惜，这样的 “交换律” 只能存在于真的交换群，或者最低限度的办法：让左陪集等于右陪集，也就是正规子群中。否则这两点无法保证。&lt;/p>
&lt;p>上面这个说明，也是为了指出证明定义合理的重要性。这一点在代数中是十分重要的。而在讨论完陪集和正规子群的重要性后，我们最后要讨论的是：&lt;em>商&lt;/em> 到底是什么。&lt;/p>
&lt;p>我们其实已经指出过，商就是所谓的分类。小学学到的 “分堆问题” 就已经是对 &lt;em>商&lt;/em> 这个字非常好的诠释了。至于为什么用了 “商” 这个字…… 首先，我不知道；其次，也许可以问商鞅？（什么地狱笑话）&lt;/p>
&lt;p>商结构远不止存在于群或者集合中。商结构几乎存在于任何代数对象里。我们可以对拓扑空间做商结构，就像是把纸/空间缝起来/黏起来一样，这样我们就可以得到各种有趣的拓扑空间，比如甜甜圈（环面）、克莱因瓶、莫比乌斯环带等；我们可以把整数轴折叠起来，这样可以得到一个有限群（还很有可能是循环群）；我们还可以把 $\mathbb{R}$ 上多项式空间（就是所有以实数作系数的多项式组成的线性空间）商去多项式 $x^2+1$，这样得到的就是我们熟悉的复空间（复述域）。这里我们提出一种理解商空间的方法：把空间的某些点/线/面或者什么东西黏起来。这个 “黏起来” 的动作，实际上就是把某些点看作同一个点，而这样就等于定义了一个等价关系：黏起来后到同一个点的原空间内的点就在同一个等价类里面。&lt;/p>
&lt;p>此时你可以看到，如果你有一种分类方法，并且你可以用什么办法把代数对象里的元素放到不同的几堆儿里，那你就已经可以生成一个商结构了。它最最最最最起码也是一个商集，而要是你分类方法足够好，你得到的商结构就会更好。我们最后提一下商结构的记号，一般有两类表示方法：一是商去一个等价关系，二是商去用这个等价关系生成的等价类。这两种记号一般都是代表着同一个含义的。利用这个等价关系对原代数结构进行划分会得到若干等价类，其中的一个就是商去等价类记号中的那个等价类。&lt;/p>
&lt;p>So，这就是对这么几个代数学结构的解释了。希望你不要因为这些文字而感到眩晕的同时，得到一些对这些代数结构直观的解释。我们回到主线吧。&lt;/p>
&lt;/details>
&lt;h3 id="正合列以及一点点点点范畴论">正合列，以及一点点点点范畴论
&lt;/h3>&lt;p>现在我们已经清楚了什么是交换群，什么是同态，什么是核，像，商群以及余核。是时候看看我们想要研究的结构了：正合列，以及对应的图。下面就是我们要研究的对象，也是一个图的例子：两个整合列所组成的图。&lt;/p>
&lt;figure>
&lt;img src="image/Commute_Diag.svg" style="width:60%">
&lt;figcaption>两个整合列，通过整合列间的同态链接&lt;/figcaption>
&lt;/figure>
你可以在图中看到两个虚箭头，这两个虚箭头我们先把它们看成实线的，也就是实际存在的。后面证明蛇引理的时候这两个箭头是可以不存在的（当然也就没有连接着的0了）。
&lt;h4 id="链复型">链复型
&lt;/h4>&lt;p>我们先来说说正合列（Exact Sequence）。上图中的正合列有两个，分别是 $0\to A \to B\to C\to 0$ 以及 $0\to A' \to B'\to C'\to 0$。它们中的 $0$, $A$ 等我们称之为 &lt;em>点&lt;/em>，实际上是一个个交换群（一般是模，我们这里取交换群即可），而每个箭头都代表着一个同态。这些同态有着特殊的要求，如果这些同态只是一般的同态，那它们就什么都不是。为了使之成为整个列，我们需要先得到所谓的链复型（Chain Complex，上下文明确时可能直接叫复型 Complex）。&lt;/p>
&lt;p>链复型要求使用同态将一系列的数学对象连接起来，通常这些数学对象以及对应同态还会有一定的顺序，且同态之间的复合还要满足特殊的要求。具体而言，链复型要求这样的序列：&lt;/p>
$$\cdots\xrightarrow{d_{i+2}} M_{i+1}\xrightarrow{d_{i+1}} M_i \xrightarrow{d_i} M_{i-1} \xrightarrow{d_{i-1}} \cdots$$&lt;p>满足条件：$d_{i+1}\circ d_{i} = 0$ 对于所有的 $i$ 都成立。这样的链复型可以被记作 $(M_\bullet,d_\bullet)$。这样的定义蕴含了下面的信息：&lt;/p>
&lt;ol>
&lt;li>交换群的序号从高到低，同态序号也从高到低&lt;/li>
&lt;li>对于所有的同态而言，左侧的同态复合上右侧同态得到的是零同态，也就是把所有的元素映射到单位元上（对于交换群，单位元就是0）&lt;/li>
&lt;li>由上面一条，如果左侧同态复合右侧同态得到了恒通映射，就说明左侧的同态必须把元素映射到右侧同态的核里面。若不然，则无法达成两次复合后为零同态。&lt;/li>
&lt;/ol>
&lt;p>链复型的结构要求每个点都是同一种结构（交换群），且某个点里的任何一个元素沿着链复型移动两次后一定会映射到单位元（后面称零元）上。这样的代数结构是为了方便我们讨论所谓的 &lt;em>同调&lt;/em>，也正因如此，链复型是同调代数中最基础也最重要的代数结构之一。&lt;/p>
&lt;h4 id="同调群正合正合列">同调群，正合，正合列
&lt;/h4>&lt;p>上面提到，正合列是在链复型商加条件得到的，而这个所谓的条件就是 &lt;em>正合&lt;/em> 条件。而为了讨论正合，我们还要引入同调群的概念。有了同调群，正合就非常好判断了。&lt;/p>
&lt;p>我们还是用上面的链复型来举例，所谓的同调群是指这样的商结构：&lt;/p>
$$H_n(M_\bullet) \vcentcolon= \Ker d_n/\Img d_{n+1},$$&lt;p>即一个同态的核与上一个同态的像之间的商群。当链复型的某个点处（即某一个 $n$）的同调群是平凡群（即只有一个元素的群，记作 $0$）时，我们称这个点上是 &lt;em>正合的&lt;/em>。而如果每个点都是正合的，我们就叫这个链复型为正合列。表达正合关系也可以不借助同调群，因为同调群等于平凡群就相当于说&lt;/p>
$$\Ker d_n = \Img{d_{n+1}},$$&lt;p>从这个角度来看也许更好理解正合是什么样的关系。仅从集合的角度来讲，链复型的要求就是在说 $\Img d_{n+1}$ 必须在 $\Ker d_n$ 的里面，它们之间可能有缝隙：$\Img d_{n+1} \subseteq \Ker d_n $；而正合则表示，这两个集合之间是没有缝隙的。这也许也是&lt;strong>正&lt;/strong>合这个字的来源吧。&lt;/p>
&lt;p>最后我们指出，我们上面的那个图片里所给出的两个正合列更为特殊，因为很短，所以叫它 &lt;em>短正合列&lt;/em>。不难看到，由 $0$ 出发的态射是单态，到 $0$ 结束的态射则是满的。而又根据正合的条件，可以得到 $f$ 必须是单态（不然 $\Ker f \neq 0$），$g$ 则必须是满态（否则 $\Img g \neq 0$。&lt;/p>
&lt;h4 id="图与交换图">图与交换图
&lt;/h4>&lt;p>学代数的时候会遇到许许多多用箭头代表的态射，而我们也常常需要将态射复合起来形成新的态射。有时我们又会发现，一个态射可以通过两种甚至多种不同的态射复合方式得到。单靠语言经常会感到乏力，自然而然地，我们想到用图（Diagram）来绘制出这样的想法，把一些态射按照对应的数学对象连接起来。上面链复型或者正合列的表示实际上已经是一副图了，但是这个图还是比较简单的。而当我们发现一个态射可以通过不同的态射复合方式得到时，我们就可以把它们画出来，这样的图我们称是交换的，这种图我们叫做交换图（Commutative Diagram）。&lt;/p>
&lt;p>以上面的用两个短正合列组成的那个图举例，如果有 $\beta\circ f = f'\circ\alpha$ 以及 $\gamma\circ g = g'\circ\beta$，那么它就是一个交换图。我们后面把态射复合时中间的圆圈 $\circ$ 省略掉。&lt;/p>
&lt;h4 id="一点点的范畴论">一点点的范畴论
&lt;/h4>&lt;p>我们最后简单地提一嘴范畴论吧。范畴论是从拓扑那里来的，是根据不同的几何结构间精巧的关系而诞生的描述这种关系的语言，但是后来逐渐被大家发现，好像很多数学结构之间也是可以构建出类似关系的。自此，便有数学家开始建立范畴论，用以正式地，形式化地描述不同数学结构它们内部的或之间的关系。&lt;/p>
&lt;p>我们举一些简单的例子，来看看什么是一个 &lt;em>范畴&lt;/em>（Category）。一个很简单的例子就是 &lt;em>所有&lt;/em> 的集合以及集合之间的 &lt;em>所有&lt;/em> 函数们所构成的范畴 $\mathsf{Set}$ 了（具体某个范畴的记号一般使用无衬线体，根据情况省略部分字母），另一个例子则是所有群以及所有的群之间的同态所构成的范畴 $\mathsf{Grp}$。可以看到很多都是 “所有的数学对象以及它们之间所有的同态构成的范畴” 这样的形式。这样的范畴还是比较基础且常见的，且根据这样的形式，我们可以很自然地总结出别的一些范畴，比如 $\mathbb{R}$ 上的所有线性空间以及所有的线性映射构成的范畴 $\mathsf{Vect_\mathbb{R}}$，所有的环以及其同态构成的映射构成的范畴 $\mathsf{Rng}$，等等等等&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>范畴之间是可以相互联系起来的，这种联系我们也可以像箭头一样写出来，称为函子（Functor）。而函子之间也可以做出联系，称为所谓自然变换（Nature Transformation）。不过好消息是，我们不需要关注这些内容，而只需要关注某一个具体范畴（具体来讲，就是阿贝尔群范畴 $\mathsf{Ab}$）的内部即可。&lt;/p>
&lt;p>范畴的作用除了给出不同类型的数学对象之间有什么样的联系之外，也给我们提供了一个讨论问题的舞台。我们可以直接讲我们在某个范畴中研究什么样的问题，此时范畴本身就给出了我们要研究内容的重要信息。另外，范畴论给了我们一些用以描述数学对象关系的语言，它们通常可以一针见血地指出数学对象间是什么样的关系，当然也因为过于抽象且过于具有总结性而被戏称为 “抽象废话”。&lt;/p>
&lt;p>最后，借助范畴论中的一些内容，比如交换图，我们可以方便地描述数学对象之间的关系。&lt;/p>
&lt;details>&lt;summary>所以什么是范畴呢？&lt;/summary>
我们这里引入范畴的原因其实非常地单纯：希望能引入所谓的交换图这一概念。虽然它本身的引入其实用不太上范畴，但是也许是出于我的私心吧，感觉这里引入范畴也能更好地规范我们研究问题的范围。
&lt;p>那么什么是范畴呢？范畴其实就是一系列对象以及它们之间态射所构成的集合体。我们这里引用著名代数学教材，李文威老师的《代数学方法》中对于范畴的定义。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>范畴的定义&lt;/strong>：&lt;/p>
&lt;p>一个范畴 $\mathcal{C}$ 是指以下的资料：&lt;/p>
&lt;ol>
&lt;li>一个集合 $\mathrm{Ob}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong>对象&lt;/strong>；&lt;/li>
&lt;li>另一个集合 $\mathrm{Mor}(\mathcal{C})$，其元素称为 $\mathcal{C}$ 的 &lt;strong>态射&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>另外，对上面两个集合之间有这样的要求：&lt;/p>
&lt;ul>
&lt;li>两集合间有一对映射： $s\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$ 和 $t\vcentcolon\space\mathrm{Mor}(\mathcal{C}) \to \mathrm{Ob}(\mathcal{C})$，它们分别指出了态射的&lt;strong>来源&lt;/strong>与&lt;strong>目标&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>对于态射而言，有这样的要求：&lt;/p>
&lt;ul>
&lt;li>针对某两个对象 $X,Y\in\mathrm{Ob}(\mathcal{C})$，我们可以从上面这一对映射中得到这两个对象之间的所有态射的集合：$\mathrm{Hom}_\mathcal{C}(X,Y)\vcentcolon=\space s^{-1}(X)\cap t^{-1}(Y)$。在明确所指范畴的情况下可简记为 $\mathrm{Hom}(X,Y)$。这样的集合也被称为 $\mathrm{Hom-}$ 集；&lt;/li>
&lt;li>对于任意的一个对象 $X$，一定存在一个态射 $\mathrm{id}_ {X} \in \mathrm{Hom}_{\mathcal{C}}(X,X),$ 这个态射被称为 $X$ 到自身的恒等态射；&lt;/li>
&lt;li>给定任意的三个对象 $X,Y,Z\in\mathrm{Ob}(\mathcal{C})$，有这样在其 $\mathrm{Hom-}$ 集之间的映射，称为&lt;strong>合成映射&lt;/strong>，定义为：
$$\begin{align*}
\circ\vcentcolon\space\mathrm{Hom}_\mathcal{C}(Y,Z) \times \mathrm{Hom}_\mathcal{C}(X,Y)&amp;\to \mathrm{Hom}_\mathcal{C}(X,Z)\\
(f,g)&amp;\mapsto f\circ g\\
\end{align*}$$
且当不至于混淆时可以省略中间的 $\circ$，将 $f\circ g$ 简记为 $fg$。&lt;/li>
&lt;/ul>
&lt;p>最后，对上面的合成映射而言，有这样的两个要求：&lt;/p>
&lt;ol>
&lt;li>结合律：对于任意的态射 $h,g,f\in\mathrm{Mor}(\mathcal{C})$，如果映射的合成 $f(gh)$ 和 $(fg)h$ 都有定义，那么 $$f(gh) = (fg)h.$$&lt;/li>
&lt;li>对于任意的态射 $f\in\mathrm{Hom}_\mathcal{C}(X,Y)$，其与恒等映射之间的复合满足关系：
$$f\circ\mathrm{id}_X = f = \mathrm{id}_Y\circ f.$$&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;p>那么以上，就是范畴的比较正式的定义。可以看到它还是有依赖一些集合论的内容的，但这只依赖于对象集合和态射集合之间的映射，以及在 $\mathrm{Hom-}$ 集之间的映射，并不涉及某个具体的代数结构，特别是没有涉及到在集合上添加运算得到的代数结构。我们一般称这样有集合作为 “基底” 的范畴为 &lt;em>具体范畴&lt;/em>。另外，由于范畴的定义非常灵活，实际上可以定义出非常抽象的范畴，比如以态射作为对象的范畴。&lt;/p>
&lt;p>最后要指出的是，范畴最关键的应该是态射，而不是范畴内的对象。范畴论以研究对象间的态射来研究范畴的行为。从范畴的定义中也可以看到，众多的要求都是对态射提出的，而非对对象。在使用或研究范畴时，应注意这一点。&lt;/p>
&lt;/details>
&lt;h3 id="所以蛇引理到底讲了什么">所以，蛇引理到底讲了什么
&lt;/h3>&lt;p>终于，我们把为了描述蛇引理讲了什么而需要的一些基础内容介绍完了。可以看到，蛇引理还是需要比较多的前置的。下面就是这个所谓的蛇引理了。我们介绍的是建立在两个短正合列所构成的交换图上的简单版本的蛇引理。具体内容如下：&lt;/p>
&lt;blockquote>
&lt;p>蛇引理：&lt;/p>
&lt;p>设有如下图所给出的交换图：&lt;/p>
&lt;figure>
&lt;img src="image/Commute_Diag.svg" style="width:60%">
&lt;/figure>
其中第一行和第二行均为正合列，每个点均为阿贝尔群（交换群）。由这样的两个正合列，我们可以构造出下面的正合列：
&lt;figure>
&lt;img src="image/Snake.svg" style="width:90%">
&lt;/figure>
且当交换图中的虚线箭头成立时，对应的虚线箭头也成立。&lt;/blockquote>
&lt;p>这条引理由于构造出的正合列需要像蛇一样从交换图的左上角开始出发一路拐到右下角而得名。真是恰当的名字。由于我们已经知道所谓的余核，所以上面的正合列实际上还可以写成这样更加对称的形式：&lt;/p>
&lt;figure>
&lt;img src="image/Snake_Coker.svg" style="width:90%">
&lt;/figure>
&lt;!-- $$
0\dashrightarrow \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma \dashrightarrow 0
$$ -->
&lt;details>&lt;summary>对称？对称在哪？&lt;/summary>
我们常常讲 “对称”，对称常常能带来强烈的美感。然而，对称到底是什么？
&lt;p>我们从小就知道轴对称，稍晚会学到中心对称，旋转对称等等。然而这些对称始终没有一个综合的描述方法，它甚至不像是数学的内容，反而更像是美术的内容。然而，有了群，我们就可以描述这样的对称性了：对称，就是使用一个群对其进行作用后仍然能回到自身的性质。对称就蕴含于群内部。&lt;/p>
&lt;p>然而我们这里打算提到的对称，并不是和群相关的，而是和交换图相关的。从交换图上可以看到，如果把底下的链条用余核来代替，那么这个图就是非常对称的：上面是核构成的链条，下面是余核构成的链条；左下角是一个单态，而右上角则是一个满态。然而我们肯定不能单纯满足于这样的只从图上看到的对称，我们想问这样的问题：余核，它和核的定义区别如此之大，为什么会这么自然地存在于这个图内？它们俩之间究竟有什么样的关系，让最后的这个交换图呈现了这样的形状？或者问得更简单一些：余核，什么是 &lt;em>余&lt;/em>？它好像是剩余的意思，但是从英文上来看又完全看不出这样的关系。&lt;em>余&lt;/em> 到底是什么？&lt;/p>
&lt;p>我们做一点剧透：因为范畴和交换图，即因为核与余核之间定义的对称性。可能会有人有这样的疑问：核与余核之间的定义的对称性？从形式上来看完全没有任何的对称性呀？我们指出：在范畴论的语言下，两者完全可以使用 &lt;em>泛性质&lt;/em> 进行定义。我们后面会提到所谓的泛性质是什么。&lt;/p>
&lt;p>我们观察核的定义：核是对一个同态定义的。比如有这样的（群）同态：$\varphi \vcentcolon G\to H$，那么这个同态 $\varphi$ 的核就是一些群 $G$ 中的元素所组成的集合，这些集合在同态 $\varphi$ 的作用下会映射到群 $H$ 的单位元处。或者我们采用原像的写法，$\Ker \varphi = \varphi^{-1} (1_H)$。&lt;/p>
&lt;p>那么我们应该怎么把他改写成使用范畴定义的东西呢？我们抓住范畴论的核心思想：使用态射来研究对象。作为一个同态的核，它在映射之后一定会到单位元上；作为一个群，它一定是同态的定义域的子群。我们可否用这个性质来做文章？答案是肯定的：我们就如此定义，但通过范畴论的语言来描述这个过程。&lt;/p>
&lt;p>我们定义态射 $\varphi \vcentcolon G\to H$ 的核是这样的一个群范畴 $\mathsf{Grp}$ 中的一个对象 $\Ker \varphi$，这个对象到同态 $\varphi$ 的定义域 $G$ 之间存在一个包含同态&lt;/p>
$$\begin{align*}
\iota \vcentcolon \Ker \varphi &amp;\hookrightarrow G\\
g &amp;\mapsto g
\end{align*}$$&lt;p>（我们这里使用带钩箭头标明它是一个单态）；此外，这个对象满足这样的性质：对于任意的同态 $\alpha\vcentcolon X\to G$，只要满足条件&lt;/p>
$$\varphi\circ\alpha = 0,$$&lt;p>（此处 $0$ 代表零映射，或者叫平凡映射（Trivial Map），即将所有的元素都映射到单位元 $1_H$ 上），那么同态 $\alpha$ 即可被唯一地分解，即对某个 $\alpha$ 而言，存在唯一的一个同态 $\overline{\alpha}\vcentcolon X\to \Ker \varphi$，满足 $\alpha = \iota\circ\overline{\alpha}$。将这些性质使用交换图来描述的话，就是说下面的这个交换图成立：&lt;/p>
&lt;figure>
&lt;img src="image/Kernel.svg" style="width:40%">
&lt;figcaption> 核的定义 &lt;/figcaption>
&lt;/figure>
&lt;p>换句话来说，对于任意满足条件 $\varphi\circ\alpha = 0$ 的态射 $\alpha \vcentcolon X \to G$，它们都一定可以被分解成两个映射，且这个分解方式是固定的：先有一个唯一的映射 $\overline{\alpha}$ 将 $X$ 映射到一个群上，然后再从这个群出发，保持原样地通过包含映射 $\iota$ 映射到原态射的陪域 $G$ 中。而这样的固定且特殊的元素，就是我们要找的映射 $\varphi$ 的核，也就是 $\Ker \varphi$。&lt;/p>
&lt;p>我们观察这样的定义，它实际上确实定义出了我们熟悉的核，只不过是用了更加范畴论的形式，并没有研究元素内部是如何映射的，而是使用了 &lt;em>平凡映射&lt;/em> 来包含所有我们需要的信息，再通过唯一分解的方式来确定它的地位。它只是换了一种更加 fancy 的说法而已。&lt;/p>
&lt;p>而接下来，我们就要仿照这样的形式，来定义余核。我们先来观察已有的余核定义，它被定义为同态的陪域模除掉同态的像得到的结构。为此，我们需要先来看看商的泛性质。我们依旧在群范畴内讨论这个问题，但是它很容易就可以推广到其他的结构中。&lt;/p>
&lt;p>从商的构造过程来看，构造商结构时需要取一个等价关系，然后根据这个等价关系进行划分，最后将所有的等价类放在一起，每个等价类作为一个商结构中的一个元素，这就是取商的过程。如果要在范畴论中讨论这个问题，那么就需要从与商相关的态射出发考虑这个问题。首先我们看取商的过程。&lt;/p>
&lt;p>鉴于上面的过程的统一性，我们将这个过程化为一个态射，称之为商映射 (Quotient Map)，记作 $\pi$。当明确左或右陪的元素时，也可以在这个记号的左下标处记下该元素，如从整数群构造 n 阶循环群的过程，其商映射就可以记为 $\pi_n\vcentcolon\mathbb{Z}\to\mathbb{Z} /n\mathbb{Z}$。有了这样的记号，我们的讨论也会更加便利。&lt;/p>
&lt;p>既然从态射角度出发，我们想观察：假如从群 $G$ 到群 $G'$ 有一个同态 $\varphi$，而群 $H$ 是 $G$ 中的正规子群（因此可以被模掉）且 $H\subseteq \Ker \varphi$（为了保证商群依旧能映射到 $G'$ 上）。那么，这个同态 $\varphi$ 与 $G$ 模 $H$ 得到的子群 $G/H$ 之间有什么样的联系呢？我们有这样的定理，同样，可以用交换图来表示：如果有上述条件存在，那么则存在一个唯一的映射 $\overline{\varphi}$，使得 $\varphi = \overline{\varphi} \circ \pi$，即下面的图交换：&lt;/p>
&lt;figure>
&lt;img src="image/Quotient.svg" style="width:40%">
&lt;figcaption> 商的泛性质 &lt;/figcaption>
&lt;/figure>
&lt;p>怎么理解这个图的交换性呢？当我们把 $G$ 映射到 $G'$ 时，由于该映射的核的限制，必须有和核的元素个数一样多的元素被映射到同一个 $G'$ 中的元素里（考虑我们定义的核，以及商映射的特点）；当将 $G$ 商映射到 $G/H$ 上面时，由于 $\Ker \varphi$ 的元素比 $H$ 中的元素数量要多（上面的子集关系），此时从 $G$ 到$G'$ 的同态 $\varphi$ 对其定义域 $G$ 的 “收缩力度” 是一定不如商映射 $\pi$ 的。因此，我们一定可以从商映射得到的 $G/H$ 中再做一次映射，从 $G/H$ 重映回 $G'$，使得 $\varphi$ 最后被表示为 $\overline{\varphi}$ 与 $\pi$ 的复合。也就是说，$\varphi$ 被分解为了两步：首先，通过正规子群进行分类，由于我们取的正规子群比核小，所以商群内的每个元素必定被映射到同一个元素内;在进行这样的分类后，再进行一次映射，把分好的等价类按照其中元素原有的根据 $\varphi$ 的映射方式来将这些等价类映射到对应的 $G'$ 中的元素里。由于拉格朗日定理，子群的关系保证了这样分类得到的等价类个数一定是整除态射 $\varphi$ 的像的，这也就保证了这个同态是良好定义的，并不会出现一个等价类映射到两个 $G'$ 中元素，或者映射到同一 $G'$ 中元素的等价类数目不同这样的情况。&lt;/p>
&lt;p>在理解上面定理的含义后，我们指出：实际上我们可以借助商的这一泛性质来定义商结构和商映射，即：设 $G$ 是一个群，其有一正规子群 $H$，则通过如下两个泛性质即可定义商群 G/H 与商映射 $\pi$：&lt;/p>
&lt;ol>
&lt;li>存在一个群 $G/H$ 和一个群同态 $\pi\vcentcolon G\to G/H$，满足 $\Ker \pi = H$；&lt;/li>
&lt;li>对任意的群 $G'$ 与 群同态 $\varphi\vcentcolon G\to G'$，如果 $H \subseteq \Ker \varphi$，则存在一个唯一的群同态 $\overline{\varphi} \vcentcolon G/H \to G'$，使得上面的交换图成立。&lt;/li>
&lt;/ol>
&lt;p>也许你有疑问：我们不是在看余核是怎么回事吗？你怎么扯到商结构和商映射用泛性质的定义了？正是由于有了商结构的泛性质，我们才能更好地定义我们已经知道的余核。&lt;/p>
&lt;p>这里也不继续卖关子了，为了定义余核，我们需要做的事情只有三件：一，将上面核的泛性质图里的所有箭头转向；二，把 $\Ker \varphi$ 换成 $\Coker \varphi$，把带钩箭头换成双箭头（代表满态），再把包含映射记号 $\iota$ 换为商映射记号 $\pi$；最后，我们再仿照核的定义，来讲所谓的余核是什么的时候，需要将群改为阿贝尔群（交换群）。我们先把表示它泛性质的图画出来；为了方便对照，我们把核对应的泛性质图用另一种形式画出并附上（两种交换图是完全等价的）：&lt;/p>
&lt;div style="display: flex">
&lt;figure style="float: left; flex: 50%">
&lt;img src="image/Coker.svg" style="width:80%">
&lt;figcaption> 余核 &lt;/figcaption>
&lt;/figure>
&lt;figure style="float: left; flex: 50%">
&lt;img src="image/Ker.svg" style="width:80%">
&lt;figcaption> 核 &lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>相信到了这一步，你一定会相信所谓的 “对称” 绝非空穴来风。所谓的余核，说得简单点，就是把核的泛性质里的所有箭头都反转后定义出来的东西而已；甚至于对于范畴论而言，所谓的 “余” 就是将某个对象的泛性质里箭头全部反转后出现的对偶。一个著名的范畴论笑话是这么讲的：&lt;/p>
&lt;p>&lt;em>A mathematician is a device for turning coffee into theorems, and a comathematician is a device for turning cotheorems into ffee.&lt;/em>&lt;/p>
&lt;p>我们再来看看余核的泛性质。很容易就可以看到余核的交换图的右侧出现了我们熟悉的身影：商结构和商映射的泛性质。通过这个小块我们得以了解到，$\Coker \varphi$ 应该具有某种商结构，需要用 $H$ 商去它的一个正规子群。那么它具体应该商去谁呢？注意到两点：&lt;/p>
&lt;p>第一点是，商结构的特点决定了它要商掉的那个正规子群本身是可以作为陪集存在于商群中的。举个简单快速的例子，$A/B$ 这个商群里 $B$ 本身就是一个陪集，是用 $A$ 中单位元 $1_A$ 去陪 $B$ 得到；而这个特殊的陪集，由于用来左陪的元素是 $A$ 中单位元，它在商群 $A/B$ 中一定也是担任单位元的责任；&lt;/p>
&lt;p>另一个点则来自于 $G\to X$ 必须是平凡映射这一要求。我们根据余核的泛性质，可以轻松地取这样的 $\beta$，让它就等于 $\pi$，这样一来 $\overline{\beta}$ 就变成了恒等映射，$X$ 也就变成了我们研究的 $\Coker \varphi$。那么，从群 $G$ 出发，在映射到 $\Coker \varphi$ 时必须到它的单位元上，那么从商映射的特点看，所有的 $G$ 中的元素都必须在经过 $\varphi$ 映射后出现到 $\Coker\varphi$ 商去的那个正规子群里。而满足这样条件的东西只有一个，即 $\Img \varphi$，且还有一个要求，就是 $\Img \varphi$ 必须是正规的，这就要求 $H$ 是交换群，进而要求整个泛性质中的群都得是交换群。&lt;/p>
&lt;p>如此，我们又成功地从余核的泛性质的定义里拿到了我们熟悉的，用商群定义的那个余核。这也进一步指明了核与余核在范畴论意义下的对偶关系。然而，对于核以及余核而言，它们的定义还可以更加 fancy 一些：我们可以使用极限和余极限来定义核与余核，这里就不过多展开了，毕竟这篇文章不是讲范畴论的，而是为了证明蛇引理的来着（）&lt;/p>
&lt;/details>
&lt;h2 id="准备证明吧">准备证明吧
&lt;/h2>&lt;p>我们的手牌已经集齐了，现在等待着我们的就是要证明这个引理。这个引理涉及到的阿贝尔群很多，同态也很多。我们需要一步一步地朝着目标前进，否则这个大个家伙是没办法一次搞定的。&lt;/p>
&lt;h3 id="证明思路">证明思路
&lt;/h3>&lt;p>从最后的结果来看，我们有这样的几个问题是需要验证的：&lt;/p>
&lt;ol>
&lt;li>$f|$ 的定义是否合理&lt;/li>
&lt;li>$g|$ 的定义是否合理&lt;/li>
&lt;li>$\hat{f'}$ 如何定义，是否良定&lt;/li>
&lt;li>$\hat{g'}$ 如何定义，是否良定&lt;/li>
&lt;li>$\delta$ 如何定义，是否良定&lt;/li>
&lt;li>每个点处是否正合&lt;/li>
&lt;li>若原交换图虚线箭头成立，得到的正合列是否对应虚线箭头也成立&lt;/li>
&lt;/ol>
&lt;p>我们不计划纠结于为什么核与余核在这里出现的如此频繁，只将之作为待证明的结论；也就是说，我们不考虑为什么选择了这样的构造，只考虑证明这个构造为什么是正确的。另外，我们可以发现第1点与第2点是很相似的，同样第3点与第4点也是很相似的。&lt;/p>
&lt;p>在正式开始进行验证之前，我们做一些符号上的约定，以免待会儿晕符号。如果是 $A$，$B$，$C$ 中的元素，我们就用对应的小写字母代表；如果是 $A'$，$B'$，$C'$ 中的元素，我们就在对应小写字母的上面也对应地加上这个 $\prime$。如果需要从同一个群中取两个元素，为了区分它们，我们会再在右上角添加上 $*$ 来表示。如果是经过了同态/映射的作用，在需要时会加上其属于的群以做提示，而不再用 $\prime$ 或者别的字母做记号，除非这样的记号是必须的。&lt;/p>
&lt;p>好了，我们开始正式的证明过程吧。&lt;/p>
&lt;h3 id="验证-f-的定义然后-g">验证 $f|$ 的定义，然后 $g|$
&lt;/h3>&lt;p>我们第一个要验证的是 $f|$ 的定义，或者说仔细考虑怎么样去定义它。从图上可以看到，这个同态是 $f$ 在 $\Ker \alpha$ 上的限制，对它的定义的验证则是要验证 $f|$ 是否真的能把 $\Ker \alpha$ 映射入 $\Ker \beta$ 中，即验证 $\Img f| \subseteq \Ker \beta$。&lt;/p>
&lt;p>为了验证这件事，我们只需要任意取 $\Ker \alpha$ 中的元素，如果这些点在 $f|$ 的映射下都属于 $\Ker \beta$，就可以验证这样的包含关系了（这也是子集的定义）。既然如此，我们取 $\Ker \alpha$ 中的一个元素 $a$，根据核的性质，既然 $a$ 在 $\alpha$ 的核内，我们知道 $\alpha (a) = 0 \in A'$，再根据同态的性质，群同态只能将单位元/零元映射到单位元/零元上，我们知道 $f' \alpha (a) = 0 \in B'$。由于交换图的性质，我们有：$\beta f (a) = f' \alpha (a) = 0$。请注意 $\beta (f(a)) = 0$ 就意味着 $f(a)$ 这一点位于 $\Ker \beta$，即 $f(a) \in \Ker \beta$，而这恰恰就是我们要证明的：任意一个 $\Ker \alpha$ 中的元素 $a$ 在经过 $f|$ 映射之后，都位于 $\Ker \beta$ 中。&lt;/p>
&lt;p>这里有一个点需要指出：为什么我们明明要验证的同态是 $f|$，最后却直接使用了 $f$ 的性质？这是因为：$f|$ 除了更改了定义域的范围之外，所有的信息都得以保留。由于我们任取的 $a$ 满足 $a\in\Ker \alpha \subseteq A$，所以 $f|$ 对在 $\Ker\alpha$ 中语境下的 $a$ 所产生的影响，和 $f$ 对 $A$ 中语境下的 $a$ 产生的影响是一模一样的。这保证了我们可以放心大胆地使用 $f$ 的性质。&lt;/p>
&lt;p>最后我们指出，这里的验证过程没有借助图表交换以及核的性质以外的任何要素，因此这套证明也可以直接照搬到下一个交换块，也就是关于 $g|$ 的定义的验证问题上。这里就不啰嗦了。&lt;/p>
&lt;h3 id="验证-hatf-的定义顺带-hatg">验证 $\hat{f'}$ 的定义，顺带 $\hat{g'}$
&lt;/h3>&lt;p>接下来要验证的就是 $\hat{f'}$ 的定义了。我们要验证的东西其实和上面类似，也是 $\Img \hat{f'} \subseteq \Coker \beta$。然而我们现在还不知道 $\hat{f'}$ 具体是怎样的，只知道它的定义域是 $\Coker \alpha$。所以我们先来看看 $\Coker \alpha$ 里都有什么，再看看 $\hat{f'}$ 是一个什么样的同态，最后来考虑验证上面所要求的定义。&lt;/p>
&lt;h4 id="operatornamecoker-alpha-里是什么样的">$\operatorname{Coker} \alpha$ 里是什么样的
&lt;/h4>&lt;p>由于 $\Coker \alpha = A' / \Img \alpha$，其中的每个元素都应该是 $\Img \alpha$ 这种形式的陪集。&lt;/p>
&lt;p>我们先考察一般的阿贝尔群（交换群）里某个同态的余核是什么样的。对于一般的阿贝尔群 $A$ 以及其上的某个同态 $f\vcentcolon\\,A\to B$ 而言，这里的等价关系是这样定义的：若 $a,a^* \in A$ 且 $a - a^* \in \Img f$，则认为 $a \sim a^* $，即 $a$ 与 $a^* $ 等价。这里的减号应该与 $a^* $ 一起理解为 $a^* $ 的逆元。这就形同 $a^{-1}a^* $ 在一般的乘法群中判定元素是否等价时一样。&lt;/p>
&lt;p>与此同时，其他的等价类（陪集），按照加法记号，也应该可以写作这样的形式：$a+\Img \alpha$。（假如你没有点开哪些小箭头的话）我们使用代表元的记号来记录这个陪集，即 $\hat{a} = a+\Img \alpha$。我们在余核中定义的运算，则是借助余核所在的群的运算所定义的：直接将代表元按照原群中的运算进行，最后给它带上帽子（找到对应的等价类）。写成符号形式则是：假设有同态 $f: A\to B$，则这个同态的余核为 $\Coker f = A/\Img f \subseteq A$，再设余核这个群中有两个元素 $\hat{a}$ 与 $\hat{a^* }$，则余核中的运算为：$\hat{a}+_\mathrm{Coker}\hat{a^* } = \widehat{a+_A a^* }$。&lt;/p>
&lt;p>现在一切都明了了。对于我们所要研究的问题而言，$\Coker \alpha$ 中的元素，就是一个个等价类，这些等价类用原群的元素作为代表元进行标记，如 $\hat{0}$, $\hat{a'}$ 这样。而其运算直接继承自群 $A'$，具体而言，只需要将用来与子群作用的元素相运算，最后再作用回子群即可。&lt;/p>
&lt;h4 id="hatf-是什么样的">$\hat{f'}$ 是什么样的
&lt;/h4>&lt;p>从交换图上可以看到，$\hat{f'}$ 是从 $\Coker \alpha$ 到 $\Coker \beta$ 上的。而在 $\Coker \alpha$ 中的元素则是众多的以代表元所代表的等价类。那么，在使用 $\hat{f'}$ 作用到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$ 后，得到的则应该是位于 $\Coker \beta$ 中的一个元素，这个元素应该是形如 $b'+\Img \beta$ 这样的等价类，自然也可以被表示为 $\hat{b'}$。这就是我们需要验证的同态，$\hat{f'}$，具体在做的事。&lt;/p>
&lt;p>让我们写的更加明确一些：我们要定义的 $\hat{f'}$ 应该是这样的：&lt;/p>
$$\begin{align*}
\hat{f'}\vcentcolon\space \Coker \alpha &amp; \to \Coker \beta \\
a' + \Img \alpha &amp; \mapsto b' + \Img \beta,
\end{align*}$$&lt;p>其中 $a'\in A'$ 与 $b' \in B'$ 之间的关系有：$f'(a') = b'$。&lt;/p>
&lt;p>那么就有值得注意的一些问题。两个元素等价时，它们自然属于同一个等价类，但这两个元素本身是可以不同的。假如两个不同但等价的元素在进入等价类后再被商群间的同态所映射，应该会得到一个目标群上的等价类。另外，自然，我们也要验证这个同态的像确实在陪域内。我们开始验证吧。&lt;/p>
&lt;h4 id="开始验证">开始验证
&lt;/h4>&lt;p>我们取 $\Coker \alpha$ 中的一个元素 $\hat{a}$，这个元素是一个等价类，等价关系由 $a' - a'^* \in \Img \alpha \hArr a' \sim a'^* $ 给出。此时我们就取这个等价类中的这两个元素 $a',\\, a'^* \in A'$。那么，此时这两个元素在经过 $f'$ 作用后得到的就是 $f' (a')$ 以及 $f'(a'^* )$。这两个 $B'$ 中的元素应该依旧会被映射到同一个等价类中，也就是两个元素等价。判断两元素等价的条件则类似于前面的判断条件：$f' (a') - f'(a'^* ) \in \Img \beta$。我们可以看到：由于 $f'$ 是一个同态，同态是保运算的，则 $f' (a') - f'(a'^* ) = f'(a' - a'^* )$。注意到 $a' - a'^* \in \Img \alpha$，由像的性质，我们就一定可以找到一个存在于 $A$ 中的一个元素 $a$，使得 $\alpha(a) = a' - a'^* $。&lt;/p>
&lt;p>我们理一下思路：我们先选取了两个在 $A'$ 中等价的元素；这两个元素的差，根据等价类划分的规则，必须是属于 $\alpha$ 的像的，那么就一定有一个对应的 $A$ 中的元素 $a$ 在 $\alpha$ 的作用下等于这两个 $A'$ 中元素的差。那么这时，我们就可以使用图表交换的性质了：$f'(\alpha(a)) = \beta(f(a))$。请注意这个地方：右侧显示 $\beta(f(a))$ 是属于 $\beta$ 的像的：$\beta(f(a)) \in \Img \beta$。这就说明了 $f'(\alpha(a)) = f'(a' - a'^* ) \in \Img \beta$。这样，我们就得到了我们所需要的：任取两个 $A'$ 中的等价元素，它们最终被映入了 $B'$ 的等价类，因为 $f' (a') - f'(a'^* ) \in \Img \beta$。&lt;/p>
&lt;p>那么这样我们就可以进一步进入到对 $\hat{f'}$ 的验证：如果 $a'\in A'$ 且 $a'^* \in A'$ 且二者等价，就有 $a' + \Img \alpha = a'^* + \Img \alpha$。我们希望这两个应该相等的等价类在经过 $\hat{f'}$ 的映射后得到的是同一个 $\Coker \beta$ 中的元素。那我们就直接进行运算：&lt;/p>
$$\begin{align*}
\hat{f'}(a' + \Img \alpha) &amp;= f'(a') + \Img \beta\\
&amp;= f' (a'^* +a'-a'^* ) + \Img \beta\\
&amp;= f' (a'^* ) + f'(a'-a'^* ) + \Img \beta \\
&amp;= f' (a'^* )+ \Img \beta\\
&amp;= \hat{f'}(a'^* + \Img \alpha).
\end{align*}$$&lt;p>我们来解释一下上面的运算过程。第一步是使用了我们上面对函数做出的定义；第二步就是单纯地进行了个加减，不过这里的加减能成立必须利用交换群的性质；第三步则是利用了 $f'$ 作为阿贝尔群同态的定义；第四步则要应用到我们刚刚得到的结论： $f' (a') - f'(a'^* ) \in \Img \beta$；第五步则就是单纯运算回以 $\hat{f'}$ 表达的形式，完成我们的证明。&lt;/p>
&lt;p>自此，我们证明了：两个任意的 $A'$ 中元素，当它们等价时，会且总是会被 $\hat{f'}$ 映射到同一个 $\Img \beta$ 中的元素。这句话还可以换个说法：我们定义的这个同态，是不依赖于等价类代表元的选取的（我们选了两个代表元，结果一样）；或者简单一些：这个同态是良定的。&lt;/p>
&lt;p>我们完全可以按照相似的逻辑处理 $\hat{g'}$。这得益于我们上面的定义以及验证没有用到除了交换图提供的信息外的任何额外附加信息。所以我们就不特别定义并验证这个 $\hat{g'}$ 了，直接借用这里的定义以及验证方法即可。&lt;/p>
&lt;details>&lt;summary>如何验证一个同态是良定的&lt;/summary>
&lt;p>在代数学中，我们常常会尝试给某个数学对象附上一个同态，或者给两个数学对象之间定义同态。然而，这样的过程并不总是顺利的：可能我们定义的东西到实际验证时是有问题的。就我个人的观点而言，这些问题包括但不限于：&lt;/p>
&lt;ul>
&lt;li>定义域上同一个元素被映射到了不同的陪域中的元素（违反映射的定义）；&lt;/li>
&lt;li>不保持对象间的结构（不保运算，不保连续等）；&lt;/li>
&lt;li>定义域不对，超出或小于定义域；&lt;/li>
&lt;li>超过了陪域的范围，&lt;/li>
&lt;/ul>
&lt;p>等等。而我们所说的验证一个同态是良定的，实际上就是在尝试验证上面的这些问题都不会出现。一般而言，后两个问题都不太容易出现，一般的验证过程都是在验证前两个问题是否存在。&lt;/p>
&lt;p>我们先看第一个，这个的验证方法非常地朴实无华，即通过验证两个定义域上相等的元素，它们在经过同态作用之后是否依旧相等。如果是保持相等的，则证明一个元素不会被映射到两个不同的元素上，从而完成第一个问题的验证。这里要提到的是，对于商群这样，元素是陪集这样集合的情况，还有必要验证一个陪集内的元素是否能被从商群出发的同态映射到定义域上的同一个元素中。不过这一点也可以归结为对第二个问题的验证，即同态是否能够保持对象间的结构。&lt;/p>
&lt;p>针对商群这样的结构，如果一个陪集内的元素被映射到了不同的定义域上的元素，那么就证明这样的映射并不能保持商群的元素，即陪集，内部所有元素等价的条件。除了这样的结构性质外，另一个常见的结构即定义好的代数运算，或者说是同态区别于函数的性质。我们也可以说，先对元素做运算再通过同态映射，其结果应该等同于先做完同态的映射，再在陪域内进行运算。这也许可以被称为同态和运算之间的 “交换性”。&lt;/p>
&lt;p>虽然第三和第四个问题一般不会出现，但是在从零开始构造一个同态时，对它们的验证依旧是有必要的。特别是第四条，即对于陪域的验证，我们要求同态的像必须是陪域的子集，否则这个映射就不是良定义的。从上面的一系列验证过程中，我们也能够看到对于这一条件的验证。&lt;/p>
&lt;/details>
&lt;h3 id="delta-的定义与验证">$\delta$ 的定义与验证
&lt;/h3>&lt;p>这个 $\delta$ 的定义算是证明蛇引理过程中的一个难点吧，这也是蛇引理的关键一步，也是 “蛇” 这个字的由来吧。我们应该如何从一个核映射到余核呢？从交换图上来看，是需要从 $C$ 中的子集映射到 $A'$ 上的等价类的。这应该如何是好呢？&lt;/p>
&lt;h4 id="delta-应该是什么样的">$\delta$ 应该是什么样的
&lt;/h4>&lt;p>好消息是：我们对同态 $g$ 以及 $f'$ 是有一些说法的：$g$ 一定是满态，而 $f'$ 则一定是单态。这是根据这两个正合列的性质，或者说是正合列中 $C$ 点与 $A'$ 点的性质而得到的。我们前面也有提到这个结论，这里简单说明一下：由于 $C$ 映射到平凡群的同态一定是一个满态，这个满态的核就一定是 $C$ 本身；由于正合的要求，$g$ 的像就必须是 $C$ 了，也就是 $g$ 是满的；由于 $0$ 到 $A'$ 作为同态必须也只能映射到 $A'$ 中的单位元，所以这个映射的像就只能是那个单位元自己形成的平凡群；由于正合列的性质，$f'$ 的核则只能是这个平凡群，也就是说它是一个单态。&lt;/p>
&lt;p>这两个信息对于 $\delta$ 的构造是必须的，否则我们没有一个很好的从 $C$ 一路走回 $A'$ 的方法。当然，有了上面的提示，我们很自然想到，这个 $\delta$ 的构造应该是什么样的。它会从 $C$ 出发，从 $g$ 反着走到 $B$ 点，在经过 $\beta$ 的映射之后，再通过 $f'$ 反过来到 $A'$ 上。我们来更细致地考察这个映射构造过程的每一步吧。&lt;/p>
&lt;h4 id="delta-的具体构造">$\delta$ 的具体构造
&lt;/h4>&lt;p>我们的 $\delta$ 是从 $\Ker \gamma$ 开始的，自然我们就取 $C$ 中的子集 $\Ker \gamma$ 里的一个元素 $c$。得益于满态的性质，我们一定是可以在 $B$ 中找到某个元素 $b$，使得 $g(b) = c$ 的。&lt;/p>
&lt;p>注意到我们对 $c$ 的选取，这个 $c$ 是在 $\Ker \gamma$ 内的，所以就会有： $\gamma(g(b)) = 0$。再根据图的交换性，我们就有了 $g'(\beta(b)) = \gamma(g(b)) = 0$，也就是说 $\beta(b) \in \Ker g'$。&lt;/p>
&lt;p>这时我们要根据正合列的性质来继续向 $A'$ 推进。由于正合性，我们有 $\Img f' = \Ker g'$，因此 $\beta(b) \in \Img f'$，而既然 $\beta(b)$ 出现在了 $f'$ 的像中，就一定会有一个 $A'$ 中的元素，我们记作 $a'$，一定会在 $f'$ 映射后到我们之前拿到的 $\beta(b)$ 上。&lt;/p>
&lt;p>最后，由于 $f'$ 是单态，上面说的那个 $a'$ 在此时是唯一确定的。而这个唯一确定的元素在 $A'$ 对应的商群 $\Coker \alpha$ 中自然也是属于唯一的一个等价类的。&lt;/p>
&lt;p>我们现在回溯一下这个过程：我们取了 $\Ker \gamma$ 中的一个元素 $c$，它一定对应了某个 $B$ 中的 $b$。但要注意的是，因为仅有 $g$ 是满态的要求，这个 $b$ 可能不唯一。接着我们从这个 $b$ 自然地得到了 $\beta(b)$，而它则有 $A'$ 中存在且唯一的对应元素 $a'$。这个元素，很自然地，在 $\Coker \alpha$ 中就有了唯一的等价类。总结下来就是：每个 $\Ker \gamma$ 中的元素经过我们上面的映射过程，都是可以得到 $\Coker \alpha$ 中的等价类的。&lt;/p>
&lt;p>然而这给了我们一个亟待解决的问题：这个映射链最后是需要组合成一个同态 $\delta\vcentcolon\\,\Ker \gamma \to \Coker \gamma$ 的，而作为一个同态，每个定义域上的元素能且只能对应到陪域上的唯一一个元素。然而从我们刚刚的映射链过程来看，由于 $c$ 在 $B$ 中对应的元素个数是不确定的，虽然每个 $b$ 中元素都能对应到唯一的 $A'$ 中的等价类，但可能所有满足 $g(b) = c$ 的 $b$ 所能对应的 $A'$ 的等价类是不一样的。用更形式化的语言来讲，我们现在要解决，或者要证明的问题就是：&lt;/p>
&lt;blockquote>
&lt;p>设存在两个 $B$ 中的元素 $b,\\,b^* $，满足 $g(b) = g(b^* )$，求证这两个元素在经过映射链 $\beta$ 与 $f'$ 的反向作用（我们以后就记这个反向作用为 $(f')^{-1}$ 了，这个记号是合理的，我们后面会提到） 后得到的元素在 $A'$ 中是等价的，其中等价关系由 $a' - a'^* \in \Img \alpha$ 给出。&lt;/p>&lt;/blockquote>
&lt;p>如果这个命题得到了验证，那么就说明这条路走得通，一个唯一的 $\Ker \gamma$ 中的 $c$，不论它在 $B$ 中对应有多少个元素，最后都会在 $A'$ 里对应到同一个等价类里，也就是在 $\Coker \alpha = A'/\Img \alpha$ 中有唯一的一个元素与之对应。这样就验证了 $\delta$ 的定义。&lt;/p>
&lt;h4 id="delta-构造的验证">$\delta$ 构造的验证
&lt;/h4>&lt;p>我们开始上面这个命题的证明吧。这里需要注意的第一个问题，同时也是指明了我们应该朝着哪个方向前进的信息，是：我们最后要得到的内容是和 $\Img \alpha$ 有关的。为此，我们一定是要用到 $\alpha$ 这个映射的相关信息的，而这也不可避免地涉及到 $A$ 这个群。因此，我们得想办法先把 $g(b) = g(b^* )$ 这个信息反映到 $A$ 这个群内。&lt;/p>
&lt;p>好消息是，通过同态的性质，我们很容易就可以得到：$g(b-b^* ) = 0$，也就是说 $b-b^* \in \Ker g$。我们故技重施，得到 $b-b^* \in \Img f$，这让我们可以讨论已有的 $g(b)$，$g(b^* )$ 与 $A$ 中的元素的关系，即我们一定可以找到至少一个 $A$ 中的元素 $a$，使得 $f(a) = b-b^* $。&lt;/p>
&lt;p>我们通过图的交换性可以得知，$\beta f (a) = \beta (b-b^* ) = f'\alpha(a)$。这时我们需要用到关于单态的一个性质。这个性质我们之前也提过，甚至这是关于单态的定义：&lt;em>具有左逆的态射为单态&lt;/em>。如此一来，我们给第二个等号的左右两边同时作用上 $f'$ 的左逆。注意到左逆的定义，我们就有了：&lt;/p>
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} f'\alpha(a) = \alpha(a)$$&lt;p>回忆我们之前所提到的，$(f')^{-1}$ 由于 $f'$ 是单态，所以能唯一地确定 $B'$ 中元素在 $A'$ 中所对应的元素；$\beta$ 本身就是一个良定的同态，因此，以上这些就说明了这样一个事实：$(f')^{-1} \beta$ 是一个良定的从 $B$ 到 $A'$ 的同态，且 $(f')^{-1} \beta (b-b^* )$ 作为 $A'$ 的元素，它同时也是位于 $\Img \alpha$ 的。&lt;/p>
&lt;p>那么此时我们再使用 $(f')^{-1} \beta$ 作为同态的性质，有：&lt;/p>
$$(f')^{-1} \beta (b-b^* ) = (f')^{-1} \beta (b)-(f')^{-1} \beta(b^* ) \in \Img \alpha$$&lt;p>至此，我们对上面进行总结：设有两个 $B$ 中的元素 $b$ 与 $b^* $，它们满足 $g(b) = g(b^* )$，则我们可以在 $A'$ 中找到这样对应的两个元素 $(f')^{-1} \beta (b)$ 和 $(f')^{-1} \beta (b^* )$，使得这两个元素在我们已经定义好的等价关系下是等价的。&lt;/p>
&lt;p>如此，我们的这个命题得证。进而，我们就成功地构造出了良定的 $\delta$：&lt;/p>
$$
\begin{align*}
\delta\vcentcolon\space\Ker\gamma&amp;\to\Coker\alpha\\
c&amp;\mapsto (f')^{-1} \beta (b) + \Img\alpha,
\end{align*}
$$&lt;p>其中，$c \in \Ker \gamma$ 且 $c = g(b)$。&lt;/p>
&lt;h4 id="一些旁注">一些旁注
&lt;/h4>&lt;p>我们可以看到，为了构造 $\delta$，我们必须利用 $g$ 的满态性质以及 $f'$ 的单态性质，还需要利用交换图右侧部分的交换性。而在验证其定义的过程中，我们同样必须利用 $g$ 的满态性质以及 $f'$ 的单态性质（这里 $g$ 的满态性是直接作为命题的前置条件而存在的），然后还需要利用交换图左侧部分的交换性。$\delta$ 的构造充分利用了我们已有的所有条件，因此算是这个引理证明比较困难的一部分，同时也是关键的部分。而关于前面 $f|$，$\hat{f'}$ 的构造与验证过程中，都只用到了图的交换性，并没有利用 $g$ 是满态以及 $f'$ 是单态的条件。&lt;/p>
&lt;p>我们再来关注 $\delta$ 的构造过程。我们从 $\Ker \gamma$ 中选择了任意的元素 $c$，它在 $g$ 的诸多原像 $b$ 们由于交换图的交换性质，在经过 $\beta$ 的映射到达 $B'$ 后都是位于 $\Img f'$ 上的。由于都在 $\Img f'$ 上，讨论 $(f')^{-1}$ 自然也是有意义的。&lt;/p>
&lt;p>另外我们结合后面对该定义的验证过程，可以看到这个元素 $c$ 是怎么一步步抵达 $\Coker \alpha$ 的：这个元素 $c$ 在 $B$ 中的原像可能包含一个或者多个元素，这些元素经过 $\beta$ 映射后都存在于 $\Img f'$ 中，这个过程里可能有些元素映射到了 $B'$ 里的同一个元素上，也有可能并不是这样，不过这里没有关系。接着它们在单射 $(f')^{-1}$ 的影响下，各不相同地映射到 $A'$ 上，最后分类到同一个等价类中（纯符号地讲，其实就是加上了 $\Img \alpha$）。&lt;/p>
&lt;p>验证过程说明了，只要都是在 $c\in\Ker\gamma$ 的原像里，注定都是会被分到同一个 $\Coker\alpha$ 的等价类里面的。然而，这个分类过程其实是在最后，在得到 $(f')^{-1}\beta(b)$ 后才完成的。好在，由于左侧块的交换性，在从 $c$ 找 $B$ 中原像的过程中，所有符合条件的 $b$ 之间的等价关系（指最终分类到同一 $\Coker \alpha$ 的元素中）早已被确定好了。&lt;/p>
&lt;p>这里再重申一下单态和满态的性质。单态意味着若陪域中的元素的原像要么非空，要么则只有一个元素，同时单态拥有唯一的左逆；满态则意味着陪域中的所有元素的原像都不是空集。我们利用满态原像的性质得出，$\Ker \gamma$ 中的元素一定可以在 $B$ 中找到对应元素，而又通过单态的性质得出，在已知 $\beta(b)$ 存在于 $f'^* $ 的条件下，$A'$ 中有且只有唯一一个元素与之对应，且通过给 $\beta (b-b^* )$ 作用左逆得出它存在于 $\alpha$ 的像内。&lt;/p>
&lt;h3 id="operatornameker-beta-处正合性的证明">$\operatorname{Ker} \beta$ 处正合性的证明
&lt;/h3>&lt;p>前面我们证明了我们要验证的点的 1-5，借此我们成功地将这些核呀余核呀之类的连起来了。然而，要成为正合列，它需要在中间的每个点上都是正合的。现在已经到手的链条是这样的：&lt;/p>
$$\Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma \xrightarrow{\delta}\Coker \alpha \xrightarrow{\hat{f'}}\Coker \beta\xrightarrow{\hat{g'}} \Coker \gamma $$&lt;p>这条链条的中间一共有 $\Ker\beta$，$\Ker\gamma$，$\Coker\alpha$，$\Coker\beta$ 四个点，我们需要分别验证它们两边的态射在它们自身处都是正合的。鉴于 $\delta$ 所连接的 $\Ker\gamma$，$\Coker\alpha$ 处的正合性会比较复杂（由于 $\delta$ 比较复杂），我们先验证 $\Ker \beta$ 处的正合性，再验证 $\Coker \beta$ 的，最后到剩下的两个。&lt;/p>
&lt;p>为了验证正合性，我们需要验证：$\Img f| = \Ker g|$。由于链条上的都是态射，这个等号只需要集合意义上的成立即可在阿贝尔群意义上同样成立，而证明两个集合相等最常用的方法之一便是验证相互包含：$\Img f| \subseteq \Ker g|$ 且 $\Img f| \supseteq \Ker g|$，而为了实现这样的目的，我们会从待验证命题中较小的集合中取点，证明它一定在较大的那个集合中，即可验证这样的子集关系了。&lt;/p>
&lt;p>在我们开始之前，我们把 $\Ker \beta$ 所在短链条写出来，方便后面观察：&lt;/p>
$$ \Ker \alpha \xrightarrow{f|} \Ker \beta \xrightarrow{g|} \Ker \gamma $$&lt;p>那我们就开始吧，先从 $\Img f| \subseteq \Ker g|$ 开始。&lt;/p>
&lt;h4 id="证明-operatornameim-f-subseteq-operatornameker-g">证明 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$
&lt;/h4>&lt;p>我们就取 $\Img f|$ 中的一个元素 $b$，根据像的性质，一定有一个 $a\in \Ker\alpha$ 满足 $f|(a) = b$。而 $f|(a)$ 实际上就是 $f$ 在 $\Ker \alpha$ 上的一个限制，所以也就有 $f(a) = b$；同时，我们取 $g|(b) = c$，由于 $g|$ 也是 $g$ 在 $\Ker\beta$ 上的限制，所以 $g|(b) = g|(f(a)) = g(b) = g(f(a)) = c$。此时，我们考虑原正合列：&lt;/p>
$$A\xrightarrow{f} B \xrightarrow{g} C,$$&lt;p>
我们得到：$f(g(a)) = 0$。由此就得到了 $c = 0$。由于这个结论不依赖于 $b$ 的选取方式，我们就以这种方式得到了 $g|(b) = c = 0$ 恒成立，进而 $b \in \Ker g|$。而这，正说明了这样一件事：如果一个 $\Ker \beta$ 中的元素 $b$ 在 $\Img f|$ 里，那么它就一定在 $\Ker g|$ 中。这就证明了 $\operatorname{Im} f| \subseteq \operatorname{Ker} g|$。&lt;/p>
&lt;p>这个命题的得证完全依赖与原正合列的性质，且通过证明该命题，我们得知上面的短链条已经是一个链复型了。下面我们需要证明的就是另一个方向的包含性，也就是：&lt;/p>
&lt;h4 id="证明-operatornameim-f-supseteq-operatornameker-g">证明 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$
&lt;/h4>&lt;p>我们故伎重施，取 $\Ker g|$ 中的一个元素，也叫它 $b$ 好了。既然它在 $g|$ 的核中，那么就有 $g|(b) = 0$，我们此时把 $b$ 放到 $B$ 集合中，此时 $g|(b) = g(b) =0$，说明 $b\in\Ker g$。而根据原链条的正合性，我们有 $\Ker g = \Img f$，因此 $b\in\Img f$。&lt;/p>
&lt;p>然而到此依然不能证明 $b\in\Img f|$，因为 $\Img f|$ 是 $\Img f$ 的子集，无法从一个元素位于更大的集合中来判定它一定在更小的集合里。我们需要更多的信息。然而既然 $b\in\Img f$，我们就可以找到 $A$ 中的一个元素 $a$，使得 $f(a) = b$。又因为根据 $b$ 的取法，它在 $g|$ 的定义域 $\Ker \beta$ 上，一定就有 $\beta(b) = \beta(f(a)) = 0$。此时，我们根据交换图的性质，可以得到 $f'(\alpha(a)) = \beta(f(a)) = 0$。&lt;/p>
&lt;p>这样的结果有什么用处呢？回忆 $f'$ 的性质，它是一个单态，因此就一定有左逆 $(f')^{-1}$。我们给上式的左右两边同时左乘（左作用）上 $(f')^{-1}$，就得到：$(f')^{-1}f'(\alpha(a)) = (f')^{-1}(0) = 0 = \alpha(a)$。观察最后一个等号，这又说明了 $a \in \Ker \alpha$。&lt;/p>
&lt;p>我们整理一下当前得到的信息，我们有 $\Ker g|$ 中的一个元素 $b$，它在 $A$ 中有一个对应的元素 $a$，我们又得到了这个元素 $a\in\Ker\alpha$。请注意 $f|$ 的定义域正是 $\Ker\alpha$。这就说明了：$b$ 在 $A$ 中对应的元素一定也在 $\Ker\alpha$ 里，也就是 $b\in\Img f|$。同样，由于 $b$ 的选取不依赖于任何的额外条件，我们就证明了 $\operatorname{Im} f| \supseteq \operatorname{Ker} g|$。至此，联合上一小节的结论，我们得出结论：该短链在 $\Ker\beta$ 处正合。&lt;/p>
&lt;h4 id="一点注解">一点注解
&lt;/h4>&lt;p>可以看到，前半部分的证明非常简单，直接借助原正合列性质即可，这样直接就证明了这个链条是一个链复型；而后面为了证明正合性的部分则需要使用到 $f'$ 是单态的条件。也许我们在证明 $\Coker \beta$ 处的正合性时，也会遇到这样的特点？我们直接开始吧。&lt;/p>
&lt;h3 id="operatornamecoker-beta-处正合性的证明">$\operatorname{Coker} \beta$ 处正合性的证明
&lt;/h3>&lt;p>和上面一样，我们证明这样的正合性，会以对应映射的像与核相互包含为切入点进行。这次我们还是先证明这个短链：&lt;/p>
$$
\Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta \xrightarrow{\hat{g'}} \Coker \gamma
$$&lt;p>是一个链复型（$\Img \hat{f'} \subseteq \Ker \hat{g'}$），再证明在中间的 $\Coker \beta$ 处是正合的（$\Img \hat{f'} \supseteq \Ker \hat{g'}$）。&lt;/p>
&lt;h4 id="证明-operatornameim-hatf-subseteq-operatornameker-hatg">证明 $\operatorname{Im} \hat{f'} \subseteq \operatorname{Ker} \hat{g'}$
&lt;/h4>&lt;p>照旧我们选择 $\Img \hat{f'}$ 中的一个元素，由于 $\Img \hat{f'} \subseteq \Coker \beta$，这个元素将会是等价类 $\hat{b'} = b' + \Img \beta$。我们想要证明，在前面这个条件下的任何 $\hat{b'}$ 都会被 $\hat{g'}$ 映射到 $\hat{0} \in \Coker \gamma$ 上。既然 $\hat{b'}\in\Img\hat{f'}$，我们就可以取到 $\Coker \alpha$ 中的一个元素 $\hat{a'}$，使得 $\hat{f'}(\hat{a'}) = \hat{b'}$。&lt;/p>
&lt;p>此时，请回忆我们是如何定义 $\hat{f'}$ 的：我们直接借助了原有的同态 $f'$，使得具有了这样的性质：&lt;/p>
$$\hat{f'}(\hat{a'}) = \hat{f'}(a'+\Img \alpha) = f'(a') + \Img \beta = b'+\Img \beta = \hat{b'} = \widehat{f'(a)}.$$&lt;p>带着这条性质，我们观察到：若是对 $\hat{b'}$ 作用上 $\hat{g'}$，就有：&lt;/p>
$$\hat{g'}(\hat{b'}) = \hat{g'}(\hat{f'}(\hat{a'})) = \hat{g'}(\widehat{f'(a')}) = \widehat{g'(f'(a'))} = \hat{0},$$&lt;p>其中，第一个等式是我们一开始取到的 $\hat{f'}(\hat{a'}) = \hat{b'}$，第二个等式是利用了我们上面给出的 $\hat{f'}$ 的性质，而第三个等式则是同样，再次利用 $\hat{g'}$ 它与 $\hat{f'}$ 同样的性质（因为定义是类似的）。最后，第四个等式则利用了原正合列的性质，有 $g'(f'(a')) = 0$。由此，我们再一次地，像上面证明 $\Ker \beta$ 处正合的第一部分一样，证明了 $\Coker \beta$ 处正合的第一部分：无论 $\hat{b}$ 如何取，只要它位于 $\Img \hat{f'}$ 中，就一定位于 $\Ker \hat{g'}$ 中。&lt;/p>
&lt;h4 id="证明-operatornameim-hatf-supseteq-operatornameker-hatg">证明 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$
&lt;/h4>&lt;p>下来我们就证明 $\Coker \beta$ 处正合的第二部分。我们希望能从 $\Ker \hat{g'}$ 中取到的元素能够以某种方式放到 $B'$ 中去，然后借助原正合列的性质去取得在 $A'$ 中或者 $\Coker \alpha$ 中的一些结论。 因此依旧，我们取 $\hat{b'} \in \Ker \hat{g'} \subseteq \Coker \beta$。由于 $\hat{b'}$ 在 $\hat{g'}$ 的核中，我们有 $\hat{g'}(\hat{b'}) = \hat{0}$。我们把这个运算拆开，有&lt;/p>
$$\begin{align*}
\hat{g'}(\hat{b'}) &amp;= \hat{g'}(b' + \Img \beta) \\
&amp;= g'(b') + \Img \gamma\\
&amp;= \hat{0} = \Img \gamma,
\end{align*}$$&lt;p>
由此可以得知，$g'(b') \in \Img \gamma$。然而，这和我们之前所做到的并不一样：$g'(b')$ 只是位于 $\Img \gamma$ 中，它并不等于 $0$。不过，我们依旧可以借助这个条件。&lt;/p>
&lt;p>从 $g'(b') \in \Img \gamma$ 条件中可以得知，一定有一个 $c \in C$ 使得 $\gamma(c) = g'(b')$。而此时，又由于 $g$ 是满射，我们知道一定有一个 $b \in B$ 使得 $g(b) = c$。把它们组合起来，就有了： $\gamma(g(b)) = g'(b')$，此时根据交换图的性质，就有了 $g'(b') = \gamma(c) = g'(\beta(b))$。我们现在把最右边这项移项到最左边，就有了 $g'(b'-\beta(b)) = 0$。&lt;/p>
&lt;p>通过上面的方式，我们成功构造出了一个位于 $g'$ 的核中的元素。因此，直接借助短链&lt;/p>
$$A'\xrightarrow{f'} B' \xrightarrow{g'} C'$$&lt;p>是正合的这一条件，就有：$b'-\beta(b) \in \Ker g' = \Img f'$。&lt;/p>
&lt;p>我们现在再看看这个新构造出的，位于 $\Img f'$ 中的这个元素的等价类是什么样的。我们把 $\hat{b'}$ 写成 $b' + \Img \beta$ 的形式，此时又由于 $\beta(b)$ 自然就在 $\Img \beta$ 中： $\beta(b) \in \Img \beta$，我们就有 $b'+\Img \beta = b' - \beta(b) + \Img \beta$。这意味这我们新构造出的这个更好的元素，它与我们一开始选择的 $b'$ 是等价的，都可以作为 $\hat{b'}$ 的代表元。&lt;/p>
&lt;p>现在我们现在想知道的是，对于等价类 $\hat{b'} = b'-\beta(b) + \Img \beta$，是否一定存在 $\Coker \alpha$ 中的某个等价类，使得它在 $\hat{f'}$ 的作用下就是我们已有的 $\hat{b'}$。为此，我们回到刚刚构造出的，位于 $\Img f'$ 中的这个元素 $b'-\beta(b)$。既然在 $f'$ 的像内，就一定有一个或者几个元素 $a' $ 满足 $f'(a' ) = b'-\beta(b)$。我们知道，$a'$ 在 $A'$ 中的等价类是 $\hat{a'} = a'+\Img \alpha$。而该等价类经过 $\hat{f'}$ 的作用后得到的结果是：&lt;/p>
$$
\hat{f'}(a'+\Img\alpha) = f'(a') + \Img\beta = b'-\beta(b) + \Img\beta = b'+\Img\beta.
$$&lt;p>好，我们现在总结我们已有的信息。我们从一个任意的 $\Coker \beta$ 中的元素 $\hat{b'}$ 出发，构建出了一个位于 $\Ker g'$ 中的元素 $b'-\beta(b)$，其中 $b$ 是直接根据 $b'$ 确定的。这个新的元素所处的等价类就是我们之前挑选的等价类。另外，我们从构造的元素出发，得到了若干个位于 $A'$ 中的元素 $a'$。它所在的等价类则是 $\hat{a'}\in\Coker \alpha$。现在，我们可以注意到：我们只挑出来了一个 $\hat{b'}$，剩下的所有的东西都是由它以及它相关的量决定的。也就是说，$\hat{b'}$ 决定了这些 $\hat{a'}$。而经过上面式子的验证，有 $\hat{f'}(\hat{a'}) = \hat{b'}$。这就说明了：任取一个位于 $\hat{g'}$ 的核内的元素，我们都能确定出一些 $\hat{a'}$，它们全都是满足 $\hat{f'}(\hat{a'}) = \hat{b'}$ 的。&lt;/p>
&lt;p>这就证明了我们想要的结论：任意一个 $\hat{g'}$ 的核内的元素都是 $\Coker \alpha$ 中元素的像，也就是 $\operatorname{Im} \hat{f'} \supseteq \operatorname{Ker} \hat{g'}$。再结合上一节证明的内容，我们就证明了这个链条在 $\operatorname{Coker} \beta$ 处是正合的。&lt;/p>
&lt;h4 id="callback">Callback
&lt;/h4>&lt;p>可以看到，对于 $\operatorname{Coker} \beta$ 处正合性的证明，是和 $\operatorname{Ker} \beta$ 处正合性的证明很类似的。不过我个人感觉，后面证明的这个，相比于 $\operatorname{Ker} \beta$ 处正合性的证明是要难一些的。这可能是因为需要手动构造一个 $b'-\beta(b)$ 来满足应用正合性的条件，以及对余核的性质的不熟悉吧。总之，顺利地证明了。而下面要证明的，就和我们自己构造出的 $\delta$ 相关了。&lt;/p>
&lt;h3 id="operatornameker-gamma-处正合性的证明">$\operatorname{Ker} \gamma$ 处正合性的证明
&lt;/h3>&lt;p>接下来我们尝试证明短链&lt;/p>
$$\Ker\beta\xrightarrow{g|}\Ker\gamma\xrightarrow{\delta}\Coker\alpha $$&lt;p>在中间一点处的正合性。我们依旧采取原来的策略。&lt;/p>
&lt;h4 id="证明-operatornameim-g-subseteq-operatornameker-delta">证明 $\operatorname{Im} g| \subseteq \operatorname{Ker} \delta$
&lt;/h4>&lt;p>照旧取一个 $\Img g|$ 中的元素 $c\in C$，我们希望能证明 $\delta(c) = \hat{0}$ 恒成立，这样一来自然就有 $\Img g| \subseteq \Ker \delta$ 了。&lt;/p>
&lt;p>既然 $c\in\Img g|$，就会有一个元素 $b\in \Ker\beta$ 使得 $g|(b) = c$。又由于这个 $b$ 是在 $\beta$ 的核中的，因此 $\beta(b) = 0$。此时我们再作用上 $(f')^{-1}$，由于 $f'$ 是单态，所以把 $0\in B'$ 作用上它的左逆只能得到唯一的元素 $0\in A'$，而这对应的 $\Coker \alpha$ 中作为元素等价类正是 $\hat{0}$。&lt;/p>
&lt;p>注意到我们上面的步骤，实际上就是在对 $c$ 作用 $\delta$。因此，我们得到了我们想要的结论：$\delta(c) = \hat{0} \in \Coker \alpha$，也就证明了本命题。&lt;/p>
&lt;h4 id="证明-operatornameim-g-supseteq-operatornameker-delta">证明 $\operatorname{Im} g| \supseteq \operatorname{Ker} \delta$
&lt;/h4>&lt;p>我们还是取 $c\in \Ker \delta$。因此，$\delta(c) = \hat{0} = 0 + \Img \alpha$。我们回顾 $\delta$ 的构造，或者说从 $c\in\Ker\gamma$ 出发抵达 $\Coker \alpha$ 的过程，如果 $\delta(c) = \Img \alpha$，那么 $c$ 就一定会经理这样的过程：它首先在 $B$ 中找到原像中的元素 $b$ 们，然后把这些元素打包被 $\beta$ 映射到 $B'$ 上，此时由于我们的构造，所有的 $\beta(b) \in \Img f'$。此时就一定有许多对应的 $a' \in A'$ 满足 $f'(a') = \beta(b)$。最后由于 $\delta(c) = \hat{0} = \Img \alpha$，必须要有 $a' \in \Img\alpha$ （注意，不是 $a' = 0$，因为只需属于 $\Img \alpha$ 即可满足条件）。&lt;/p>
&lt;p>经过上面的过程，我们得到了这样和原条件等价的条件，即必须至少有一个 $a'\in\Img\alpha$，它由 $f'(a') = \beta(b)$ 确定，而 $\beta(b)$ 中的 $b$ 则从 $c$ 的原像中找到。&lt;/p>
&lt;p>因此，我们先关注这个集众多条件于一身的 $a'$，由于其处在 $\alpha$ 的像内，就一定有 $a\in A$ 使得 $\alpha(a) = a'$。此时我们从 $a$ 出发，利用交换图的性质，就有 $f'(\alpha(a)) = \beta(f(a))$。注意到我们 $a'$ 上的两个条件，将它们带入这个关系，就得到 $f'(\alpha(a)) = f'(a') = \beta(b) = \beta(f(a))$。&lt;/p>
&lt;p>我们关注最后一个等号，它说明了这样的问题：$\beta(b) = \beta(f(a))$，则有 $\beta(b-f(a)) = 0$，也就是 $b-f(a)$ 是属于 $\Ker \beta$ 的。回顾这个元素的构造过程，$b$ 是任意一个在 $c$ 的原像中的元素，这里的 $a$ 是根据 $a'$ 任意选取的在原像内的元素，$a'$ 又是 $\beta(b)$ 在其原像内任意选取的元素。我们看到，$b$ 和 $a$ 都是除了利用 $c\in\Ker\gamma$ 和交换图性质以外任意选取的符合条件的元素，如果对它作用 $g|$ 之后能够回到 $c$，就说明这样的一件事：$c$ 的原像内元素不管怎么选，总会以某些形式回到 $\Ker\beta$，进而映射到 $g|$ 的原像内。&lt;/p>
&lt;p>幸运的是，这很好验证：$g|(b-f(a)) = g(b-f(a)) = g(b) - g(f(a)) = g(b) = c$。第一个等号来自 $g|$ 的定义，当将之放入 $B$ 中考虑是就可以使用 $g$ 替代；第二个等号来自 $g$ 是同态的保运算性质；第三个等号来自链复型的要求；而最后一个等号就是我们一开始选取 $b$ 的方式。这正是说明了我们前面讲的：$c$ 原像中的 $b$，会以 $b-f(a)$（其中 $a$ 也是由 $c$ 间接决定的）的形式出现在 $\Ker\beta$ 里，最后被 $g|$ 映射回 $c$，而这就证明了任何一个 $\Ker\gamma$ 中的元素，其都是 $\Img g|$ 中的元素，也就证明了本命题。再结合上一条命题的证明，我们成功得到了这条链条在 $\Ker\gamma$ 上的正合性。&lt;/p>
&lt;h4 id="一点绕过的弯路">一点绕过的弯路
&lt;/h4>&lt;p>第二个命题的证明其实没有特别顺利。这主要是因为对 $\delta$ 构造的理解不够导致的，或者说太过希望 $\delta$ 有一个好的显式表达而造成的。在取到 $a' = \alpha(a)$ 的时候，我希望直接得到 $b$ 是一定属于 $\Ker\beta$ 的结论，虽然感觉上会有和之前类似的从 $b$ 出发构造的属于 $\Ker\beta$ 的元素一样的桥段，但由于依赖 $\delta$ 的显示表达，我卡在了 $(f')^{-1}$ 只是左逆而非右逆这一点上。因为如果按照我之前的思路，就一定要遇到 $f'((f')^{-1}(\beta(b)))$ 这样的元素。而由于 $(f')^{-1}$ 并非右逆，这个式子是无法约化到 $\beta(b)$ 上的。&lt;/p>
&lt;p>可以看到，最后解决这个问题的方法，是直接采用 $\delta$ 在构造过程中的表现，在从 $B'$ 至 $A'$ 的过程中选择使用 $\beta(b)$ 一定在 $f'$ 的像中的条件，从而绕过了这个问题。虽然说用形式化的思路，比如限定这里 $f'$ 的范围，从而让做出一些限定条件的 $f'$ 成为同构来解决这个问题，但这始终不是个很好的方案。&lt;/p>
&lt;p>另外，就是 $b$ 一定属于 $\Ker\beta$ 的错觉。实际上，$b$ 可以不在 $\Ker\beta$ 中，只需要 $b$ 和某个经过 $g|$ 映射后等于 $0$ 的东西结合之后位于 $\Ker\beta$ 即可。当然我们现在知道，这个东西就是从 $c$ 一路确定下来的 $f(a)$ 了。&lt;/p>
&lt;p>好了，我们开始准备证明蛇引理主体的最后一部分吧：$\Coker\alpha$ 处的正合性。&lt;/p>
&lt;h3 id="operatornamecoker-alpha-处正合性的证明">$\operatorname{Coker} \alpha$ 处正合性的证明。
&lt;/h3>&lt;p>我们不多废话，还是先证明 $\Img \delta \subseteq \Ker \hat{f'}$，后证明 $\Img \delta \supseteq \Ker \hat{f'}$。对应的短链是：&lt;/p>
$$\Ker \gamma \xrightarrow{\delta} \Coker \alpha \xrightarrow{\hat{f'}} \Coker \beta$$&lt;h4 id="证明-operatornameim-delta-subseteq-operatornameker-hatf">证明 $\operatorname{Im} \delta \subseteq \operatorname{Ker} \hat{f'}$
&lt;/h4>&lt;p>取 $\Img \delta$ 中的元素 $\hat{a'} \in \Coker\alpha$，通过证明 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$ 即可证明本命题。由于 $\hat{f'}$ 的定义，我们有 $\hat{f'}(\hat{a'}) = \widehat{f'(a')} = f'(a') + \Img \beta = 0 + \Img \beta$，也就是说只需要证明 $f'(a') \in \Img \beta$，我们就能证明本命题。由于 $\hat{a'}\in\Img\delta$，一定有一个 $\Ker\gamma$ 中的元素 $c$ 满足 $\delta(c) = \hat{a'}$。&lt;/p>
&lt;p>我们这时使用 $\delta$ 的定义：若 $\delta(c) = \hat{a'}$，就说明一定有一个 $b\in B$，这个 $b$ 在 $c$ 的原像中，而且 $\beta(b) = f'(a')$。啊，这不就是我们要的结论吗？既然 $f'(a') = \beta(b)$ 了，那自然 $f'(a')$ 就在 $\beta$ 的像里面了呀。就这样，我们证明了这个命题。&lt;/p>
&lt;h4 id="证明-operatornameim-delta-supseteq-operatornameker-hatf">证明 $\operatorname{Im} \delta \supseteq \operatorname{Ker} \hat{f'}$
&lt;/h4>&lt;p>还是一样，取 $\Ker \hat{f'}$ 中的元素 $\hat{a'} \in \Coker\alpha$。既然在 $\Ker\hat{f'}$ 里，我们就有 $\hat{f'}(\hat{a'}) = \hat{0} = \Img \beta \in \Coker\beta$（我们是不是刚刚见过这句，那就快进吧），进而 $f'(a') \in \Img \beta \subseteq B'$。那么，既然是在 $\Img \beta$ 中的，我们就取所有满足 $\beta(b) = f'(a')$ 的 $b\in B$。此时我们用交换图右侧的交换性，给这个式子左右两边左作用上 $g'$，就得到&lt;/p>
$$0 = g'(f'(a')) = g'(\beta(b)) = \gamma(g(b)),$$&lt;p>其中第一个等号来自交换图下面的链复型的性质，第二个等号就是作用 $g'$ 的结果，第三个等号则是交换图的性质。观察这个式子的左右两端，不难根据核的定义得到结论：只要是满足条件的 $b$，$g(b)$ 就全都在 $\Ker \gamma$ 中。&lt;/p>
&lt;p>到这里其实已经证明完了，因为我们仅从 $\hat{a'}\in\Ker\hat{f'}$ 出发，仅利用交换图就得到了所有满足条件的 $b$，证明了它们全都会在 $g$ 的作用下进入到 $\Ker\gamma$ 里，也就是说，$\hat{a'}$ 确定了且一定对应到了 $\Ker\gamma$ 中的某些元素。这就说明了 $\Img \delta \supseteq \Ker \hat{f'}$。&lt;/p>
&lt;p>我们写详细点，多写几步，那么让 $g(b) = c$，根据 $\delta$ 的定义（或者作用过程），对 $c$ 作用上 $\delta$ 后，将会先有若干个满足 $g(b) = c$ 的 $b$，紧接着这些 $b$ 将被 $\beta$ 映射到 $B'$ 里，最后从 $A'$ 里找到对应的原像，用它们生成一个等价类。而由于我们上面的过程，最后找到的 $A'$ 中的元素所生成的等价类，就是我们一开始的 $\hat{a'}$。这就说明 $\delta(c) = \hat{a'}$。 由于 $\hat{a'}$ 是我们随意取的在 $\Ker\hat{f'}$ 中的元素，都能得到 $\delta(c) = \hat{a'}$，因此 $\hat{a'}$ 确实就存在于 $\Img \delta$ 里。&lt;/p>
&lt;p>至此，我们证明了该命题，并结合上一个证明的命题，一起证明了链条在 $\Coker \alpha$ 处是正合的。&lt;/p>
&lt;h3 id="虚线箭头的相关证明">虚线箭头的相关证明
&lt;/h3>&lt;p>其实上面已经证明完了蛇引理的主体部分。下来我们将证明最后的两个命题：若交换图中的上下两个链条都是短正合列（也就是有 $0\to A$ 和 $C' \to 0$ 成立），那么在从该交换图中得到的正合列的头尾就可以补上 $0\to\Ker\alpha$ 以及 $\Coker\gamma\to 0$，使得 $\Ker\alpha$ 以及 $\Coker\gamma$ 处正合。&lt;/p>
&lt;p>我们还是先证第一个，也就是从 $0\to A$ 的存在可以得到 $0\to\Ker\alpha$ 且 $\Ker\alpha$ 处正合。&lt;/p>
&lt;h4 id="证明-operatornamekeralpha-处的正合性">证明 $\operatorname{Ker}\alpha$ 处的正合性
&lt;/h4>&lt;p>若有 $0\to A$，则根据正合列的性质（或者直接看交换图下面的那个链条），我们就有 $f$ 也是个单态。因此，对 $f$ 做出在 $\Ker\alpha$ 上的限制得到的 $f|$ 并不会改变它是单态的事实（只缩小了定义域）。此时，由于 $f|$ 是单态，它的核根据单态的性质，就一定是一个平凡群。&lt;/p>
&lt;p>此时我们补上 $0\to\Ker\alpha$，由于它一定是单态，它的像只能是平凡群。这自然地就证明了链条在 $\Ker\alpha$ 处是正合的。&lt;/p>
&lt;h4 id="证明-operatornamecokergamma-处的正合性">证明 $\operatorname{Coker}\gamma$ 处的正合性
&lt;/h4>&lt;p>如果有 $C'\to 0$，则根据正合列的性质，我们知道 $g'$ 就必须是满态，这也就意味着 $\Img g' = C'$。&lt;/p>
&lt;p>我们来看我们定义出的 $\hat{g'}\vcentcolon\space\Coker\beta\to\Coker\gamma$，任取它的定义域上的一个元素 $\hat{b'} = b'+\Img\beta$，经过 $\hat{g'}$ 映射后得到的 $\Coker\gamma$ 中对应的元素则是 $g'(b') + \Img\gamma$。然而由于 $\Img g' = C'$，这说明 $g'(b')$ 会随着所有对 $\hat{b'}$ 的选取而跑遍任何一个这里的 $C'$ 中的元素，进而使 $\hat{g'}$ 也是一个满态。自此，我们就可以给 $\Coker\gamma$ 的右端补上 $\Coker\gamma\to 0$ 的同时保持其正合性，因为补上的映射的核正是 $\Coker\gamma$。&lt;/p>
&lt;h3 id="证完串起来">证完串起来
&lt;/h3>&lt;p>至此，我们完全证明了前面列出的所有结论，进而证明了蛇引理。简单盘点我们证明过的东西，我们做了这些事：&lt;/p>
&lt;ol>
&lt;li>构造了五个阿贝尔群间的同态，一一验证了它们的定义是 OK 的；&lt;/li>
&lt;li>对四个点上的正合性做出证明，具体是先向前得到前一个同态的像在后一个的核内，再证明后一个的核再前一个的像内，从而得到正合&lt;/li>
&lt;li>对得到的正合列在交换图上下链条都是短正合列的情况做出补充。&lt;/li>
&lt;/ol>
&lt;p>这里有几个值得一提的点。首先，我们在一开始就得到了 $f|$ 和 $g|$ 的定义，它貌似是直接给出的，但应该是由我们自己定义的，即便定义好之后也是同样的形式。由于阿贝尔群同态的核天生就是其定义域上的阿贝尔子群，除了使用原同态在核上的限制来定义以外，并没有什么更好的定义方法了。&lt;/p>
&lt;p>另外，我们尝试给定义的 $\delta$ 一个具体的表达式，然而这个做法其实可能并不好（我们也应该已经看到了，$(f')^{-1}$ 可能会造成一些问题）。这个同态可以被称作 &lt;em>连接同态&lt;/em>，是蛇引理中连接上下两个正合列的的很重要的一个同态。&lt;/p>
&lt;p>然后，就余核来看，如果对它的一些性质更加熟悉，可能证明过程会更加简单。不过我们也在证明过程中看到了关于它的一些性质，这里就不再赘述，只提一点，就是余核内的单位元（零元）代表的不是简单的 $0$，而是一个等价类。我们还可以看到核与余核之间的一些微妙的联系。然而这里就不过多讨论这些了，这些更多是属于范畴论的内容。从范畴的角度来看，它们的区别就是用来定义的交换图内的箭头方向不一样而已。&lt;/p>
&lt;p>还有就是，我们对正合性做出验证时，并没有按照从左向右的顺序，而是先验证了处于交换图中间位置对应的点的正合性，再验证了两边的。这也许是受到了我所看的视频的影响吧。我想在这里做出另一个推荐的证明顺序，即从链条的左边开始，先证明这个链条是一个链复型，再证明它的正合性。从上面的证明过程来看，其实证明它是链复型的过程非常简单，难点则是那个反包含的证明。当然，我暂时也不计划再证明一次，这次写的很多了，就这样吧。&lt;/p>
&lt;p>此外，基础版本的蛇引理不包含最后的两个同态，就是 $0\to A$ 和 $C'\to 0$。另一个角度来讲，为了从交换图中得到一条正合列，我们只需要这些最低限度的条件。不过，蛇引理还可以继续拓展下去，不过就不叫蛇引理了。&lt;/p>
&lt;p>最后，我们要指出，我们这里做证明的方法，就是所谓的追图（Diagram Chasing）。这种方法从交换图的某个点内的元素为起点，沿着交换图中的态射移动，最终 “追” 到我们需要的元素为止，从而证明某个结论。追图是同调代数中重要的证明方法，其中最基础的一个证明例子便是这里的蛇引理。不过，这里的证明确实较为冗长，如果借助更高级更复杂的数学工具/技巧，比如范畴论，那么证明应该会更加简短一些，形式也更精简一些，不过可能很难看懂，我也不会这些（）&lt;/p>
&lt;h2 id="证毕后的一点感想">证毕后的一点感想
&lt;/h2>&lt;p>一开始动工的时候，我是没想到竟然能写这么多的。也许是因为我太罗嗦了吧，前面讲了很多的前置，也不知道讲清楚没有，而后面证明过程的很多话又都是套话；又或者我觉得写详细一些，易懂一些，可能会比较好，所以就把证明过程中我的一些想法以及口头的一些表达揉进去了。个人而言我还是挺喜欢思考这些东西并把思考过程写下来的。我也有想过把这篇拆成几个部分，不过目前先写在一起吧。即便看完这么多也需要好久好久。&lt;/p>
&lt;p>可以看到里面有一些可以点开的隐藏了的内容，有许多还没有写好，标记着 “Under Construction~”。这些内容应该会在某天我心血来潮之后再次补好吧（补档：我写好了！）。不过也有可能会删掉，或者直接拆分出来？我也不好现在就下判断。另外我还计划在这篇文章的后面，也就是在证明结束后，再补一个不那么啰嗦的证明过程。这样的话，已经有代数基础的朋友也许就可以直接跳到精简版的来看？emmm不过既然已经有代数基础了，想必来看这篇也就是图一乐了。还是希望能嘴下留情~ 作为一个普通的数学爱好者，能证完这个我感觉还挺有成就感的啦。&lt;/p>
&lt;p>不过必须承认的是，写的过程中我还是回头修改了不少表述不太合适的部分，以及这篇证明是离不开网络上的众多优秀资料的帮助的。感谢互联网，互联网万岁！~&lt;/p>
&lt;p>最后，祝您身心健康，生活愉快~&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>我其实挺纠结应该说 &lt;em>函数&lt;/em> 还是 &lt;em>映射&lt;/em> 的。函数我认为用以指代给集合上每个点指派一个数字的东西更合适，更符合我心目中对函&lt;strong>数&lt;/strong>的想象。而映射又太广泛了，因为很多地方代数结构之间不会一板一眼地讲 “同态”，而是直接就说映射了。思来想去，还是函数更合适，毕竟接触最多，接受程度也最广泛。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>这里所谓的合理性，在一般数学教材中称为良定义，而一个定义是合理的也被称为良定的。很奇怪的说法……良定……&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>有数学家表示应区别含幺环范畴 $\mathsf{Ring}$ 与不含幺的环范畴 $\mathsf{Rng}$，我觉得环应该含有乘法幺元，且应该省略元音字母 $\mathsf{i}$，所以写成这样。请根据上下文确定环范畴具体是什么样的含义。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>多相场模型与巨势方程</title><link>https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/</link><pubDate>Sun, 05 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%A4%9A%E7%9B%B8%E5%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B7%A8%E5%8A%BF%E6%96%B9%E7%A8%8B/ShoujouRei_MikitoP.png" alt="Featured image of post 多相场模型与巨势方程" />&lt;p>&lt;em>记录一下目前使用到的两个相场模型，包括它们的推导，假设和缺陷&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://twitter.com/katorei_" target="_blank" rel="noopener"
>かとうれい&lt;/a> 太太， 为 &lt;a class="link" href="https://space.bilibili.com/108833238" target="_blank" rel="noopener"
>Mikito P&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/list/ml1197098078?spm_id_from=333.1007.0.0&amp;amp;oid=27304533&amp;amp;bvid=BV1Rs411N7Aq" target="_blank" rel="noopener"
>少女レイ&lt;/a> 的曲绘&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=1334077117" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;h2 id="简介">简介
&lt;/h2>&lt;p>目前在做的 U-Nb 体系不连续析出的模拟，里面用到了这两个演化方程。之前一直没有仔细思考过这两个演化方程到底是什么来头，为什么这个体系适合使用这两个方程，导致现在想大概修改一下它们也无从下手。这里就作为笔记记录下这两个方程的推导方法，优缺点，以及我个人的一些看法吧。&lt;/p>
&lt;h2 id="多相场模型">多相场模型
&lt;/h2>&lt;h3 id="模型介绍">模型介绍
&lt;/h3>&lt;p>多相场模型（或者说是界面场模型，差不多吧）是适用于非保守场的演化方程，来自于 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
>I. Steinbach 和 F. Pezzolla 的文章&lt;/a>。它的形式为：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p>这里的 $F$ 是自由能泛函，$\tilde{N}$ 是有效序参量的个数，$\tilde{L}_{\alpha\beta}$ 是有效序参量里两相之间的界面移动参数，而括号内的差则是表示一种算符，即&lt;/p>
$$
\left(\frac{\delta }{\delta \phi_\beta} - \frac{\delta }{\delta \phi_\alpha} \right)F = \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha}.
$$&lt;p>简单来说，这篇文章考虑了使用界面场来描述不同相之间的界面并且演化，而非使用相自身的序参量作为演化参量。虽然最后还是会落到使用相自身的序参量来演化，但是界面场的思想融入到来这个演化模型中。最主要的改进应该是在考虑界面场的同时，考虑每个点处的有效序参量，也就是不为 0 的相的序参量，这样一来还可以简化计算（虽然实际计算过程中也可以只用传统的所有相的计算就是了）。&lt;/p>
&lt;p>平心而论，这篇文章写的逻辑结构并不是非常清晰，公式推导过程更是灾难，甚至符号都有一些问题，但是谁让这个模型好用呢？那就不多讲废话了，直接开始推导这个方程吧。要注意的是，这里的推导过程和作者的推导过程略有出入，同时也参考了 &lt;a class="link" href="https://doi.org/10.1016/j.commatsci.2023.112047" target="_blank" rel="noopener"
>Q. Huang et al 的这篇文章&lt;/a>。&lt;/p>
&lt;h3 id="模型推导">模型推导
&lt;/h3>&lt;p>对多相问题而言，我们引入一个约束：每个点上的所有序参量之和为一常数 1。即：&lt;/p>
$$
\sum_{\alpha = 1}^{N} \phi_\alpha = 1,
$$&lt;p>由于对时间求导的线性性，又有：&lt;/p>
$$
\sum_{\alpha = 1}^{N} \frac{\partial \phi_\alpha}{\partial t} = 0.
$$&lt;p>设我们现在已经有一个自由能泛函 $F[\{\phi\},\{\nabla\phi\}]$，其形式为：&lt;/p>
$$
F[\{\phi\},\{\nabla\phi\}] = \int_\Omega f\left(\{\phi\},\{\nabla\phi\}\right) \,\mathrm{d}\omega,
$$&lt;p>即我们写出了其能量密度形式。我们现在希望能把上面引入的约束进一步引入这个能量泛函内，因此我们使用 Lagrange 乘数法，引入 Lagrange 乘数 $\lambda$ 到自由能密度中，则有：&lt;/p>
$$
\begin{aligned}
l \left(\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right) &amp; = f\left(\left\{\phi \right\},\left\{\nabla\phi \right\}\right) - \lambda\left( \sum_{\alpha = 1}^{N} \phi_\alpha - 1 \right); \\
\mathcal{L}\left[\left\{\phi \right\},\left\{\nabla\phi \right\}, \lambda\right] &amp;= \int_\Omega l \,\mathrm{d}\omega.
\end{aligned}
$$&lt;p>然后我们令 $\mathcal{L}$ 对 $\phi_\alpha$ 做变分，得到：&lt;/p>
$$
\begin{aligned}
\frac{\delta \mathcal{L}}{\delta \phi_\alpha} &amp; = \frac{\partial l}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial l}{\partial \nabla \phi_\alpha} \\
&amp; = \frac{\partial f}{\partial \phi_\alpha} - \nabla \cdot \frac{\partial f}{\partial \nabla \phi_\alpha} - \lambda \\
&amp; = \frac{\delta F}{\delta \phi_\alpha} - \lambda .
\end{aligned}
$$&lt;p>此时我们应用所谓的 “Relaxation Ansatz”，即这个变分导数值为 $\phi_\alpha$ 的演化速率，即：&lt;/p>
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta \mathcal{L}}{\delta \phi_\alpha}\\
&amp;= -\frac{\delta F}{\delta \phi_\alpha} + \lambda
\end{aligned}
$$&lt;p>则根据上面的约束条件，我们能解出 $\lambda$ 为：&lt;/p>
$$
\lambda = \frac{1}{N} \sum_{\alpha = 1}^{N} \frac{\delta F}{\delta \phi_\alpha}
$$&lt;p>此时将 $\lambda$ 带入应用 “Relaxation Ansatz” 后的变分结果中，得到：&lt;/p>
$$
\begin{aligned}
\frac{\partial \phi_\alpha}{\partial t} &amp;= -\frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta = 1}^{N} \frac{\delta F}{\delta \phi_\beta} - \frac{\delta F}{\delta \phi_\alpha} \\
&amp;= -\frac{N-1}{N} \frac{\delta F}{\delta \phi_\alpha} + \frac{1}{N} \sum_{\beta \neq \alpha} \frac{\delta F}{\delta \phi_\beta} \\
&amp;= - \frac{1}{N} \sum_{\beta \neq \alpha} \left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F \\
\end{aligned}
$$&lt;p>最后，我们考虑到由于我们只考虑有效序参量，即不为 0 的序参量，这里的 $N$ 可以修改为 $\tilde{N}$；括号内属于对两相间的界面场的驱动力描述，对于不同的两相驱动力，驱动力大小应该是不同的，所以我们给驱动力前面乘以和两相相关的界面移动参数，$\tilde{L}_{\alpha\beta}$。这样一来结果为：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = -\frac{1}{\tilde{N}}\sum_{\beta \neq \alpha} \tilde{L}_{\alpha\beta}\left(\frac{\delta }{\delta \phi_\alpha} - \frac{\delta }{\delta \phi_\beta} \right)F,
$$&lt;p>即我们的多相场模型。&lt;/p>
&lt;h3 id="模型解释">模型解释
&lt;/h3>&lt;p>上面的推导过程，在最后一步之前都是比较合理的。然而为什么最后能把 $\tilde{L}_{\alpha\beta}$ 硬生生塞进求和里面呢？也许只能通过物理的角度去尝试解释。这个公式在考虑 “Relaxation Ansatz” 时没有引入移动性的一些参数，比如经典 Allen-Cahn 方程里的移动性矩阵，也是为了方便公式推导，否则会陷入求和地狱，得到的 $\lambda$ 的值会变成：&lt;/p>
$$
\lambda = \frac{\sum_\alpha\sum_\beta{}L_{\alpha\beta}\frac{\delta F}{\delta \phi_\beta}}{\sum_\alpha\sum_\beta{}L_{\alpha\beta}},
$$&lt;p>带入公式后会得到：&lt;/p>
$$
\frac{\partial \phi_\alpha}{\partial t} = \frac{\sum_\beta{L_{\alpha\beta}}}{\sum_\xi\sum_\zeta L_{\xi\zeta}}{\sum_\xi\sum_{\zeta\neq\beta} L_{\xi\zeta}\left( \frac{\delta }{\delta \phi_\beta} -\frac{\delta }{\delta \phi_\zeta} \right)F}
$$&lt;p>虽然严谨，但是难以理解，而当考虑到这里的移动性参数可以直接集成在 $\tilde{L}_{\alpha\beta}$ 和 $\tilde{N}$ 后，整个式子都会变得更简洁，物理意义也更加明确。&lt;/p>
&lt;p>另外，在 &lt;a class="link" href="https://doi.org/10.1016/S0167-2789%2899%2900129-3" target="_blank" rel="noopener"
>I. Steinbach 和 F. Pezzolla 的文章&lt;/a> 里，$\left( \frac{\delta }{\delta \phi_\alpha} -\frac{\delta }{\delta \phi_\beta} \right)F$ 被解释为界面场 $\psi_{\alpha\beta}$，这也是为什么这个模型叫做界面场模型。而这篇文章中的推导过程里，如果考虑使用界面场进行推导的话，可以绕过求取 $\lambda$ 的显式表达，因为这个 $\lambda$ 对所有相都是相同的，而界面场这样差值的定义方式注定会消去 $\lambda$ 的影响。&lt;/p>
&lt;p>最后，我们指出，这个演化方程并没有对自由能 $F$ 做出任何的约束，因此该模型适用性非常广。事实上，多相场模型的应用极为广泛，经常可以在近年的相场模拟文章中见到。所以，尽管看起来这个模型的推导（在我看来，也许是我的问题）并不足够可靠，但是它很好用。是的，很好用。&lt;/p>
&lt;h2 id="巨势方程">巨势方程
&lt;/h2>&lt;h3 id="模型介绍-1">模型介绍
&lt;/h3>&lt;p>为了演化保守场变量，我们经常需要使用 Cahn-Hilliard 方程。然而，为了得到更好的结果，又或者当我们遇到了一些由演化方程引入的数值上的问题，我们也许需要对这个经典的方程做一些改变，就像上面的 Allen-Cahn 方程和多相场模型之间的关系一样。对于浓度这个最经典的变量而言，我们有总浓度场模型（考虑整个模拟域的浓度），相浓度场模型（考虑每个相内部的物质浓度），以及我们这里要介绍的巨势方程（演化模拟域内的化学势）。&lt;/p>
&lt;p>在介绍巨势方程具体的表达式之前，我们先来看一下所谓的“相浓度”和“总浓度”吧。我们知道，对于整个体系而言，其组分数量（元素）是固定的，而一个体系中可能有多个晶粒，而每个晶粒又可能分属不同的相。对不同的相而言，其成分很有可能是不同的。因此，一个组分的浓度在每个相内应该是不变的（不随位置变化），而在整个模拟域内会发生改变（随着相的不同而变化）。另外，浓度的改变是依赖于扩散势的，扩散势梯度会引导浓度进行变化，从高势处流向低势处。因此，相生长过程中浓度的变化可以认为是相浓度不同所导致的相之间扩散势不同所引发的。根据这一点，我们还可以通过演化模拟域内扩散势的变化来间接地模拟浓度的变化。这里我们要介绍的巨势方程，就是这么一个用来模拟扩散势变化的方程。&lt;/p>
&lt;p>巨势方程的表达式如下：&lt;/p>
$$
\frac{\partial \mu_i}{\partial t} = \left[\phi_\alpha \frac{\partial c_j^\alpha}{\partial \mu_i} \right]^{-1} \left( \nabla\cdot \bar{M}_{jk} \nabla\mu_k + R_j - c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \right).
$$&lt;p>我需要解释一下这个方程的记号。首先，和往常相似，$c$ 代表相浓度（即一个相内部的浓度），$\phi$ 代表相。此外，这个公式中的 $\mu$ 代表化学势（严格来讲是巨势，这也是这个方程名称的由来，但为方便理解我们就称为化学势），$M$ 代表浓度的移动性参数， $R$ 代表可能存在的浓度/物质源。再者，这个方程实际上使用了爱因斯坦求和约定，即如果一个乘积中一个指标出现了两次，那么就对这个指标求和。我们举个例子，比如方程右侧圆括号中的最后一项的记号代表的是：&lt;/p>
$$
c_j^\alpha\frac{\partial \phi_\alpha}{\partial t} \coloneqq \sum_{\alpha}^{N}c_j^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p>因此，上面的方程实际上是一个复杂求和。另外，记号中的 $i,j,k$ 都是用以标记元素（组分）的，我们设一共有 $K$ 个组分，所以独立组分一共有 $K-1$ 个（最后一个的量可以用 1 减去其余所有的组分的量），同时 $\alpha,\beta$ 等是用来标记相的，我们设一共有 $N$ 个相。根据我们的记号，上面的公式中如果有某个量没有重复指标（重复指标通常也称为哑指标，dummy index），则说明这个变量实则是代表了一个向量，这个向量根据指标的记号区别有 $N$ 或者 $K-1$ 个分量。而如果一个变量有两个指标，则说明这个变量实则是一个矩阵。我们后文记 $K-1$ 为 $\tilde{K}$ 以方便书写。&lt;/p>
&lt;p>最后我们要解释的是中括号和 $-1$ 的上标。这个记号是代表我们先以括号内的元素组成一个矩阵，然后对矩阵求逆。至此方程中的下标记号应该已经全部清晰明了了。&lt;/p>
&lt;h3 id="方程推导">方程推导
&lt;/h3>&lt;p>下面我们来尝试对这个方程进行推导。我们直接从 Cahn-Hilliard 方程出发：&lt;/p>
$$
\frac{\partial \tilde{c}_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \frac{\delta F}{\delta \tilde{c}_j} + R_i.
$$&lt;p>这里我们再次对记号做一些解释。这里我们先不使用爱因斯坦求和约定，方便解释方程内部发生了什么，另外这里的 $\tilde{c}_i$ 代表的是体系内的总浓度。我们加上了波浪线是为了强调是整个体系内的总浓度，方便和后面的相浓度做出区分。&lt;/p>
&lt;p>由于我们这里使用了总浓度，它实际上可以使用相浓度和相分数来表示：$\tilde c_i = \sum_\alpha^N \phi_\alpha c^\alpha_i$。另外我们知道，$\frac{\delta F}{\delta \tilde{c}_j}$ 实际上是表示的体系内化学势（巨势）。所以我们直接用 $\mu_j$ 来替代。这样就有：&lt;/p>
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p>现在我们把目光聚焦在等式左侧，因为等式右侧，可以看到，其实已经是最终结果的一部分了。对于等式左侧，首先对有限求和而言，求导的线性性保证了我们可以把求导和求和交换次序。然后我们考虑使用对乘积偏导（求导）的规则，则有：&lt;/p>
$$
\frac{\partial \sum_\alpha^N \phi_\alpha c^\alpha_i}{\partial t} = \sum_\alpha^N\left(\phi_\alpha \frac{\partial c^\alpha_i}{\partial t} + c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} \right) = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i.
$$&lt;p>我们考虑把求和拆开，把含有相分数对时间求偏导的部分挪到等式右侧，则有：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \nabla \cdot \sum_{j}^{\tilde{K}}\nabla M_{ij}\nabla \mu_j + R_i - \sum_\alpha^N c^\alpha_i \frac{\partial \phi_\alpha }{\partial t} .
$$&lt;p>接下来是比较关键的一步，我们考虑把浓度和化学势联系起来。即考虑相浓度作为化学势的函数：$c_i^\alpha = c_i^\alpha\left( \mu_1, \mu_2, \cdots, \mu_{\tilde{K}} \right)$。这样我们就可以使用求（偏）导的链式法则，有：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial t} = \sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t},
$$&lt;p>然后考虑到对成分求和实际上与相无关，我们把对成分求和的求和号挪到最外面，这样就得到了：&lt;/p>
$$
\sum_\alpha^N \phi_\alpha \sum_k^{\tilde{K}}\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p>我们先在这里暂停一下，回忆矩阵乘法的记号。设我们有两个矩阵，一个 $n\times m$ 矩阵 $A = \{a_{ij}\}$ 和一个 $m\times p$ 矩阵 $B = \{b_{jk}\}$，则它们的乘积矩阵 $C$ 应该是一个 $n \times p$ 矩阵，它的元素可以记为：$\sum_j^m a_{ij}b_{jk}$。另外，我们考察偏导 $\frac{\partial c^\alpha_i}{\partial \mu_k}$ ，这个偏导在当 $i$ 和 $k$ 都在 $\tilde{K}$ 个元素中取值时，实际上它组成了一个 $\tilde{K} \times \tilde{K}$ 矩阵中的元素。对应的，我们可以把 $\partial \mu_k$ 看作一个具有 $\tilde{K}$ 个分量的向量（或者 $\tilde{K} \times 1$ 的矩阵）。&lt;/p>
&lt;p>根据上面的内容，我们可以发现，实际上这里的求和可以写作两个矩阵的乘积（或者矩阵乘以一个向量）。至此我们采用爱因斯坦求和约定，则有：&lt;/p>
$$
\sum_k^{\tilde{K}} \sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} \coloneqq \phi_\alpha\frac{\partial c^\alpha_i}{\partial \mu_k}\frac{\partial \mu_k}{\partial t}.
$$&lt;p>我们把上面等式右边的三个因子做简单的区分，前两个因子的乘积实际上由于 $\alpha$ 指标重复的原因，代表了一个求和，而后又因为这个求和与第三个因子的 $k$ 指标重复，代表了矩阵的乘法。或者我们可以把 $\sum_\alpha^N \phi_\alpha \frac{\partial c^\alpha_i}{\partial \mu_k}$ 理解为矩阵中的第 $\left( i,k \right)$ 个元素&lt;/p>
&lt;p>那么经过上面的说明，我们将等价变量依次带回，并对整个方程使用爱因斯坦求和约定重写，则有下面的结果：&lt;/p>
$$
\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\frac{\partial \mu_k}{\partial t} = \nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}.
$$&lt;p>现在我们可以将上式翻译为：一个 $\tilde{K} \times \tilde{K}$ 的矩阵 $\left\{\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k} \right\}$ 与一个 $\tilde{K} \times 1$ 矩阵 $\frac{\partial \mu_k}{\partial t}$ 相乘，得到的结果是三个 $\tilde{K} \times 1$ 矩阵相加。而我们希望的是能够得到演化体系扩散势变化的方程，这正好可以用 $\frac{\partial \mu_k}{\partial t}$ 来表示。所以我们的最后一步就是在等式两边同时左乘上这个 $\tilde{K} \times \tilde{K}$ 矩阵的逆矩阵，得到了：&lt;/p>
$$
\frac{\partial \mu_k}{\partial t} = \left[\phi_\alpha \frac{\partial c_i^\alpha}{\partial \mu_k}\right]^{-1}\left(\nabla\cdot \bar{M}_{ij} \nabla\mu_j + R_i - c_i^\alpha\frac{\partial \phi_\alpha}{\partial t}\right).
$$&lt;p>也许你会发现这个式子和我们一开始给出的式子在下标上有差别。这个实际上是为了公式美观而改变了下标的排列顺序。只要保证公式内部的记号顺序一致，就可以保证公式，或者说矩阵乘法的逻辑顺序一致，因此我们这里得到的结果和上面给出的公式是没有本质区别的。&lt;/p>
&lt;h3 id="模型解释-1">模型解释
&lt;/h3>&lt;p>我知道，这里其实留了很多的坑，比如说什么是巨势方程里的“巨势”？巨势和化学势有什么关系？为什么非要用化学势/巨势来演化整个体系，用总浓度不好吗？相浓度不行吗？我们来一个个解释这些问题。&lt;/p>
&lt;p>首先，巨势是什么呢？我们知道，热力学中有很多不同的热力学函数，比如焓 $H$，熵 $S$，内能 $U$，吉布斯自由能 $G$，亥姆霍兹自由能 $F$ 等等。巨势，又称朗道自由能也是一种热力学函数，其表达式为：&lt;/p>
$$
\Omega \coloneqq F-\mu N = U-TS-\mu N,
$$&lt;p>其中 $F$ 是亥姆霍兹自由能，$U$ 是内能，$T$ 是体系温度，$S$ 是熵，$\mu$ 是化学势，$N$ 是体系内的粒子数。巨势的微分形式为：&lt;/p>
$$
\mathrm{d}\Omega = \mathrm{d}U-T\mathrm{d}S-S\mathrm{d}T-\mu\mathrm{d}N-N\mathrm{d}\mu = -P\mathrm{d}V-S\mathrm{d}T-N\mathrm{d}\mu.
$$&lt;p>巨势在体系达到热力学平衡的时候会取到最小值。当体系内的其余变量 $V$，$T$ 不变时，巨势的变化实际上就反映了化学势的变化。另外我们还可以从这个公式中得到浓度的表达方式：考虑将巨势除以体系的体积得到能量密度，此时 $N$ 将从体系内粒子数量变为体系内的粒子浓度/数密度 $\rho$。假设我们还得到了物质的原子体积 $V_a$，那么浓度 $c$ 就可以表达为：&lt;/p>
$$
c = V_a \rho = V_a \left(\frac{\partial \Omega}{\partial \mu}\right)_{V,T}.
$$&lt;p>据此，我们可以考虑将浓度表达为化学势的函数。这也是前述的浓度能对化学势求导的一个佐证吧。&lt;/p>
&lt;p>那么，为什么要用巨势方程呢？它对比总浓度或者相浓度有什么优势呢？我们考虑一个多元多相体系，每个相内部都有多种组元，在相内部这些组元的浓度是固定的，而相与相之间的组元浓度一般是不同的。当发生相变时，相内物质浓度可能会发生变化。在这个情况下，我们如果想演化整个体系的浓度分布情况，就不可避免地必须演化每个相的浓度分布。&lt;/p>
&lt;p>我们首先会想到使用相浓度去演化整个体系，这样再将相浓度和相分数相结合就可以得到整个体系内的浓度分布。这个方法从理论上讲很不错，但从实际处理过程中会发生一些数值问题：在相界面处，特别是相分数较小的情况下，不可避免的要用一个数去除以一个非常小的（接近于0）的数字。由于 Cahn-Hilliard 方程是直接对总浓度进行演化的，因此必须先从总浓度中拆分出相浓度才可以直接演化相浓度。从总浓度反推相浓度时，不可避免要处理在界面上的浓度分配，这时必须要借助某种假设来正确地把浓度分配到每个相中。一般采用的假设是假设界面上的每个点上，每个相的化学势都相等。根据这点，总浓度和相浓度的关系可以表达为：&lt;/p>
$$
c^i = \sum_\alpha\phi_\alpha c_\alpha^i
$$&lt;p>这里，相浓度前的 $\phi_\alpha$，相分数，就会引发问题。假设现在需要演化某个很靠近某个相内部的位置（或者说 $\phi_\alpha \approx 1$ 的区域），此时将会有很多别的相的相分数约等于 0。为了演化各自的相浓度，就需要把这个相分数除过去，此时由于计算机精度问题，很容易造成结果不稳定。&lt;/p>
&lt;p>那如果直接考虑总浓度呢？总浓度实际上就是最传统的 Cahn-Hilliard 方程，而为了求得相的演化速率，还是需要通过某种方式去推出每个相中的浓度分配问题。这样会增加过多的计算量：反求相浓度的过程实际上是解线性方程组问题。也就是说，使用相浓度，会遇到数值问题，使用总浓度，又会增加很多的计算量，到头来不过是和相浓度方法的先后顺序调换一下，在反求相浓度的时候依旧可能遇到数值问题。&lt;/p>
&lt;p>然而，使用扩散势时，这个问题被巧妙地隐藏到了偏导数中。这样相当于用某种方法绕过了这样的数值问题，保持了合理的计算开销。简单来说就是，又快又好。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>其实很不好意思地说，这篇内容实际上只是对这两个公式做了一些简单的推导，而后面的解释部分我自认为写的并不好。好像所有的解释最后都要归结到一个结论上：好用。这个点实际上在考虑纯理论时是没有什么用处的：我需要精准的理论来描述物理现象，结果你却告诉我 XXX 然后 YYY 最后得到这些东西，它的理论背景可能不够强，但是它好用就够了。我相信这样的解释是很难真正地打动某个人的心的。&lt;/p>
&lt;p>然而，好用其实就已经够了，因为这些理论到头来本就是为了能够帮助我们在某个假设的基础上能够更好地做模拟。在这里，这个基础假设可以说是 relaxation ansatz 以及等势假设。首先第一个假设能够让我们的体系从一个非平衡态&lt;em>演化&lt;/em>到平衡态，而不是只能直接地给出一个平衡态下的数量场，而第二个假设则能够解决相场法中界面上物质分配的问题，让演化能够得以在多相的情况下正常进行下去。这些假设，不论从过程还是结果来看，都是很有必要的。而除了这些假设外，（在不考虑我自己推导过程不够严谨的情况下，）推导过程都是尽可能严谨的。得到的结果，也正如上面所说，好用。&lt;/p>
&lt;p>上面这一大段，我希望能传达到的意思就是，这些公式已经在较少的叫宽松的假设的基础上用尽可能严谨的逻辑推导出了可用，好用的结果，那么作为使用这些公式的人来讲，它好用就够了，坚持实用主义也许是更实际的做法。当然了，阅读本段的您也可以认为是我对自己的推导过程没有什么自信的开脱就是了，嘿嘿嘿~&lt;/p>
&lt;p>那么最后，祝您生活愉快~&lt;/p></description></item><item><title>关于泛函导数和变分法-来自相场公式推导的问题</title><link>https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;img src="https://a-moment096.github.io/p/%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%87%BD%E5%AF%BC%E6%95%B0%E5%92%8C%E5%8F%98%E5%88%86%E6%B3%95-%E6%9D%A5%E8%87%AA%E7%9B%B8%E5%9C%BA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E7%9A%84%E9%97%AE%E9%A2%98/HelloWorld-r-906.jpg" alt="Featured image of post 关于泛函导数和变分法-来自相场公式推导的问题" />&lt;p>&lt;em>本文系拾人牙慧之作，仅为解决公式推导过程中的一些边角料的数学问题，内容如有错漏还请谅解。另外，感谢老大中先生的《变分法基础》第三版。本文的主要内容几乎全部参考本书。&lt;/em>&lt;/p>
&lt;p>&lt;em>头图出自 &lt;a class="link" href="https://x.com/amn_amn_/status/1580863274081349632" target="_blank" rel="noopener"
>雨野&lt;/a> 太太，为 &lt;a class="link" href="https://twitter.com/arukuremu" target="_blank" rel="noopener"
>r-906&lt;/a> 所作的 &lt;a class="link" href="https://www.bilibili.com/video/BV1Ee4y1E7J6/" target="_blank" rel="noopener"
>Hello World!&lt;/a> 的曲绘&lt;/em>&lt;/p>
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
&lt;style type="text/css">.dark-theme .aplayer{background:#212121}.dark-theme .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark-theme .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark-theme .aplayer .aplayer-body{background-color:#212121}.dark-theme .aplayer .aplayer-info{border-top-color:#212121}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-music .aplayer-author{color:#fff}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark-theme .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark-theme .aplayer .aplayer-list{background-color:#212121}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark-theme .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark-theme .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark-theme .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark-theme .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark-theme .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark-theme .aplayer .aplayer-list li .aplayer-list-author{color:#ddd}.dark-theme .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark-theme .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top, #212121 0%, rgba(33,33,33,0) 100%);background:linear-gradient(to bottom, #212121 0%, rgba(33,33,33,0) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#212121', endColorstr='#00212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:-webkit-linear-gradient(top, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);background:linear-gradient(to bottom, rgba(33,33,33,0) 0%, rgba(33,33,33,0.8) 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#00212121', endColorstr='#cc212121',GradientType=0 )}.dark-theme .aplayer .aplayer-lrc p{color:#fff}.dark-theme .aplayer .aplayer-miniswitcher{background:#484848}.dark-theme .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}&lt;/style>
&lt;script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js">&lt;/script>&lt;meting-js auto="https://music.163.com/#/song?id=2076684514" theme="#2980b9" loop="none">&lt;/meting-js>
&lt;p>2025.06.06 更新：感谢&lt;a class="link" href="https://github.com/which-is-my-way" target="_blank" rel="noopener"
>@which-is-my-way&lt;/a>指正，公式 &lt;a class="link" href="#modify" >16&lt;/a> 补上点乘单位法向量&lt;/p>
&lt;h2 id="晶体相场公式带来的问题">晶体相场公式带来的问题
&lt;/h2>&lt;p>在一个阳光明媚的晚上，师兄找到我问了一个问题：下面的这个相场公式是怎么组装起来的？具体来讲是：从下面的公式（2）和公式（3）是怎么得到公式（4）的：
&lt;/p>
$$
\begin{align}
F &amp;= \int_V f \mathrm{d}v\\ &amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \left( \omega\left( \nabla^2 \right) \psi + \psi^3 \right)+ \xi.
\end{align}
$$&lt;p>
这里我们做一些简单的背景介绍吧。这个公式来源于&lt;a class="link" href="https://doi.org/10.1103/PhysRevE.70.051605" target="_blank" rel="noopener"
>这篇文章&lt;/a>，是提出晶体相场理论的文章，其重要性不言而喻，近乎所有的该领域的文章在使用这篇文章的结果时都需要引用这些个公式。我们这里不对晶体相场做太多介绍了（因为我也不了解，虽然也有相场两个字，但是几乎只有最最基础的假设相似而已了），简单介绍一下这些公式（名称）这些方便后面表述。其中公式（1）是指体系总能量可以表达为能量密度对体积的积分（这里先不给出能量和能量密度的参量），这里可以看到总能量实际上是一个泛函；（2）是指能量密度的具体构造，（3）是和传统相场形式相类似的一个演化方程，在传统相场里是 &lt;em>Cahn-Hilliard&lt;/em> 方程。而（4）就是将（3）中的变分展开得到的结果，或者说是具体计算过程中使用的公式的显式表达。&lt;/p>
&lt;p>另外我必须提到的一点是，这里列出的公式并不完整，比如 $\omega$ 是什么我并没有做说明，这是为了复述一下我的心路历程（即便是笔记，也不希望太死板，毕竟是从实际问题来的）。当然，后面会把完整的问题复述，以及推导过程完整地列出来的。&lt;/p>
&lt;h2 id="传统相场公式对吗">传统相场公式，对吗？
&lt;/h2>&lt;p>拿到这个公式的时候其实并不是直接从文献拿到的，而是几张图片（大概就是公式（2）（3）和（4））。而我看到公式的第一反应是：这符号不是很对吧？把 $\psi$ 放到括号外面？这不太对吧？然后我便开始按照以往推导传统相场能量变分的方式推导了。我们来看看传统相场公式吧。
&lt;/p>
$$
\begin{align}
F(c, \nabla c ) &amp;= \int_{\Omega} f(c, \nabla c )\, \mathrm{d}\omega = \int_{\Omega} f_b(c, \eta) + \kappa_c \left| \nabla c \right|^2 \mathrm{d}\omega;\\
\frac{\partial c_i}{\partial t} &amp;= \nabla \cdot M_{ij} \nabla \frac{\delta F}{\delta c_j \left( r,t \right)},
\end{align}
$$&lt;p>
其中，公式（6）即为 Cahn-Hilliard 方程，而公式（5）则是传统相场中的总能构造的一种常见（最基础的）形式，其中 $f$ 是能量密度，$f_b$ 是体自由能密度。可以看到能量泛函是依赖于（?）浓度和浓度的梯度的。对这个公式的推导我们直接使用三维条件下的 Euler-Lagrange 方程：
&lt;/p>
$$
\begin{align}
\frac{\delta F\left[ x,y,y' \right]}{\delta x} = \frac{\partial f}{\partial x} - \nabla \cdot \frac{\partial f}{\partial \nabla x}.
\end{align}
$$&lt;p>
这样一来，这个公式就可以被展开了，只需要按照能量泛函的具体表达形式带入，然后求一下偏导，很快就会得到结果。&lt;/p>
&lt;p>说实话，这是在太棒了，只需要用很多现成（?）的内容，做一些非常简单（?）的推导，就（?）可以得到最后体系的演化方程具体表达形式。那心动不如行动，直接把这一套挪到上面的原始问题吧。很好，我们先对 $\psi$ 求偏导，得到（?）下面的东西：
&lt;/p>
$$
\frac{\partial f}{\partial \psi} = \frac{1}{2}\omega\left( \nabla^2 \right)\psi + \psi^3,
$$&lt;p>
然后，我们要对 $\nabla \psi$ 求偏导了。嗯，$\nabla \psi$ …… 但是这里是 $\nabla^2$ ？话说回来为什么要用 $\omega$ 带括号把 Laplacian 算子包起来呀？啊？&lt;/p>
&lt;p>这对吗？这不对吧？&lt;/p>
&lt;h2 id="重新审视问题omega-是什么">重新审视问题，$\omega$ 是什么？
&lt;/h2>&lt;p>问题看来根本不是我想得那么简单。还是需要从零开始一步步建立起这个问题的合理描述，并找到真正的解决方法。首先要解决的，就是 $\omega(\nabla^2)$ 这个奇怪的写法。假如这个写法是对的，那 $\omega$ 就不是什么参数之类的东西了，就应该是算符的一个函数或者别的什么东西了。&lt;/p>
&lt;p>找到原始文献，查看定义，我们得到了 $\omega$ 的真面目：
&lt;/p>
$$
\begin{align}
\omega (\nabla^2) = r + \left(1 + \nabla ^2\right)^2,
\end{align}
$$&lt;p>
其中的 $r$ 是一个复杂的常数，不用关心。果不其然。$\omega$ 应该解释为一个对 $\nabla^2$ 算子做一种变换得到的新的算子。或者说，它是把算子映射到算子的一个映射。太棒了，我们把这个结果带入公式（1）中的 $f$ 吧：
&lt;/p>
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\\
&amp;= \frac{\psi}{2} \left(r + \left(1 + \nabla ^2\right)^2 \right)\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p>
等一下，算子中的平方应该怎么解释？常数作用于一个变量应该怎么解释？根据算符的运算规则，我们得知：算符的平方，应该解释为算符作用于被作用量两次，而常数作用应解释为标量乘法。那么我们得到：
&lt;/p>
$$
\begin{align*}
f &amp;= \frac{\psi}{2} \left(r\psi + \left(1 + \nabla ^2\right)^2\psi \right) + \frac{\psi^4}{4}\\
&amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \nabla^2\psi + \frac{1}{2}\psi\nabla^2\nabla^2\psi + \frac{\psi^4}{4}.
\end{align*}
$$&lt;p>
啊，看起来头好晕，怎么 Laplacian 也有个平方？我们更换符号：$\Delta = \nabla^2$，就有了：
&lt;/p>
$$
\begin{align}
f &amp;= r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{align}
$$&lt;p>
好了，这下我们搞清楚了 $\omega$ 到底是什么以及它对公式有何影响，现在我们对 $\psi$ 求的偏导应该就没问题了吧？&lt;/p>
&lt;p>等等，什么是 $\Delta\Delta\psi$ ？对 $\psi$ 求偏导的话要管它吗？就算不管这个东西，这个公式里没有熟悉的 $\nabla\psi$ 呀，那我们的能量密度对 $\nabla\psi$ 求偏导等于 0 ？这不太对吧？话说回来我们的总能量泛函到底依赖于什么变量？再等一下，依赖？对于一个泛函而言，我们只需要找到最符合要求的一个函数就好了呀？这个函数自然就可以通过对坐标求导得到自己的偏导数了，那偏导数就不应该是一个独立变量才对吧，我们对它做偏导数到底是为什么？&lt;/p>
&lt;p>完了，本来以为什么都知道，现在什么都不知道了。变分法，Euler-Lagrange 方程，这些都不应该是现成的吗？Laplacian，奇怪的 $\Delta\Delta\psi$，这些都不是能直接套到已有公式里的吧？&lt;/p>
&lt;h2 id="死胡同从头开始吧">死胡同？从头开始吧！
&lt;/h2>&lt;p>其实 $\Delta\Delta\psi$ 或多或少能想到是怎么个形式，无非就是把 $\Delta$ 作用两次就行了，关键在于这个变量，以及 $\Delta \psi$ 怎么参与到这个泛函构造中的，并且它们应该怎么参与到泛函导数里面。而为了搞清楚这个问题，我们也许必须明白这个泛函的“自变量”都有哪些，或者说，依赖于哪些变量，并且要搞清楚变量函数本身和它对位置的求导之间到底是有着什么样的关系。&lt;/p>
&lt;p>问题很多，我们干脆从头开始，一步步拆解吧，就从&lt;em>泛函是什么&lt;/em>这个问题开始。&lt;/p>
&lt;h3 id="泛函">泛函
&lt;/h3>&lt;p>我们讨论的泛函其实是一类特殊的映射，这个映射拥有定义域和陪域，其定义域为在某个空间上定义的全体函数组成的空间（比如，$\mathbb{R} \supseteq \Omega\to\mathbb{R}$ 的函数组成的空间，或者 $\mathbb{R}^3 \supseteq \Omega\to\mathbb{R}$ 的函数空间，根据我们的问题是几维的来确定这些函数的定义域），而泛函的陪域则是一个数域，对于能量而言我们就选择 $\mathbb{R}$ 好了。所以这个映射，从形式上来写，应该就是：&lt;/p>
$$
F:\left\{ y \;\Big|\; y: \Omega \to \mathbb{R} \right\} \to \mathbb{R}.
$$&lt;p>另外我们的泛函的另一个特殊之处在于，它常常可以写成这样一个积分的形式：&lt;/p>
$$
F = \int_\Omega f\, \mathrm{d}\omega.
$$&lt;p>我们常遇到的变分问题，也就是说在求什么样的函数 $\phi \in \left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 能够使得将之带入泛函 $F$ 时能让这个泛函取到最小值&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。甚至我们遇到的问题更加得特殊，因为我们要求函数族 $\left\{ y \\;\Big|\\; y: \Omega \to \mathbb{R} \right\}$ 满足这样的条件：在区域边界 $\partial \Omega$ 上这些函数族内的函数都必须相等，或者换句话说，就是我们的问题是固定边界问题。&lt;/p>
&lt;p>太棒了，但是上面这些叙述，对我们的问题有什么帮助呢？我们把目光聚焦到泛函积分形式中的这个 $f$ 上。它没这里有具体的表达式，只是说明了要对它做积分。它具有什么样的意义呢？&lt;/p>
&lt;h3 id="被积函数泛函的核">被积函数（泛函的核）
&lt;/h3>&lt;p>我们这里指出：这个被积分的东西 $f$ 实际上是对泛函的要求。在部分文献中 $f$ 也称为泛函的核。$f$ 的具体表达形式，将会对最后得到的 $y$ 做出约束，使之满足泛函 $F$ 取到最小值的结果。那么，一个对 $y$ 的约束，要怎么表达它呢？或者说我们应该对 $y$ 做一些什么，来使之成为 $y$ 的约束呢？&lt;/p>
&lt;p>为了用 $f$ 来约束 $y$，我们考虑使用 $f$ 来描述 $y$ 的行为。$y$ 在什么情况下，会得到什么样子的结果，大概就是这样的方式去描述。而我们常常在描述 $y$ 的行为时，会考虑到它的导数的行为，将导数 $y'$ 和 $y$ 二者相互作用时得到的结果结合起来。最后考虑到我们描述 $y$ 时很难避免加入函数自变量 $x \in \Omega$，最后我们得到的 $f$ 就会变成这样的东西：它看起来像是一个关于 $x\in \Omega$，$y : \Omega \to \mathbb{R}$ 以及 $y' : \Omega \to \mathbb{R}^n$ 三个变量的函数（其中 $n$ 的取值取决于考虑的函数的定义域维数）。当存在更多高阶导数参与描述 $y$ 的行为时，这个函数 $f$ 所依赖的变量就更多了。在这个函数中，我们不考虑 $y$ 是和 $y'$ 或者更高阶的导数相关的，因为它们都独立地描述函数 $y$ 的行为。可以这样理解：$y'$ 对函数 $y$ 的约束作用是没法直接用 $y$ 自己或者 $x$ 自己单独去描述的，所以它的影响就应该是独立于 $y$ 和 $x$ 的。 这样一来，令 $f$ 对 $y$，$y'$ 等求偏导也是可以理解的了。另外，我们只关注对 $y$ 起实际约束作用的量，假如 $f$ 中不含有 $y'$，我们认为 $f$ 是不显含 $y'$ 的，此时并不是说 $y'$ 不存在了，而是它不参与到对 $y$ 的行为约束中。&lt;/p>
&lt;p>当我们想要求取得到的函数的定义域从一维上升到我们更常遇到的三维时，函数 $y$ 所依赖的变量也就更加复杂了，可能包括 $\nabla y$，$\nabla \cdot y$，$\nabla \cdot \nabla y$ 等等。和上面类似，我们依旧将这些处理为独立存在于 $f$ 中的变量。有了上面这些的铺垫，我们至少能让我们的问题变得更加清楚一些：问题中的能量形式，将其变量依赖状态完整地写出，应该是以下的形式（这里我们按照惯例将&lt;em>双调和算子&lt;/em> $\Delta\Delta$ 写成 $\Delta^2$ 的形式，它也可以写作 $\nabla^4$）：&lt;/p>
$$
\begin{align}
F\left[\psi\right] &amp;= \int_V f \left(\psi,\Delta\psi,\Delta\Delta\psi\right) \mathrm{d}v\\ &amp;= \int_V r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4} \mathrm{d}v.
\end{align}
$$&lt;h3 id="再考察-euler-lagrange-方程">再考察 Euler-Lagrange 方程
&lt;/h3>&lt;p>然而上面的一切似乎只是澄清了一些基本事实，并没有对解决这个问题起到非常实质的帮助呀。别灰心，至少我们知道了：上面的 Euler-Lagrange 方程，应该是只适用于 $f(x,y,\nabla y)$的，而对于新的 $f$，我们需要自己想办法得到这样的方程。因此，我们必须深入到变分法的根本，去了解变分法到底是怎么推导出了上面我们用到的 Euler-Lagrange 方程的。为此，我们采用我们一开始认为非常轻易地获得的 Euler-Lagrange 方程所对应的泛函形式来作为例子，自己推导一下它对应的 Euler-Lagrange 方程。&lt;/p>
&lt;p>回忆我们面对的变分法的一般问题：在什么样子的函数 $y$ 下，我们构造出的泛函能够取最小值。我们的函数 $y$ 的定义域是固定的，所以我们要关心的是这个符合要求的函数在每一个点处的值应该是什么样的。不妨假设我们已经有了一个最佳的函数满足要求了，称这个函数为 $\varphi$。此时，由于这个函数已经是最好的，最满足需求的函数了，任何对这个函数某个值的改变，都会让我们的泛函不能取最小值。&lt;/p>
&lt;p>我们来试着把这个结论写成更形式化一些的表达：假设函数 $\varphi : \Omega \to \mathbb{R}$ 是满足泛函 $F$ 的最小值需要的函数，则此时任意函数 $y \neq \varphi$ 都会造成这样的结果：$F[y] - F[\varphi] = \delta F > 0$ ，这里的 $\delta F$ 就是泛函 $F$ 的&lt;em>变分&lt;/em>。这里大于 0 是因为我们已经知道了 $F[\varphi]$ 是最小值。反过来讲，当 $\delta F = 0$ 的时候，就能说明此时的函数 $y$ 就是我们需要的函数 $\varphi$。&lt;/p>
&lt;p>这个表达是否让你感到一丝熟悉？我们先继续向下推进。&lt;/p>
&lt;p>可以看到，假如我们把这个不等式用我们之前熟悉的泛函的积分形式展开，并根据积分的线性性合并，得到的结果是：&lt;/p>
$$
\delta F = \int_\Omega f(x,y, \nabla y) - f(x,\varphi,\nabla\varphi) \mathrm{d} \,\omega = \int_\Omega \delta f\, \mathrm{d}\omega.
$$&lt;p>上面的第二个等号是我们把被积函数的差记为了这样对函数的全变分。这个积分不等式的被积分项里，变量 $x$ 没有什么变化，那我们干脆将 $f$ 在现在看作一个二元函数。我们把 $\varphi$ 改写为以 $y$ 为基础加上一个扰动的形式：$\varphi = y+\delta y$，那么我们可以模仿全微分那样，把这里对函数的全变分 $\delta f$ 做全微分式的处理，就可以根据它的两个变量的偏导来写出其全变分的表达式。带入上式，则有：&lt;/p>
$$
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega = \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\delta\nabla y \right) \, \mathrm{d}\omega.
$$&lt;p>这个形式已经是我们很熟悉的形式了，但是还有一些区别。这里我们指出，函数对向量求偏导得到的也是一个向量，所以这里需要用向量内积，其中的技术细节我们不多赘述，我们更关注的是：怎么把 $\delta \nabla y$ 写成别的形式，来进一步向我们的结果前进。注意到 $\nabla$ 是对坐标求导，而 $\delta$ 则是在保持定义域不发生改变的情况下，改变了函数的值。因此二者应该是相互独立的，也意味着两个算符是可以相交换的。再使用点乘的乘积律：$\nabla \cdot (f{\bf{}v}) = f\nabla\cdot{\bf v}+{\bf v}\cdot\nabla f$，这样一通操作，就得到：&lt;/p>
$$
\begin{align}
\delta F = \int_\Omega \delta f\, \mathrm{d}\omega &amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y + \frac{\partial f}{\partial \nabla y}\cdot\nabla\delta y \right) \, \mathrm{d}\omega \\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y}\delta y - \nabla \cdot \frac{\partial f}{\partial \nabla y}\delta y \right) \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega .
\end{align}
$$&lt;p>而在式（13）中，最后的积分可以根据多元积分的 Green 公式，化成对区域 $\Omega$ 的边界 $\partial \Omega$ 积分。而此时，由于在边界上所有的函数的值都要相等，此时 $\delta y = 0$，这样最后一项积分就化为0了。我们写为下面的结果：&lt;/p>
&lt;span id="modify">
$$
\begin{align}
\delta F &amp;= \int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_\Omega \nabla\cdot\left(\frac{\partial f}{\partial \nabla y}\delta y\right) \, \mathrm{d}\omega\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega + \int_{\partial\Omega} \left(\frac{\partial f}{\partial \nabla y}\delta y\right)\cdot\hat{n} \, \mathrm{d}A\\
&amp;=\int_\Omega \left(\frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} \right)\delta y \, \mathrm{d}\omega.
\end{align}
$$&lt;/span>
这样，我们就距离我们希望得到的形式，Euler-Lagrange 公式只差一步了。注意到这里使用的 $\delta y$ 是任意的，假如 $\delta F = 0$，从积分里的内容来看，只能是括号内的部分等于 0。
&lt;p>我们可以看到，上面的过程，可以分为大致四个部分：得到全变分形式，将非目标变分以变分和微分的交换律改写为目标函数变分，消去多余项，由变分任意性得到被积函数内部等于 0。我们因此，可以根据我们已经熟悉的函数导数的概念，将公式（18）中的被积函数括号内这个关键部分定义为泛函的导数，即：
&lt;/p>
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y},
$$&lt;p>
当其为 0 时，
&lt;/p>
$$
\frac{\delta F}{\delta y} = \frac{\partial f}{\partial y} - \nabla \cdot \frac{\partial f}{\partial \nabla y} = 0,
$$&lt;p>
泛函即取到极值（在我们的情境下即为最小值）。这就是所谓的 Euler-Lagrange 方程。&lt;/p>
&lt;h3 id="最后一步">最后一步
&lt;/h3>&lt;p>现在，我们对泛函的概念做了一些解释，并从头建立起了我们之前使用的 Euler-Lagrange 公式。这里我希望做一些补充说明。可以看到这里的泛函导数并不是直接的“某些东西的商然后做极限”，而是将某个对我们有用的部分定义为了泛函导数。对这个概念最佳的解释，就是它等于 0 时代表泛函的极值，通过解这个方程就能得到令泛函取得极值的极限函数。它不应被解释为变化率或者什么别的内容。&lt;/p>
&lt;p>另外，我们上面用到了“二元函数全微分”这样的类比。平心而论，我自己并不是特别能接受这种说法。另一个可行的解释是，将函数 $y$ 化为 $y = \varphi + \varepsilon\eta$，也就是说我们使用了一个任意函数 $\eta : \Omega \to \mathbb{R}$，让它乘上一个极小的量 $\varepsilon$，这样就相当于用 $\varepsilon\eta$ 形成了一个函数的扰动，即 $\delta y$。我们要求 $\eta$ 是一个任意的函数，而在任何计算过程中都保持 $\eta$ 不变。此时整个式子将会成为只关于 $\varepsilon$ 的一元函数了。对于一个一元函数，其极值点就会出现在导数等于 0 的位置。那么此时对 $\varepsilon$ 求偏导，也能得到和上面类似的结论，并且通过格林公式化简得到最后的结论。当然，这也只是另一种思路，仅供参考。&lt;/p>
&lt;p>最后要提出的是，上面的推导过程是和 $f$ 的表达式强相关的，尤其是其依赖的变量。然而当我们再考察其和变量之间的关系时，可以发现每个变量实际上对应到最后的 Euler-Lagrange 公式中都是相对独立的。比如，$x$ 这个部分没有在公式中出现，$y$ 的部分对应对 $y$ 求偏导，而 $\nabla y$ 的部分则对应着对 $\nabla y$ 求偏导后再对结果做散度。这个结果是可以预想到的：由于全微分公式，或者换成泛函的语境，全变分公式，的性质，是会出现这样的结果。那么我们也自然可以预想到，假如 $f$ 依赖的变量是别的变量，也应该有类似的结论才对。&lt;/p>
&lt;p>到这里，我们近乎完全搞通了我们最后想要解决问题的路径。我们已经得到了泛函具体的表达式，搞清楚了泛函的核（即那个被积函数 $f$）的参数表，得到了对泛函做变分法的具体思路。我们的下一步，或者最后一步，便是真的带进去算了。&lt;/p>
&lt;h2 id="计算">计算！
&lt;/h2>&lt;p>为了读者的精神健康，我们隐藏当 $f$ 依赖情况为 $f(p,\psi,\Delta \psi,\Delta\Delta \psi)$ （其中 $p \in V$ 代表位置）时的 Euler-Lagrange 公式的推导，直接给出结果：&lt;/p>
$$
\begin{equation}
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right)
\end{equation}
$$&lt;details>
&lt;summary>如果你愿意看推导过程的话：&lt;/summary>
&lt;p>不，你其实不想看，你只是好奇我到底有没有真的写这些推导过程。事实是：写了，下面就是。&lt;/p>
&lt;p>但是如果你真的想看这个部分，谢谢你，我的努力没有白费。&lt;/p>
&lt;p>我们先根据全变分，写出泛函的核函数变分后的结果：&lt;/p>
$$
\begin{align*}
\delta F &amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \delta \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; = \int_V \delta f(p,\psi,\Delta\psi,\Delta\Delta\psi) \,\mathrm{d}v \\
&amp; =\int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v. \\
\end{align*}
$$&lt;p>接下来我们分别考察被积分的每一项。其中第一项的对 $\psi$ 的变分 $\delta\psi$ 已经符合我们的要求了，第二项中的 $\delta \Delta \psi$ 和第三项中的 $\delta \Delta\Delta\psi$ 则需要我们处理为某个函数乘以 $\delta\psi$ 的形式，以便于最后的逻辑处理。&lt;/p>
&lt;p>根据变分与求导和交换的关系，我们有：&lt;/p>
$$
\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi = \left(\frac{\partial f}{\partial \Delta\psi}\right)\Delta \delta \psi = f_1 \Delta\delta\psi;\\
\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi = \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right) \Delta\Delta\delta\psi = f_2\Delta\Delta\delta\psi,
$$&lt;p>其中每行公式的第二个等号都是为了护眼做的处理，即将括号中的偏微分用记号表示。我们先看上面第一个式子，这是两个标量函数的乘积，其第二个因式展开应为:&lt;/p>
$$
\Delta \delta \psi = \nabla \cdot \nabla \delta\psi,
$$&lt;p>注意到散度存在恒等式：$\nabla \cdot (f\mathbf{v}) = f\nabla\cdot\mathbf{v} + \nabla f \cdot \mathbf{v}$，其中 $f$ 为标量函数或标量场， $v$ 为向量值函数或向量场，我们可以对上面的结果变换得到：&lt;/p>
$$
\begin{align*}
f_1\nabla \cdot \nabla \delta\psi &amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla f_1\cdot \nabla\delta\psi \\
&amp;= \nabla\cdot(f_1\nabla\delta\psi) - \nabla\cdot(\delta\psi\nabla f_1) + \delta \psi \nabla\cdot\nabla f_1.
\end{align*}
$$&lt;p>上式对一个三维区域 $\Omega$ 的积分，根据散度定理，有：&lt;/p>
$$
\begin{align*}
\int_V f_1 \nabla\cdot\nabla\delta\psi \,\mathrm{d}v &amp;= \int_V \nabla\cdot(f_1\nabla\delta\psi)\,\mathrm{d}v -\int_V \nabla\cdot(\delta\psi\nabla f_1) \,\mathrm{d}v+\int_V \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v \\
&amp;=\int_{\partial V} f_1\nabla\delta\psi\cdot\hat{n}\,\mathrm{d}s - \int_{\partial V} \delta\psi\nabla f_1\cdot\hat{n} \,\mathrm{d}s + \int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v\\
&amp;=\int_{V} \delta \psi \nabla\cdot\nabla f_1 \,\mathrm{d}v.
\end{align*}
$$&lt;p>上式第二个等号使用了散度定理，第三个等号则是考虑到在边界处 $\delta\psi = 0$，$\nabla\delta\psi = \mathbf{0}$。这样我们就得到了原变分中被积函数第二项的表达形式。我们现在考虑其中的第三项，即 $f_2\Delta\Delta\delta\psi$。我们先将其中的 $\Delta\delta\psi$ 看作函数标量函数 $\varphi$，则原式写为 $f_2\Delta\varphi$。此时，套用我们上面已经得到的结果，有：&lt;/p>
$$
\begin{align*}
\int_V f_2 \Delta\Delta\delta\psi \,\mathrm{d}v &amp;= \int_V f_2 \Delta\varphi \,\mathrm{d}v\\
&amp;= \int_{\partial V} f_2\nabla\varphi\cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \varphi\nabla f_2\cdot\hat{n} \,\mathrm{d}s+\int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v \\
&amp;= \int_V \varphi \nabla\cdot\nabla f_2 \,\mathrm{d}v = \int_V \varphi \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \Delta\delta\psi \Delta f_2 \,\mathrm{d}v = \int_V \nabla\cdot\nabla\delta\psi\, \Delta f_2 \,\mathrm{d}v\\
&amp;= \int_{\partial V} \Delta f_2\nabla\delta\psi \cdot\hat{n}\,\mathrm{d}s -\int_{\partial V} \delta\psi\,\nabla (\Delta f_2)\cdot\hat{n} \,\mathrm{d}s+\int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v \\
&amp;= \int_V \delta\psi \Delta \Delta f_2 \,\mathrm{d}v,
\end{align*}
$$&lt;p>其中所有的操作与前面是一样的，不断用恒等式拆开，然后由于在边界上的包含 $\delta\psi$ 的项全部归零，所有对 $V$ 的边界 $\partial V$ 的积分都会变成 0，最后就得到了我们想要的结果。我们把这些积分再合起来，将为了方便所做的记号带回，就有：&lt;/p>
$$
\begin{align*}
\delta F &amp; = \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \Delta\psi
+ \left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \Delta\Delta\psi \,\mathrm{d}v \\
&amp;= \int_V \left(\frac{\partial f}{\partial \psi}\right)\delta \psi
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)\delta \psi
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\delta \psi \,\mathrm{d}v \\
&amp;= \int_V \left(\left(\frac{\partial f}{\partial \psi}\right)
+ \Delta\left(\frac{\partial f}{\partial \Delta\psi}\right)
+ \Delta\Delta\left(\frac{\partial f}{\partial \Delta\Delta\psi}\right)\right)\delta \psi \,\mathrm{d}v.
\end{align*}
$$&lt;p>那么，由泛函导数的定义，我们就得到了 Euler-Lagrange 方程：
&lt;/p>
$$
\frac{\delta F}{\delta \psi} = \frac{\partial f}{\partial \psi} + \Delta \left(\frac{\partial f}{\partial \Delta \psi}\right)+ \Delta\Delta \left(\frac{\partial f}{\partial \Delta\Delta \psi}\right).
$$&lt;/details>
&lt;p>现在,我们来把式子带进去吧。为了方便，我们先把公式待带入的公式写在下面：&lt;/p>
$$
\begin{align}
F[\psi] &amp;= \int_V f(p,\psi,\Delta\psi,\Delta\Delta\psi) \mathrm{d}v\\
&amp;= \int_V \left(\frac{\psi}{2} \omega \left(\nabla ^2\right)\psi + \frac{\psi^4}{4}\right) \mathrm{d}v;\\
\omega (\nabla^2) &amp;= r + \left(1 + \nabla ^2\right)^2;\\
\frac{\partial \psi}{\partial t} &amp;= \nabla^2 \frac{\delta F}{\delta \psi} + \xi.\\
\end{align}
$$&lt;p>我们的目的也就是将公式（21）先带入公式（20）得到能量的具体表达形式，然后将得到的结果带入公式（18）来计算能量变分，最后得到公式（22）的显式表达。其中第一步已经完成了，能量密度的具体表达形式为：&lt;/p>
$$
\begin{equation}
f = r\frac{\psi^2}{2} + \frac{\psi^2}{2} + \psi \Delta\psi + \frac{1}{2}\psi\Delta\Delta\psi + \frac{\psi^4}{4}.
\end{equation}
$$&lt;p>我们先对公式（23）计算需要的这些偏导数，得到：&lt;/p>
$$
\begin{align}
\frac{\partial f}{\partial \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3;\\
\frac{\partial f}{\partial \Delta \psi} &amp;= \psi;\\
\frac{\partial f}{\partial \Delta\Delta \psi} &amp;=\frac{1}{2}\psi.
\end{align}
$$&lt;p>现在把这些得到的结果，即公式（24-26）带入到我们得到的 Euler-Lagrange 方程（18）中。注意在前面加上对应的 Laplace 算子或者双调和算子。得到的结果为：&lt;/p>
$$
\begin{align}
\frac{\delta F}{\delta \psi} &amp;= r\psi + \psi + \Delta\psi + \frac{1}{2}\Delta\Delta\psi+\psi^3 + \Delta\psi+\frac{1}{2}\Delta\Delta\psi \\
&amp;=r\psi + \psi + 2\Delta\psi + \Delta\Delta\psi+\psi^3\\
&amp;=\left(r + \left(1 + 2\Delta + \Delta\Delta\right)\right)\psi+\psi^3\\
&amp;=\omega(\Delta)\psi + \psi^3.\\
\end{align}
$$&lt;p>那么最后，把式（30）带回到式（22）中。此时我们尊重原文，把符号统一，将 $\Delta$ 重写回 $\nabla^2$，就有：&lt;/p>
$$
\begin{equation}
\frac{\partial \psi}{\partial t} = \nabla^2 \left(\omega(\nabla^2)\psi + \psi^3\right) + \xi.
\end{equation}
$$&lt;p>这就是我们一开始的目标，式（4）。&lt;/p>
&lt;h2 id="后记">后记
&lt;/h2>&lt;p>其实这个问题一开始就很清楚：只要找到正确的 Euler-Lagrange 公式，带入无脑计算就行了。但是如何找到正确的 Euler-Lagrange 公式则是一个比较棘手的问题。本文的思路启发自老大中先生的《变分法基础》，翻开书，几乎所有的笔墨全都放在了如何去根据泛函的形式来推导出对应的 Euler-Lagrange 方程上。所幸，我们的这个方程形式非常简单，且答案几乎是现成的，只需要找到正确的位置后取用即可。&lt;/p>
&lt;p>那么这篇文章前面的部分有什么用呢？像跳梁小丑一样跳来跳去，最后发现从一开始就不对劲，转而从头开始推导整个公式。如果一开始就找到这个合适的公式，不就好了吗？也许能够找到这个合适的公式确实能立马解决眼前的问题，但是以后呢？如果遇到了一个形式又不太一样的泛函，此时应该怎么推导出其对应的 Euler-Lagrange 方程呢？而且从文章前半部分可以看到：我对变分法的理解，在推导出这个公式以前，是有问题的。我机械地认为就是带入那个人尽皆知的 Euler-Lagrange 方程，然后算算算就好了。旋即就遇到了第一个问题：怎么让 Laplacian 对梯度求导。是的，我当时并不怀疑是公式问题，而是考虑怎么让这个公式能算下去。在网上搜索一段时间之后，我貌似得到了结果，但总归不太满意，因为带入后得不到最后的公式。&lt;/p>
&lt;p>一段迷茫过后，我突然对变量之间的依赖情况产生了疑惑。网上搜寻的结果表明，不能单纯地看作相互关联的变量，或者说单纯的求导关系。最后我得到了上文中的解释，也许我在这部分的解释是错误的，但我用这个方法说服了自己。希望这个观点没有问题。顺带，我得到这个解释或多或少受到了热力学的启发：热力学中的偏导数必须标明哪些变量是固定不变的，这时因为热力学参数张成了一个高维空间，而体系的热力学状态则是这个空间上的一个超平面，热力学状态函数则是这个超平面上定义的场。因此，对热力学状态函数求偏导的时候必须固定求导方向，也就是固定某些变量不变。也许是这样的理解让我将泛函的核理解为了对函数的约束（我也不知道怎么联系上去的，所以说只可谓之&lt;em>启发&lt;/em>）。&lt;/p>
&lt;p>然而即便如此，我依旧没法得到最后最关键的公式。此时只能从头开始一步步推导 Euler-Lagrange 公式了。所幸，我找到了老大中先生的这本书，读过一部分之后，遍跳着找到了我需要的答案。感谢这本书，让我少走了不知道多少弯路。&lt;/p>
&lt;p>最后，感谢您能阅读到这里，看这么久的流水账也挺辛苦的。希望这篇流水账一样的文章也能帮助正在阅读的你增进对 Euler-Lagrange 公式和变分法或者泛函导数的理解。&lt;/p>
&lt;p>那么，祝您生活愉快~&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>请容许我这里混淆最小值和极小值，以及最值和极值，因为我们默认需要这个泛函取到的是极小的部分，且这个极小值一定是全局的，即最小值。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Phase Field: 相场模拟学习笔记 III</title><link>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iii/</link><pubDate>Mon, 23 Dec 2024 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iii/</guid><description>&lt;img src="https://a-moment096.github.io/posts/PF_Tutorial/Skadi.png" alt="Featured image of post Phase Field: 相场模拟学习笔记 III" />&lt;p>&lt;em>接上一节内容, 这节会简单介绍 C++ 的一些语法知识, 然后用 C++ 实现一维传热方程的模拟。&lt;/em>&lt;/p>
&lt;h2 id="c一门高效的适宜科学计算的程序语言">C++：一门高效的，适宜科学计算的程序语言
&lt;/h2>&lt;p>C++ 是一门经典的编程语言，于 1979 年由 Bjarne Stroustrup 设计，最初目的是为了成为更好的 C 语言，而后随着自身发展，成为了一门和 C 语言有许多相似之处，而又截然不同的一门语言。 C++ 支持多种编程范式，包括但不限于面向过程，面向对象，函数式，模板元编程等等。 其丰富的生态，高效的算法库以及&lt;em>零成本抽象&lt;/em>的理念让 C++ 极为适合进行各类科学运算。此外，C++ 的语法较为亲民，其多种编程范式也便于不同背景的开发者上手，故我们在这里引入 C++ 作为后续计算使用的程序语言。&lt;/p>
&lt;h3 id="c-简介">C++ 简介
&lt;/h3>&lt;p>首先，我们对 C++ 的一些基础概念做出简单的介绍。这些概念你也许在上节中已经遇到过来，这里再做出进一步的解释。&lt;/p>
&lt;h3 id="c-编译器">C++ 编译器
&lt;/h3>&lt;p>C++ 作为一门语言，当谈起 C++ 编程时，实际上我们只是书写了以 C++ 的格式书写的代码，而将这些代码翻译为机器能够阅读并执行的程序，需要许多道不同的工序。幸运的是，&lt;strong>编译器&lt;/strong>（compiler）可以近乎一步到位地帮助我们完成这个过程。C++ 历史悠久，自然发展有多种编译器来编译源代码。这里列举其中三个较为知名的编译器（工具链）：&lt;/p>
&lt;ul>
&lt;li>GNU Compiler Collection (GCC) 以及 G++：来自 GNU 基金会的开源老牌编译器工具集合，其中用以编译 C++ 的编译器为 G++。G++ 编译器几乎是 Linux 平台的标准编译器，而 Windows 平台可以考虑使用一些迁移工程，如 Cygwin， MSYS2 或 MinGW（Minimalist GNU for Windows）。其链接器为 &lt;code>ld&lt;/code>，调试器为 &lt;code>gdb&lt;/code>。&lt;/li>
&lt;li>Microsoft Visual C++ (MSVC)：微软开发的 C++ 编译器工具，除了编译 C++ 外还兼职编译其他的一些代码，如 C 等。其命令行工具名为 &lt;code>cl.exe&lt;/code>，但只能通过微软的开发者命令行调用。使用 MSVC 的一般方式为使用微软开发的 IDE。其链接器为 &lt;code>LINK.exe&lt;/code>，调试器为 &lt;code>vsdbg.exe&lt;/code>。&lt;/li>
&lt;li>Clang++ / LLVM：LLVM 组织开发的一款模块化的现代编译器工具集合，其中用以编译 C++ 的编译器前端为 Clang++。 Clang++ 为 MacOS 系统默认的编译器。当然也可以安装在 Windows 平台或 Linux 平台上。其链接器为 &lt;code>lld&lt;/code>， 调试器为 &lt;code>lldb&lt;/code>。
以上三款编译器近乎最受欢迎的 C++ 编译器，当然也有一些其他的 C++ 编译器，但由于不同编译器对语言的实现可能有所不同，依旧是建议没有特殊需求的开发者采用三大主流编译器编译 C++ 代码。&lt;/li>
&lt;/ul>
&lt;p>编译器负责将源码编译为二进制文件，而&lt;strong>链接器&lt;/strong>（linker）则负责将不同的二进制文件按照要求链接起来，形成一个单独的二进制文件。&lt;strong>调试器&lt;/strong>（debugger）则负责读取符号表后对二进制文件进行逐行运行与调试。至于编译器的&lt;em>前端&lt;/em>，&lt;em>后端&lt;/em>以及其具体运行超出了单纯运用的范围，这里不深入介绍（其实笔者也不太懂）。&lt;/p>
&lt;p>这里同时也稍微提一下 &lt;em>编译器&lt;/em>，&lt;em>编辑器&lt;/em>，&lt;em>解释器&lt;/em> 和 &lt;em>IDE&lt;/em> 的区别。其中，解释器我们已经在 Python 中遇到过，它负责将 Python 代码逐行解释给机器并令机器执行。其属于广义上的编译器，即将源代码（文本）转化为机器能识别的指令等的程序。而狭义的编译器则指将文件整体处理并编译为二进制文件的程序。由于 C++ 的执行必须先编译为二进制文件，故其编译器是必不可少的。编译器则与前两者完全区分开，是编辑文字的工具。常见的编辑器如 Windows 上的记事本，Linux 上常用的 Eamcs，Vim，较为现代的 VSCode 等。 经常与编辑器搞混的概念则为IDE。IDE是指集成开发环境（Integrated Developing Enviroment），其兼具编辑器与编译器的功能，可以在其中编辑代码并编译为二进制文件后运行，且通常具有别的功能，如断点调试等等。 这些概念是有一定区分的必要的，否则容易造成误解。&lt;/p>
&lt;h3 id="c-编译链接">C++ 编译链接
&lt;/h3>&lt;p>理解 C++ 的编译过程与链接过程对正确运用编译器编译 C++ 代码是必要的。这里不会过分深入，旨在介绍大致过程，以免出现一些常见问题（如找不到符号定义等）。&lt;/p>
&lt;p>在编译过程中，编译器会首先将所有的源文件（通常后缀为 &lt;code>.cpp&lt;/code>, &lt;code>.cxx&lt;/code> 等）按照要求编译为相对应的对象文件（Linux 上为 &lt;code>.o&lt;/code> 文件，Windows上为 &lt;code>.obj&lt;/code> 文件），并留下没有实现但是已经声明过的函数、类等，等待链接器链接至对应位置的静态或动态库。随后链接器将执行链接，即将对象文件，外部静态库（ Static Library, Linux上的 &lt;code>.o&lt;/code> 或 Windows 上的 &lt;code>.lib&lt;/code> 文件）和外部的动态库（Shared Object 或 Dynamic Library，Linux上的 &lt;code>.so&lt;/code> 或 Windows 上的 &lt;code>.dll&lt;/code> 文件）链接至一起形成一个二进制文件。其中，静态库将和程序生成的对象文件合并到一起形成一个文件，动态链接库则不被合并到文件中。因此，使用动态链接库可以减少重复代码，降低程序的大小。随后在运行该程序时，当程序需要外部链接库中定义的内容时，操作系统将按照一定的顺序寻找动态链接库，并找到其中的定义然后执行。当没能找到动态链接库时，程序便会报出“未定义的符号 XXX”的错误。一般程序会到环境变量中的位置寻找动态链接库，随后在程序所在文件夹下寻找动态库。如果用到了动态链接库，请注意让程序能找到动态库，否则无法成功运行。&lt;/p>
&lt;p>上面仅为简单的介绍，其中编译过程还可以细分为若干步，链接过程也可以分为若干步骤。这里不再介绍。但是需要指出的是：编译过程中，根据编译的类型，会对代码进行不同程度的优化。常见的所谓 &lt;em>Release&lt;/em> 版本即为打开所有优化选项，且不生成/加载符号表的程序版本，其程序体积小，运行速度快，但通常无法调试（因为缺少符号表）。与之对应的 &lt;em>Debug&lt;/em> 版的优化则较少，但其含有的符号表可以在调试过程中逐步运行代码并查看变量值。编译程序时请注意这些区别。&lt;/p>
&lt;h3 id="调试器与调试">调试器与调试
&lt;/h3>&lt;p>调试器通常是一类独立的程序，其可以运行编译链接完成的可执行程序，并且加载程序对应的符号表后可以逐行运行程序。调试器还支持断点，在特定位置暂停程序的运行，并且显示当前位置程序中加载的变量和函数调用栈等。调试器的出现极大地方便了程序的调试，可以方便定位程序中存在的问题并做出修改，以编写出更加符合要求的代码。&lt;/p>
&lt;p>调试器常常拥有自己的界面，可以独立运行，然而目前常见的使用方式是使用一些外部程序调用调试器，捕获其输出并传递输入的参量，以便与源代码进行对照。常见的 IDE 均有此功能，而一些编译器经过合理的配置之后，也可以调用调试器进行使用。通常的调试过程为：添加断点，逐步运行，查看变量/修改变量值，步入函数/步出函数等。调试过程中可以多加探索。&lt;/p>
&lt;h3 id="c-环境搭建">C++ 环境搭建
&lt;/h3>&lt;p>如果您使用 Windows 平台，最简单的方法即为考虑微软旗下的 Visual Studio。作为一款成熟的 IDE，Visual Studio 可以在简单的了解其操作之后便将注意力集中在编程解决问题本身而非工具的使用。只需要在官网下载 Visual Studio 的下载器，在下载器界面内选择 C++ 桌面开发的组件，便可以在安装后创建一个解决方案+一个项目，并在左边资源管理器中新建一个 C++ 源文件后开始编写程序了。所有的编译器选项等等都可以通过项目属性来管理配置。如果需要在 Windows 平台上编写大型程序的话，Visual Studio 近乎是 Windows 平台的不二之选。&lt;/p>
&lt;p>不过如果只需要编译运行单个 C++ 文件，又或者 Visual Studio 太过笨重，不适合您的电脑环境的话，可以考虑使用 MinGW-w64 或者 MSYS2 中的编译器与 C++ 运行时。在写好 C++ 源文件之后， 像在 Linux 环境下一样调用 &lt;code>g++&lt;/code> 命令编译源文件，即可得到可执行的程序。除了在 Windows 上模拟 Linux 环境外，还可以考虑使用 WSL 来创建本地的轻量化 Linux 子系统，登录到子系统后就相当于打开了 Linux 虚拟机，此时便可在 Linux 环境下安装编译所需要的工具链并进行编译了。&lt;/p>
&lt;p>由于所谓源代码仅为有一定格式的文本文件，故而您可以使用任何喜欢的文本编辑工具来编写源代码。然而好的编辑器可以辅助编写，特别是代码高亮，自动补全，调用编译器等功能可以极大地方便代码编写。这里推荐使用 VSCode，其丰富的插件生态可以在安装好编译器与对应插件的情况下提供良好的代码高亮，定义跳转，自动补全的功能，且可以编译 C++ 源文件并调试/执行。具体内容由于 VSCode 提供了详尽的文档，这里不再赘述。&lt;/p>
&lt;h3 id="c-标准">C++ 标准
&lt;/h3>&lt;p>作为一门发展良久的语言，C++ 经历了数次版本迭代，也因此拥有多个语言版本。根据 ISO 的标准，C++ 委员会将对语言特性，语法规则等进行调整，对语言库做出提案，并由各大编译器厂商进行实现。不同的编译器厂商可能会采用不同的实现方式，且不同的编译器可能会添加不同的扩展，故而非标准的 C++ 代码可能需要根据平台和编译器进行编译。而当源码采用的标准与编译器标准不同时，也常常会出现编译错误。所以在编写/编译源文件时应明确采用的 C++ 标准。目前业界常用的且拥有广泛编译器支持的 C++ 标准为 C++14，但该标准较为老旧，缺少很多便利的库函数等。可以考虑使用 C++17 或者 C++20 标准以方便使用。本教程使用 C++17 标准。请注意 Visual Studio 默认的 C++ 标准为 C++14，如有必要请在项目属性中修改 C++ 标准。&lt;/p>
&lt;h2 id="c-语法基础">C++ 语法基础
&lt;/h2>&lt;p>经过上面的介绍，相信您已经对 C++ 所配套的工具和其必要的信息已经有所了解，而到目前为止，我们还没有介绍 C++ 具体的语法。那么我们接下来便开始 C++ 语法的介绍。&lt;/p>
&lt;h3 id="注释头文件和-include">注释，头文件和 &lt;code>#include&lt;/code>
&lt;/h3>&lt;p>程序通常都有注释。C++ 中的单行注释以 &lt;code>//&lt;/code> 开始，让编译器忽略一行中 &lt;code>//&lt;/code> 后的所有内容。 而多行注释（或者更准确地说，范围注释）则是以 &lt;code>/*&lt;/code> 开始，以 &lt;code>*/&lt;/code> 结束。简单更改程序时，单行注释很常用，而多行注释常用来书写大段说明性的文字，特别是版权信息等。&lt;/p>
&lt;p>打开一个 C++ 文件，首先看到的常常是各种 &lt;code>#include&lt;/code> 开头的若干行。在 C++ 中，当需要使用外部的内容时（如，函数，类等），通常使用 &lt;code>#include&lt;/code> 预处理命令来将对应库的头文件引入该文件。比如需要使用标准库的输入输出流时，则需要在源文件中使用 &lt;code>#include &amp;lt;iostream&amp;gt;&lt;/code>。而在使用自建库时，通常使用冒号 &lt;code>&amp;quot;&amp;quot;&lt;/code> 而非尖括号 &lt;code>&amp;lt;&amp;gt;&lt;/code> 来引入头文件。&lt;/p>
&lt;p>所谓头文件，通常指以 &lt;code>.h&lt;/code> 结尾的 C++ 代码，其中声明了一些函数或者类等，也可以在头文件中实现这些函数/类。在引入头文件后，便可以使用头文件中定义的名称，作用类似于 Python 中的 &lt;code>import&lt;/code>，但更为原始一些，因为 &lt;code>#include&lt;/code> 会令编译器直接将对应文件复制粘贴到对应位置。&lt;/p>
&lt;p>标准库的头文件常常与标准库相关联，所谓标准库，是指 C++ 标准所提供的一系列函数，类，函数模板以及类模板等内容。上面的 &lt;code>iostream&lt;/code> 便是一个例子。 标准库非常地多，当有需要时请自行搜索是否存在已有的库可以满足需求。&lt;/p>
&lt;h3 id="main-函数和小例子">&lt;code>main&lt;/code> 函数和小例子
&lt;/h3>&lt;p>对 C++ 程序而言，一个可执行文件必须要包含一个 &lt;code>main&lt;/code> 函数作为程序的主入口。当程序执行时，会从 &lt;code>main&lt;/code> 函数开始执行，并且逐行向下。一个 C++ 程序只能拥有一个程序入口，意即 &lt;code>main&lt;/code> 函数。下面是一个简单的例子：&lt;em>hello_world.cpp&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;Hello C++ world!&amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>main&lt;/code> 函数拥有以下几个特点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>main&lt;/code> 函数必须拥有 &lt;code>int&lt;/code> 返回值类型&lt;/li>
&lt;li>&lt;code>main&lt;/code> 函数的参数列表可以为空，也可以有两个参数：一个整值类型用以表示接受参数的个数，一个字符串数组/指针/容器用以存储接受的参数。&lt;/li>
&lt;li>&lt;code>main&lt;/code> 函数成功执行时应返回 &lt;code>0&lt;/code>。标准允许不写返回值，默认返回 &lt;code>0&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>main&lt;/code> 函数除了作为程序入口以外，本身也是一个满足 C++ 语法的函数。我们后面会看到 &lt;code>main&lt;/code> 函数作为函数的几个要素。&lt;/p>
&lt;h3 id="变量类型">变量类型
&lt;/h3>&lt;p>C++ 和 Python 最大的区别中，其中一个便是所有的变量具有静态类型（别的区别还有不需要代码缩进表示代码块等等）。在 C++ 中，声明变量需要首先声明变量的类型，然后是变量名。可以（也推荐）在声明变量时给变量初始化，通常只需在变量名后用等号 &lt;code>=&lt;/code> 接上需要赋予的值即可。也可以通过初始化列表进行变量初始化，且对于类而言还可以使用合适的类构造函数进行变量初始化。下面是一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">yes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vd&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mf">0.1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0.2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0.4&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;I&amp;#39;m a string!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了简化内容，我们只介绍 &lt;code>int&lt;/code>，&lt;code>double&lt;/code>，&lt;code>bool&lt;/code>，&lt;code>string&lt;/code> 和 &lt;code>vector&lt;/code> 五种类型，他们分别代表有符号整数，双精度浮点数，布尔值，字符串和向量。其中前三种是 C++ 的内置变量类型，在计算过程中常用到；后两者需要引入对应的头文件才能使用。这里有以下几点需要注意：&lt;/p>
&lt;ul>
&lt;li>变量不进行初始化时请不要使用。可能会带有垃圾数据。如上面示例中的 &lt;code>double j&lt;/code> 并没有对变量 &lt;code>j&lt;/code> 进行初始化，里面可能存有任何错误的数据，需要在初始化之后使用。&lt;/li>
&lt;li>变量可以使用大括号 &lt;code>{}&lt;/code> 进行初始化，称为初始化列表。该方式对多个数据的组合变量较为常用。&lt;/li>
&lt;li>使用标准库内的变量/类/函数时，如果没有使用 &lt;code>using namespace std;&lt;/code> 进行全局获取名称，请使用 &lt;code>std::&lt;/code> 来告诉编译器该名称的位置。 这里不介绍命名空间的内容。&lt;/li>
&lt;li>对于 &lt;code>vector&lt;/code> 这种类模板，请在后面的尖括号中指明容器中数据的类型。如上的 &lt;code>std::vector&amp;lt;double&amp;gt;&lt;/code> 意即声明一个内部变量类型为 &lt;code>double&lt;/code> 的容器类 &lt;code>vector&lt;/code>。&lt;/li>
&lt;li>字符串以双引号&lt;code>&amp;quot;&lt;/code>开头，以双引号&lt;code>&amp;quot;&lt;/code>结尾。&lt;/li>
&lt;li>请勿使用全角字符，C++ 文本使用半角字符作为其符号。&lt;/li>
&lt;li>变量命名不能以数字开头，可以包含数字，下划线和英文字母。&lt;/li>
&lt;/ul>
&lt;p>请注意，C++ 是严格类型语言。 当类型不匹配（且自动类型转换失败）时编译器会报错，在存在自动类型转换的情况下编译器可能会警告。请尽量不要让类型做自动转换，如使用 &lt;code>double&lt;/code> 将整数变量强行转化为小数等。&lt;/p>
&lt;h3 id="作用域">作用域
&lt;/h3>&lt;p>和 Python 相似，C++ 也有变量作用域的概念。在 C++ 中，代码块使用花括号（大括号）来区分，代码块可以嵌套于代码块内。代码块内的变量可以获取代码块外变量的信息，但代码块外的变量无法获取代码块内的信息。变量在离开自己定义位置所在代码块时，如果没有特殊情况，将会自动销毁。使用循环，判断语句以及声明函数时使用的花括号也是一个作用域。下面是一个小例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">888&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// success
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="c1">// i will be 888 here
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Below is an error:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// j = 666;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="控制流循环和判断语句">控制流，循环和判断语句
&lt;/h3>&lt;p>首先介绍循环语句。这里仅介绍 &lt;code>for&lt;/code> 循环与 &lt;code>while&lt;/code> 循环。下面是使用 &lt;code>for&lt;/code> 和 &lt;code>while&lt;/code> 循环的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这两个循环都会将数字从 &lt;code>0&lt;/code> 打印至 &lt;code>9&lt;/code>，且其语法特征是完全相同的。其中 &lt;code>for&lt;/code> 循环圆括号内第一项为循环前语句，会在循环开始前执行，常用来声明并初始化循环变量；第二项为循环条件，满足条件则继续循环；第三项为循环末尾语句，在执行完循环体内语句后将执行第三项中的语句。而 &lt;code>while&lt;/code> 循环则显得简单很多：只要满足括号内的语句条件便可以一直进行下去。 请注意下面的循环在套上一层代码块后才能与上方等同。换句话说，在 &lt;code>for&lt;/code> 循环括号中定义的变量时临时变量，在离开循环后将会自动销毁。另外值得注意的是，&lt;code>for&lt;/code> 循环的括号内是三个语句，使用分号 &lt;code>;&lt;/code> 分割，而非逗号 &lt;code>,&lt;/code>。另外，判断条件实际上是一个表达式，当表达式值为 &lt;code>true&lt;/code> 时则继续循环，为 &lt;code>false&lt;/code> 则停止。&lt;/p>
&lt;p>这里再介绍一下所谓的 range &lt;code>for&lt;/code> 循环。当存在一个不变长的容器式的变量时，可以通过：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="n">rep_elem&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">container&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="cm">/* xxx */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样的语法来用 &lt;code>rep_elem&lt;/code> 依次从前向后地取用所有的元素，以此完成循环。&lt;/p>
&lt;p>判断语句这里仅介绍 &lt;code>if-else&lt;/code> 语句。下面是一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;false&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="nf">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;yes&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;?&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其语法特性一目了然，这里不再赘述。&lt;/p>
&lt;p>另外要介绍的是 &lt;code>break&lt;/code> 和 &lt;code>continue&lt;/code> 控制命令。当循环遇到 &lt;code>break&lt;/code> 命令时将会立刻停止循环，而当执行到 &lt;code>continue&lt;/code> 时则会结束本次循环，进入到下一次循环。对于嵌套循环，&lt;code>break&lt;/code> 和 &lt;code>continue&lt;/code> 只负责当前循环的控制，不会控制父循环。&lt;/p>
&lt;h3 id="函数">函数
&lt;/h3>&lt;p>C++ 中的函数包含五个要素：返回值类型，函数名，参数列表，函数体，返回值。下面是一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kt">double&lt;/span> &lt;span class="nf">my_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们声明了一个函数：返回值类型为 &lt;code>double&lt;/code>，函数名为 my_add，参数列表中接受两个 &lt;code>double&lt;/code> 类型的参数。这三个要素即可声明一个函数的存在。后面的函数体和返回值则是对该函数的实现方法，这里只做了一件事，即返回了参数列表中两个值的和。&lt;/p>
&lt;p>这里要提出的是，C++ 中的函数允许不返回值，此时返回值类型为 &lt;code>void&lt;/code>；函数也可以不接受任何参数，这时只需空置参数列表即可，但是圆括号是必须的。我个人建议声明函数时即将函数做出定义，但是在有必要时，可以列出声明后在另外的地方做出函数定义，例如将声明放在头文件中，函数定义则放在一个源文件中。&lt;/p>
&lt;p>另外，在这里我尝试提出另一种理解函数的方式：提供了对外通道的独立代码块。这个代码块可以把外部的数值通过参数列表交换给代码块内部，而后从代码块内部返回一个结果交给代码块外部。在需要使用该代码块时，只需使用代码块的名称即可。此外需要注意的时，在使用函数时，像上面例子所定义的函数是无法改变外部数据值的。可以理解为代码块内部的所有内容都独立于其他部分，不会对接外部的上下文，只会根据传入的数据进行处理。如果需要改变外部数据，则需要在参数列表中传入&lt;strong>指针&lt;/strong>或者&lt;strong>引用&lt;/strong>，这两个概念会在下一个部分介绍。&lt;/p>
&lt;p>最后要提出的是，函数允许递归调用，即函数调用自己。通过递归调用，可以将复杂的逻辑用较为简单的代码实现。C++ 函数还允许&lt;em>重载&lt;/em>，即同一个函数名通过参数列表的不同来让编译器自动区分调用的是什么函数。请注意，仅返回值不同是无法区分的，只有参数列表才能让编译器对同名函数做出区分。也许可以考虑将参数列表纳入“函数名”的一部分，这可以为所谓的&lt;em>函数指针&lt;/em>带来一定的解释，但可能有一些问题？所以仅供参考。&lt;/p>
&lt;h3 id="指针">指针
&lt;/h3>&lt;p>我们这里不会介绍指针太复杂的内容，仅对指针最基本的用法以及其背后（可能）的思想做出大致介绍。在介绍指针之前，有必要先简单介绍 C++ 语言下的内存逻辑。&lt;/p>
&lt;p>在程序运行过程中，由操作系统所管理的程序内存可以根据代码中的内容而区分为两个部分：堆和栈。其中的栈实际上是一种数据结构，指先入后出的队列，但这里我们只把它理解为一个由程序直接管理的内存。这些内存（比如某些变量）会由代码创建后存在栈上，当该程序的变量脱离某个部分时，由于变量的生存周期便会从栈上弹出销毁。这带来了一些好处，让程序的所有内存都得到恰当的管理，但是操作系统能分配给程序的栈空间大小是有限的，当栈空间不足以储存所有变量时，程序便会报出&lt;em>栈溢出&lt;/em>的错误。&lt;/p>
&lt;p>为了解决这样的痛点，程序允许和操作系统沟通，拿到不直接属于程序栈空间内的内存。拿到的这些内存就保存在&lt;em>堆&lt;/em>上，而声明或使用这些内存则可以使用&lt;em>指针&lt;/em>来取得。需要注意的是，虽然堆空间很大，但是堆空间由于数据散乱，其速率可能不如栈上的内存；另外，即便空间很大，不加限制的创建内存且不加销毁，特别是运行时间较久的时候，程序可能会用光所有的内存，此时便会造成所谓的&lt;em>内存泄漏&lt;/em>。由于使用堆上数据近乎只能依靠指针，所以使用指针时需要格外注意，特别是内存的释放。&lt;/p>
&lt;p>那么指针到底是什么？我们提取上面所给出的一些信息：指针需要能够获得堆上的内存，C++ 是强类型语言，需要使用指针获取并管理堆上内存。如果考虑 C++ 可以通过内存的地址管理内存，那么答案就呼之欲出了：指针，实际上是一种特别的变量。它会记录一个地址，并记录上这个地址下的数据的类型（同一数据，在不同类型解释下会给出不同的值，比如 &lt;code>0&lt;/code> 在 &lt;code>int&lt;/code> 下就是数字0，而在 &lt;code>bool&lt;/code> 下则会解释为 &lt;code>false&lt;/code>，所以指针的类型（大部分情况下）是必须的），随后在使用该地址内所存储的数据时，只需要对指针&lt;em>解引用&lt;/em>便可以获得该值。下面是一个例子来说明如何声明指针，以及如何获取变量的地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="c1">// Output i&amp;#39;s address
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="c1">// Modify i&amp;#39;s value
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">8&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1234&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//1234
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的例子中，我们先声明了（栈上）的一个变量 &lt;code>i&lt;/code>，随后用 &lt;code>int *&lt;/code> 作为数据类型名声明了一个指针 &lt;code>p&lt;/code>，并用 &lt;code>&amp;amp;i&lt;/code> 取得 &lt;code>i&lt;/code> 的地址，然后给这个变量 &lt;code>p&lt;/code> 赋予了 &lt;code>i&lt;/code> 的地址的值（称为&lt;em>指针p指向i&lt;/em>）。此时输出 &lt;code>p&lt;/code> 的值时会打印出一些十六进制数字。之后，通过 &lt;code>*&lt;/code> 运算符，取出了保存在 &lt;code>p&lt;/code> 中的地址下存储的值，并直接对该内存地址覆写数据 &lt;code>1234&lt;/code>。由于 &lt;code>p&lt;/code> 保存的地址正是 &lt;code>i&lt;/code> 的地址，所以对 &lt;code>i&lt;/code> 的地址写入新数据即为给 &lt;code>i&lt;/code> 重新赋值。这样一来，输出 &lt;code>i&lt;/code> 的值时，得到的结果即为 &lt;code>1234&lt;/code>。&lt;/p>
&lt;p>希望这个例子以及这里的简单介绍能帮助你理解指针是什么以及有什么作用。值得注意的是，这里指针指向的变量依旧是一个栈上的变量，而在很多需要使用指针的情况下，需要的常常是堆上的数据。为了在堆上创建变量，需要使用 &lt;code>new&lt;/code> 关键字。而当在堆上创建变量后，如果不再使用变量时，必须使用 &lt;code>delete&lt;/code> 关键字删除该变量。其主要原因是，当我们声明指针时，通常都是在栈上创建的数据；作为一个栈上的变量而言，当指针变量离开其作用域时便会被销毁。如果只有一个指针指向某个内存空间时，销毁该指针之后，内存中的数据便没有别的办法取到；而此时由于通过 &lt;code>new&lt;/code> 创建了这个内存，操作系统会一直保留这个内存直到 &lt;code>delete&lt;/code> 删除该内存，或者程序退出由操作系统销毁所有内存。这样一来，只 &lt;code>new&lt;/code> 不 &lt;code>delete&lt;/code>，当数据量较大时便会造成严重的内存泄漏；此外只 &lt;code>new&lt;/code> 不 &lt;code>delete&lt;/code> 还会把数据暴露在外，造成安全风险。然而要是使用了两个指针指向同一个内存时，如果在一个指针上销毁了内存，而另一个指针仍然认为内存没有销毁，那么该指针便会称为&lt;em>野指针&lt;/em>，或者&lt;em>悬空指针&lt;/em>。这时，当尝试使用该指针时，程序便会出错，轻则报错退出，重则产生难以排查的奇怪问题。&lt;/p>
&lt;p>上面这么一大段，其最终目的只为了说明一件事：请不要轻易使用指针。指针很好用，但是 C++ 中也提供了别的很多更友好的方式来管理并使用内存。一旦使用裸指针又不小心忘记删除或者出现空指针，程序便会出现很多奇怪的问题。所以，对自己技术没有绝对自信时，请不要轻易使用指针。&lt;/p>
&lt;p>最后我们提出如何使用指针来帮助函数改变外部变量的值：通过指针传入参数时，虽然函数无法改变参数的值，但是由于参数传入的指针指向的内存空间不会受到影响，所以可以在函数内部给传入的指针内保存的地址下的变量赋值，从而绕开函数的限制。然而，为了达成这一目的，有一种更加安全，且更加便于理解的方式：&lt;em>引用&lt;/em>。&lt;/p>
&lt;h3 id="引用">引用
&lt;/h3>&lt;p>与指针相比较而言，引用就显得更加和蔼一些了，简单来讲，声明一个引用也就是声明了一个变量的别名。我们先看一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ri&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">ri&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">&lt;span class="n">ri&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5678&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//5678
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们首先声明了一个变量 &lt;code>i&lt;/code>，然后创建了一个引用 &lt;code>ri&lt;/code> 作为 &lt;code>i&lt;/code> 的别名。这样一来，我们对 &lt;code>ri&lt;/code> 所做出的&lt;em>任何操作&lt;/em>（应该）都是相当于对 &lt;code>i&lt;/code> 本身所做出的。当 &lt;code>i&lt;/code> 被销毁时，变量 &lt;code>i&lt;/code> 和它的引用 &lt;code>ri&lt;/code> 会一起消失。和指针相比，引用显然要安全的多。但是与此同时，引用也有一些限制：引用不能改变它引用谁。一旦引用被创建，引用本身和引用所指向的内容就绑定死了。此外，由于引用&lt;em>别名&lt;/em>的特性，引用不可能存在空引用，这也就要求了引用的“声明”必须立刻对其初始化，且一经初始化就不可改变。所以这里不应该使用“声明”，“赋值”等描述这一过程，最恰当的描述即为“初始化”。&lt;/p>
&lt;p>值得注意的时，引用，和指针类似，也可以作为函数参数传入函数内部。当作为函数参数把引用传入函数内部时，引用的“别名”特点依旧保持，函数内对参数的改变依旧会反映在函数外部。一种理解方式是，函数参数列表的默认传参方式是把参数的值复制一份，生成一个临时变量，然后使用该变量；指针传参时把指针的地址复制了一份，然后使用该临时地址可以在不改变地址的情况下改变地址内部的数据；引用传参时，创建了一个临时的引用，由于引用的特性，函数对引用的影响就相当于对变量本身的影响。&lt;/p>
&lt;p>总之，引用在 C++ 中是更加推荐的使用方式。当然，引用也有别的限制。引用由于终究是变量的“别名”，不会改变变量的内存布局，所以不存在“引用数组”这一数据结构。同时，也不会出现引用的引用，也不会有指针的引用。这主要是因为，引用并不是实际的对象，不会占据内存，因此也没有对应的地址（参考 &lt;a class="link" href="https://stackoverflow.com/questions/1164266/why-are-arrays-of-references-illegal" target="_blank" rel="noopener"
>Stack Overflow 上的回答&lt;/a>）。&lt;/p>
&lt;p>最后，有人声称引用是必须初始化的常量指针。这一点见仁见智，个人认为可以这么去理解行为，但二者不能划等号，具体实现需要根据不同的编译器去考虑。&lt;/p>
&lt;h3 id="类模板stl">类，模板，STL
&lt;/h3>&lt;p>前面的部分几乎涵盖了所有 C++ 的基础语法。这里再做出一些补充，比如 C++ 的面向对象（类），模板和标准模板库。&lt;/p>
&lt;h4 id="类面向对象">类，面向对象
&lt;/h4>&lt;p>面向对象在 Python 已经做出了简单的介绍。这里在其基础上介绍 C++ 的面向对象的语法。&lt;/p>
&lt;p>首先需要注意的是，C++ 中存在结构体 &lt;code>struct&lt;/code> 和 类 &lt;code>class&lt;/code> 两种类似的数据结构。一般认为，&lt;code>struct&lt;/code> 和 &lt;code>class&lt;/code> 的区别仅在于默认的访问控制。 &lt;code>struct&lt;/code> 的默认访问是 &lt;code>public&lt;/code> 的，而 &lt;code>class&lt;/code> 则是默认 &lt;code>private&lt;/code> 的。然而，也许二者也有一些微妙的区别，这里不加区分。（我也不知道）&lt;/p>
&lt;p>下面是一个简单的类声明的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">my_class&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">is_true&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="n">my_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">is&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">s_value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">is&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">print_info&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Data is obtained? &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">is_true&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Value is &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">simple_class_sample&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们声明了一个类，名为 &lt;code>my_class&lt;/code>，其中包含有两个数据，这些数据由 &lt;code>private&lt;/code> 保护起来所以外界无法直接取得这两个数据；在公开的部分（&lt;code>public&lt;/code>）中有两个函数，一个 &lt;code>my_class&lt;/code> 和一个 &lt;code>print_info&lt;/code>。由于是 &lt;code>public&lt;/code> 的，可以在类外调用这两个函数。其中可以看到，&lt;code>my_class&lt;/code> 的函数名和类名相同。这是一类特殊的函数，名为类的&lt;em>构造函数&lt;/em>。在使用该类声明一个新的变量时，可以使用该函数来初始化变量。由于函数重载的特性，一个类可以拥有多个不同的构造函数以满足不同的构造条件。这里隐藏了一些函数，这些函数会自动定义好，包括&lt;em>析构函数&lt;/em>（变量退出作用域时会调用析构函数销毁变量），&lt;em>拷贝赋值函数&lt;/em>（将变量复制从而创建一个新变量），以及&lt;em>默认构造函数&lt;/em>（什么都不做，采用默认值初始化类内的变量），等等。&lt;/p>
&lt;p>这里再次提醒，创建一个类实际上就是创建了一个新的复合数据类型，通过该复合数据类型以及其内部定义的函数（方法），可以实现通过方法来操控用该类型创建的变量（对象）。&lt;/p>
&lt;p>最后，类的定义必须在大括号后添加一个分号，否则编译器会报错；定义好一个类后可以立刻创建一个变量，这里创建了一个变量名为 &lt;code>simple_class_sample&lt;/code>，使用了默认构造函数。&lt;/p>
&lt;p>C++ 的面向对象的特性十分丰富且比较完备，这里不再做出介绍。&lt;/p>
&lt;h4 id="模板">模板
&lt;/h4>&lt;p>模板是一类更加复杂的，更加高阶的编程方式。模板会在编译器即进行运算，因此模板从某种角度而言，可以说是用来生成代码的代码。这里提到模板，主要是引入后面的标准模板库，因此这里仅做出最简单的介绍。&lt;/p>
&lt;p>下面是一个类模板创建和函数模板创建的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="n">T&lt;/span> &lt;span class="n">my_add_t&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">class_T&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">T&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">print_T_value&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">text&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里创建了一个函数模板 &lt;code>my_add_t&lt;/code> 和一个类模板 &lt;code>class_T&lt;/code>。在使用它们时，只需要在其模板名后面跟上一个尖括号，然后在尖括号内写上需要的类型名即可。这里需要注意的是，在使用这里定义的类模板时，要保证 &lt;code>T&lt;/code> 类型中拥有 &lt;code>text&lt;/code> 这个属性，否则会报错。&lt;/p>
&lt;h4 id="stl-标准模板库">STL: 标准模板库
&lt;/h4>&lt;p>STL 是 Standard Template Library的缩写，即标准模板库，是一系列的函数和类库，允许使用库中的类模板和函数模板。科学计算中，最常见的类模板便是 &lt;code>std::vector&lt;/code> 了。作为类模板，需要在使用它的时候用尖括号来放入变量的类型。这个类型没有太大的限制，除了因为历史遗留问题而不推荐 &lt;code>bool&lt;/code> 作为函数模板外，几乎可以使用任何变量类型来实例化该类模板。像这样的容器模板类还有 &lt;code>std::deque&lt;/code>，&lt;code>std::array&lt;/code> 等，它们都有各自的特性，感兴趣请自行搜索。这里介绍这些容器类共有的一些常用方法。&lt;/p>
&lt;p>作为容器，一定存在一个方法来告知其内部元素的数量，这个方法为 &lt;code>size()&lt;/code>。调用 &lt;code>size()&lt;/code> 方法后会返回一个 &lt;code>size_t&lt;/code> 类型的数字来表示容器内元素数量。其次，我们需要存取容器中的元素。取用元素时，STL 提供了 &lt;code>at()&lt;/code> 方法来从容器的某个位置下取出元素，这个方法接受一个整型数据来取出容器中的元素，当这个数字超出了容器范围时将会报错。当然 STL 也提供了传统的下标方法 &lt;code>[]&lt;/code> 取用，但是这个方法不安全，不会进行边界检查。对 &lt;code>std::vector&lt;/code> 而言，可以通过 &lt;code>push_back()&lt;/code> 方法来将参数列表中的元素添加入容器的最后。当需要删除最后一个元素时，可以使用 &lt;code>pop_back()&lt;/code>。最后我们介绍这些 STL 容器都有的 &lt;code>iterator&lt;/code>，即迭代器。通过使用 &lt;code>begin()&lt;/code> 方法即可返回一个迭代器，这个迭代器的作用类似于指针，允许与整数做加减法，允许比较大小（第一个元素最小，最后一个最大）以及是否相等，而最后一个元素&lt;strong>再向后一个位置&lt;/strong>的迭代器为 &lt;code>end()&lt;/code>。因此，使用迭代器取用容器中的元素也是允许的。另外，使用迭代器比较时，建议尽量使用判断相等/不等，而非比较大小。因为有部分迭代器可能没有实现迭代器的大小比较。&lt;/p>
&lt;h2 id="c-简单计算案例传热方程">C++ 简单计算案例：传热方程
&lt;/h2>&lt;p>终于，经过漫长且枯燥的语法学习，我们终于可以看一些实际的问题，并尝试使用 C++ 来解决它们了。我们遇到的第一个案例，即为所谓的 Fourier 传热问题。&lt;/p>
&lt;h3 id="问题描述">问题描述
&lt;/h3>&lt;p>问题描述如下：&lt;/p>
&lt;blockquote>
&lt;p>问题：设现在有一个热源，其中心处在 x = 64 的位置，宽度为40，温度为1，再设整个模拟域的宽度为 128，且边界上采用固定边界条件，除了热源外的位置温度为 1。先在已知传热方程如下：
&lt;/p>
$$ \dfrac{\partial T}{\partial t} = \mu \dfrac{\partial^2 T}{\partial x ^2},$$&lt;p>
且在该问题中取 $\mu = 1$，求算该体系在上述方程下的演化过程。&lt;/p>&lt;/blockquote>
&lt;p>其中的偏微分方程即为所谓的 Fourier 传热方程的简化版，将每一点的热导率看作一个定值并将所有其他参数合并后称为 $\mu$。&lt;/p>
&lt;h3 id="问题拆解">问题拆解
&lt;/h3>&lt;p>分析该问题，我们拥有的信息十分完全，再根据已知的 Laplacian 算符和向前欧拉法，我们很快就能构建出该问题对应的 C++ 代码。我们采用 $\Delta x = 1$，$\Delta t = 0.2$ 的空间和时间步长以计算时空间导数，并使用向前欧拉法迭代演化出该体系的演化过程。代码层面，我们考虑使用最基础的面向过程方法，并且注意到边界判断时固定边界上的温度值为 0.0。&lt;/p>
&lt;h3 id="代码实现">代码实现
&lt;/h3>&lt;p>下面是我编写的一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;filesystem&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;fstream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">Nx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">dt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">mu&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nstep&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">20000&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// total iterate time
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">pstep&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// print result every 200 step
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="k">auto&lt;/span> &lt;span class="n">begin_time&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">high_resolution_clock&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">result_dir&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;./results/&amp;#34;&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">filesystem&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">create_directories&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result_dir&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Nx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">Nx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">44&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">84&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl"> &lt;span class="c1">// tempory mesh for value storage
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">temp_mesh&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mesh&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="c1">// ----- Begin Simulation ----- //
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">istep&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">istep&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nstep&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">istep&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">33&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">Nx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">34&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">im&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">35&lt;/span>&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">ip&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">36&lt;/span>&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">val_m&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="n">val_p&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mf">0.0&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">37&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">38&lt;/span>&lt;span class="cl"> &lt;span class="c1">// Fixed boundary condition (to 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">39&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">im&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">40&lt;/span>&lt;span class="cl"> &lt;span class="n">val_m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">41&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">42&lt;/span>&lt;span class="cl"> &lt;span class="n">val_m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">im&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">43&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">44&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Nx&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ip&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">45&lt;/span>&lt;span class="cl"> &lt;span class="n">val_p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">46&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">47&lt;/span>&lt;span class="cl"> &lt;span class="n">val_p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ip&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">48&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">49&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">50&lt;/span>&lt;span class="cl"> &lt;span class="n">temp_mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">mu&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dt&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">val_m&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">val_p&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mf">2.0&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">dx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">51&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">52&lt;/span>&lt;span class="cl"> &lt;span class="c1">// update the origin mesh
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">53&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">mesh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp_mesh&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">54&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">55&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">istep&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">pstep&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">56&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">of_name&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">result_dir&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;fixed_step_&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">istep&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;.csv&amp;#34;&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">57&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">ofstream&lt;/span> &lt;span class="n">ofs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">of_name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">58&lt;/span>&lt;span class="cl"> &lt;span class="c1">// if the file is indeed opened
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">59&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ofs&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">60&lt;/span>&lt;span class="cl"> &lt;span class="n">ofs&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\&amp;#34;&lt;/span>&lt;span class="s">pos&lt;/span>&lt;span class="se">\&amp;#34;&lt;/span>&lt;span class="s">&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;,&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\&amp;#34;&lt;/span>&lt;span class="s">val&lt;/span>&lt;span class="se">\&amp;#34;&lt;/span>&lt;span class="s">&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">61&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">Nx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">62&lt;/span>&lt;span class="cl"> &lt;span class="n">ofs&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;,&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">63&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">64&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">65&lt;/span>&lt;span class="cl"> &lt;span class="c1">// close the file after write
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">66&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">ofs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">67&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">68&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">69&lt;/span>&lt;span class="cl"> &lt;span class="c1">// ----- End Simulation ----- //
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">70&lt;/span>&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">71&lt;/span>&lt;span class="cl"> &lt;span class="k">auto&lt;/span> &lt;span class="n">end_time&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">high_resolution_clock&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">72&lt;/span>&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;The time cost in this simulation is &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">duration&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">end_time&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">begin_time&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">73&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">74&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里用到了一些技巧，在边界判断处使用下标运算是否越界来判断是否处于边界处，以及使用了 &lt;code>&amp;lt;chrono&amp;gt;&lt;/code> 库来监测程序运行时间。在成功运行并且用输出的 &lt;code>csv&lt;/code> 文件绘制曲线图后结果大致如下：&lt;/p>
&lt;p>&lt;img src="https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iii/heat_transfer_result.png"
width="500"
height="380"
srcset="https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iii/heat_transfer_result_hu_51db1d3192a486f.png 480w, https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iii/heat_transfer_result_hu_b3d78924e08641b6.png 1024w"
loading="lazy"
alt="传热方程求解结果"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>可以看到这个结果还是比较符合预期的。&lt;/p>
&lt;h2 id="结语">结语
&lt;/h2>&lt;p>太久不更新，写起来有些不是很得心应手。写完这些回头一看，我竟然写了这么多东西？C++ 的基础知识点比我想象的要多很多呀。如果您看到了这里，感谢您的支持。C++ 平心而论，好上手是真的，在了解一定的编程相关知识后很快就能写出一份能跑的代码。但是，C++ 的语法特性繁杂，内容过于丰富导致的则是 C++ 极高的进阶难度。几乎没有人敢说自己精通 C++，因为总有一些奇怪的点会出现在这门历史丰富且悠久的语言上，而恰好提问者知道但回答者不知道。不过好在，如果仅仅是为了使用 C++ 进行简单的高效计算，那么它的入门内容应该只需要上面这些又臭又长的介绍就差不多够了。在实际编程过程中，大多数的函数和类的 API 都是需要现查的，甚至有时候确实还需要面对 CV 编程（复制粘贴）。此外，不论任何编程语言，语言本身只能提供一些好用的特性，或者一些包装好了的算法轮子。实际在编程时最重要的问题是怎么分析问题，并且就这个问题设计出一套算法来解决问题。希望语言不会称为您的绊脚石。&lt;/p>
&lt;p>下一节我会正式采用 C++ 来实现在 Cahn-Hilliard 方程引导下调幅分解的相场（其实是浓度场）模拟。再下一节则会进行 Allen-Cahn 方程下的晶粒长大模拟，并作为这个入门系列的最后一部分。敬请期待。&lt;/p></description></item><item><title>Phase Field: 相场模拟学习笔记 II</title><link>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ii/</link><pubDate>Fri, 22 Nov 2024 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ii/</guid><description>&lt;img src="https://a-moment096.github.io/posts/PF_Tutorial/Skadi.png" alt="Featured image of post Phase Field: 相场模拟学习笔记 II" />&lt;p>&lt;em>接上一节内容, 这节会简单介绍 Python 的一些语法知识, 以及尝试使用 Python 实现上节所列出来的部分算法.&lt;/em>&lt;/p>
&lt;h2 id="python-初探索">Python 初探索
&lt;/h2>&lt;h3 id="简介">简介
&lt;/h3>&lt;p>Python 是一种蟒蛇, 而在编程语境下, Python 则是一门十分受欢迎的编程语言. Python 具有语法友好 (接近英语), 功能强大 (感谢开源与社区), 社区活跃等优秀的特点, 让 Python 成为入门编程的一个好选择.&lt;/p>
&lt;p>为什么选择 Python 来实现上节内容提到的算法呢? 主要原因有二: 一是 Python 的语法实在是太友好, 对于没有学习过或者对编程不甚了解的同学而言, 先尝试 Python 的话不容易因为语言的问题劝退. 相比于直接介绍下一节要讲的 C++, 先用 Python 熟悉一些编程中常见的概念也是有好处的. 其二可能是出于我个人的私心吧, 因为 Python 真的太好用了, 我个人而言希望能稍微做一些推广. 作为一门好用的工具语言, 它在很多情况下都可以帮助完成一些琐碎的工作. 特别是如画图, 我很喜欢用 Python 绘制函数图像之类, 非常好用.&lt;/p>
&lt;p>总之, 这里选择使用 Python 来作为程序的入门. 相信在通过 Python 了解一定的编程基础之后, 再去了解别的语言也不会显得那么吃力了 (比如, C++).&lt;/p>
&lt;h3 id="解释器安装与环境配置">解释器安装与环境配置
&lt;/h3>&lt;h4 id="python-解释器">Python 解释器
&lt;/h4>&lt;p>Python 的运行是需要其解释器的. 目前最新版的 Python 解释器可以直接在 &lt;a class="link" href="https://www.python.org/downloads/" target="_blank" rel="noopener"
>Python 官网&lt;/a> 下载. Linux 平台用户可以考虑使用各自发行版的包管理器实现 Python 的安装. 安装时请切记选择 &lt;strong>ADD TO PATH&lt;/strong>, 否则可能需要手动调整环境变量以让 Shell 能找到 Python.&lt;/p>
&lt;p>&lt;strong>解释器&lt;/strong>是什么? 简单来说, 就是&lt;em>逐行&lt;/em>把写的脚本翻译为机器所能理解的代码指令, 然后执行. 所以 Python 是逐行运行的, 这点非常适合 Debug, 也许也是 Python 受人欢迎的原因之一. 与&lt;strong>解释器&lt;/strong>相对的一个概念是&lt;strong>编译器&lt;/strong>. 这里所指的编译器应该是狭义上的编译器, 广义上的编译器应该也包含 Python 这类的解释器. 编译器不会逐行解释代码, 而是将代码作为一个整体, 然后处理翻译, 最后形成机器能阅读并执行的内容后进行执行. 这种方式让编译器可以为代码做出很多的优化, 但是也一定程度上牺牲了 &amp;ldquo;逐行运行&amp;rdquo; 的便利. C/C++, Rust 等语言都是需要编译器进行编译的. 为了弥补无法原生逐行运行的缺陷, 这些语言使用了调试器 (Debugger) 以及调试符号 (Debug Symbol) 等技术来在编译完成后, 根据符号表一一对照并运行代码, 呈现出逐行运行的效果. 然而这种方法依旧会损失一定的运行性能.&lt;/p>
&lt;p>Python 解释器拥有多个版本, 每个版本对语言的语法都有一定的调整. 有些调整影响巨大 (比如从 Python2 到 Python3 的转变), 另一些可能因为其语法特性不常用, 不会直接影响到用户体验. Python 解释器也不一定是最新版就最好, 需要考虑项目的适配以及对应包的版本需求. 不过在这里我们并不太依赖 Python 解释器的版本, 只要保证是比较新的 Python 解释器版本, 并且主流的科学计算库, 如 &lt;code>numpy&lt;/code>, &lt;code>matplotlib&lt;/code>, &lt;code>scipy&lt;/code> 等即可.&lt;/p>
&lt;h4 id="编辑器-与-visual-studio-code">编辑器 与 Visual Studio Code
&lt;/h4>&lt;p>在安装好 Python 解释器之后其实就已经可以开始 Python 编程了 (没错, 就是传说中的记事本编程). 然而这当然不是最好的方法, 这种方法光是考虑到没有代码高亮就让人很难以接受了. 这里我个人推荐 Visual Studio Code (以下简称 VSC).&lt;/p>
&lt;p>VSC 功能强大, &lt;a class="link" href="https://code.visualstudio.com/" target="_blank" rel="noopener"
>安装&lt;/a>方便, 插件生态极其丰富, 通过合理的配置近乎可以达到 IDE (Integrated Development Environment, 集成开发环境) 的水平. 我个人在写简单的 Python 脚本时几乎都是使用 VSC 写的. 一路默认安装后, 根据需要安装中文插件, 然后再在插件页面搜索 Python 即可安装 Python 插件全家桶, 然后就可以开始使用 VSC 写 Python 代码 (脚本)了. VSC 的安装与环境配置也可以参考我之前写的&lt;a class="link" href="https://a-moment096.github.io/p/python--vscode-%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/" >博客文章&lt;/a>.&lt;/p>
&lt;p>这里没有推荐 IDE, 因为 IDE 对这里仅仅使用 Python 做一些简单应用而言太过 &amp;ldquo;全能&amp;rdquo;, 或者说, 负担太重. 当然, 如果感兴趣, 可以考虑使用大名鼎鼎的 PyCharm. 这里不再赘述.&lt;/p>
&lt;h4 id="虚拟环境-venv-和-pip">虚拟环境, venv 和 pip
&lt;/h4>&lt;p>这里简单介绍一下虚拟环境. 因为 Python 的生态丰富, 可能会碰到某些依赖相互冲突的情况, 尤其是在多人共同开发的情况下, 每个人的开发环境配置不同, 很容易导致依赖冲突. 为解决这种情况, 可以考虑使用 Python 的虚拟环境 &lt;code>virtualenv&lt;/code>. 创建的虚拟环境下有该虚拟环境所自有的一些包, 并且和该虚拟环境以外的部分是相互独立的. 使用 VSC 创建 &lt;code>virtualenv&lt;/code> 虚拟环境非常简单, 只需要 &lt;code>Ctrl+Shift+P&lt;/code> 打开 VSC 的命令, 然后搜索 &lt;code>Python: Create Environment&lt;/code> 即可根据向导一步步搭建虚拟环境.&lt;/p>
&lt;p>搭建好的虚拟环境会存放在 &lt;code>.venv&lt;/code> 的文件夹中. 这里面将会包含所有该虚拟环境的内容, 包括在该虚拟环境下安装的各种包. 如果不想再使用该虚拟环境, 只需要删除该文件夹即可. VSC 会自动检测是否存在虚拟环境, 并且自动切换到虚拟环境下. 如果您使用 Shell, 可以手动在命令行中运行 &lt;code>.venv&lt;/code> 文件夹内的 &lt;code>acitvate&lt;/code> 脚本 (Windows 在子文件夹 &lt;code>Scripts&lt;/code> 中, Linux 则一般在 &lt;code>bin&lt;/code> 子文件夹中), 即可启动该虚拟环境.&lt;/p>
&lt;p>在搭建好虚拟环境 (或者不使用虚拟环境) 之后, 需要从网上下载需要的包来帮助 Python 脚本的运行, 实现各种功能. 这时就需要用到&lt;em>包管理器&lt;/em>. Python 默认的包管理器为 &lt;code>pip&lt;/code>, 使用 &lt;code>pip&lt;/code> 安装或者更新包都十分简单, 以安装 &lt;code>matplotlib&lt;/code> 举例, 输入命令 &lt;code>pip install matplotlib&lt;/code> 即可. 要更新包, 则使用 &lt;code>pip install --upgrade matplotlib&lt;/code> 就可以. 如果有一份使用 &lt;code>pip freeze&lt;/code> 所生成的软件包列表 (一般该列表文件名为 &lt;code>requirements.txt&lt;/code>), 则可以使用命令 &lt;code>pip install -r requirements.txt&lt;/code> 即可根据该列表中的内容进行安装.&lt;/p>
&lt;h3 id="python-语法基础">Python 语法基础
&lt;/h3>&lt;p>上面的废话可能有点多了, 下面就介绍 Python 最主要的语法点, 作为使用 Python 的基础, 同时提出一些编程语言中所拥有的共性:&lt;/p>
&lt;h4 id="类型">类型
&lt;/h4>&lt;p>虽然 Python 是一门动态类型的语言, 数据在 Python 中是根据上下文做出类型判断的, 然而这里还是简单介绍一下 Python 中常用的变量类型. 其中最常用的就是一些基础类型, 如 &lt;code>int&lt;/code>, &lt;code>float&lt;/code>, &lt;code>str&lt;/code>, &lt;code>bool&lt;/code> 等, 它们分别代表&lt;em>整数&lt;/em>, &lt;em>浮点数&lt;/em>, &lt;em>字符串&lt;/em>, &lt;em>布尔值&lt;/em>. 这些类型是 Python 所天然支持的, 也是一般语言中常常原生支持的类型. 除了这些基础类型外, 还有很多的组合类型, 如 &lt;code>List&lt;/code> (列表), &lt;code>Dict&lt;/code> (字典), &lt;code>Tuple&lt;/code> (元组) 等等. 这些类型通常是由一些基础类型所产生, 比如列表, 就是由不同类型的内容组合在一起形成的类似于容器的数据结构.&lt;/p>
&lt;p>Python 中的类型通常其本身也是一个&lt;em>类&lt;/em> (&lt;code>class&lt;/code>), 意味着它们也有一些成员函数可以进行操作. 这里就不详细叙述了.&lt;/p>
&lt;p>此外, 尽管 Python 是动态类型语言, 其依旧支持对类型的标注. Python 采取后置类型标记方法, 在变量的后面添加 &lt;code>:&lt;/code> 然后跟上对应的类型名即可标注其类型. 值得注意的是, 尽管有了类型标注, 这个标注更应该作为仅对程序开发者或使用者的提示, 这里标注的任何类型&lt;em>都没有任何的约束力&lt;/em>.&lt;/p>
&lt;h4 id="变量声明">变量声明
&lt;/h4>&lt;p>Python 的变量声明非常简单, 只需要遵循 &lt;code>name = value&lt;/code> 的规则即可声明并初始化一个变量. 顺带一提, Python 中变量的赋值也是同样的语法, 而 Python 中的变量又具有唯一的名称, 因此在使用 &lt;code>name = value&lt;/code> 的语句时, 如果前面已经声明了 &lt;code>name&lt;/code> 这个变量, 则会直接使用新的值覆盖掉原有的值. 而且由于是动态类型语言, 这里不会因为类型不匹配而报错. 因此你可以随时让一个变量拥有别的类型. 这一点十分灵活, 尤其是在确定某个变量的值不再使用, 而该变量的名称又很适合用作下一个值的名称时, 即可立刻覆盖掉原有的值.&lt;/p>
&lt;h4 id="作用域">作用域
&lt;/h4>&lt;p>编程语言中常常拥有&lt;em>作用域&lt;/em>这一概念. 这个概念可以认为是为了约束变量的生存周期而存在的. 一般而言, 一个变量的作用域在没有特殊声明的情况下, 只能对自己所在的区域以及该区域下的子区域可见.&lt;/p>
&lt;p>Python 这门语言其中的一个特别之处就在于, Python 的作用域划分是通过缩进完成的. 当代码顶格写成时, 这些语句的作用域即为全局作用域. 而如果有代码需要在某个作用域内时 (比如, 定义的函数内, &lt;code>for&lt;/code> 循环中, 条件判断中), 则需要使用冒号 &lt;code>:&lt;/code> 打开一个新的子区域, 然后使用缩进去标识哪些部分是属于该作用域的. 这一点褒贬不一, 有人认为这个方法很简洁, 避免了过多的符号; 也有人认为这种风格让 Python 的代码逻辑可能不清晰, 造成阅读困难. 但是, 无论如何, Python 的作用域是这样通过缩进定义的. 那么, 在上一层的作用域中所定义的变量对下一级的子作用域是可见的, 而子作用域内定义的变量会在程序脱离该作用域之后消失, 因此子作用域的变量对外部是不可见的. 这一点几乎是所有编程语言所通用的.&lt;/p>
&lt;p>举个例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="n">outside&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="n">inside&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">outside&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl">&lt;span class="c1"># 下面这句会报错, 找不到定义. 因为在前面离开作用域的时候, inside就被回收然后消失了.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="c1"># print(inside) &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>if&lt;/code> 就开启了一个新的子作用域, 其中定义的变量 &lt;code>inside&lt;/code> 在外面是看不到的, 而其中是可以看到 &lt;code>outside&lt;/code> 变量的.&lt;/p>
&lt;h4 id="控制流-循环和判断语句">控制流, 循环和判断语句
&lt;/h4>&lt;p>Python 中可以使用 &lt;code>for&lt;/code> 循环, &lt;code>while&lt;/code> 循环以及其他的循环. 其中, &lt;code>for&lt;/code> 循环比较特殊, 只能在某个范围内循环, 而这个循环需要是 &lt;em>iterable&lt;/em> 的. 这个所谓的 iterable 可以翻译为&lt;em>可迭代的&lt;/em>, 比如 &lt;code>range&lt;/code> 函数所生成的范围, 一个 List, 一个 Tuple 等等. 其语法为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">iterable&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="c1"># And something more&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="c1"># Here is not inside the for loop.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的 &lt;code>i&lt;/code> 会从 &lt;code>iterable&lt;/code> 的第一个元素开始, 每过一个循环体便会让 &lt;code>i&lt;/code> 变成 &lt;code>iterable&lt;/code> 中的下一个元素, 直到 &lt;code>iterable&lt;/code> 中的元素被取完. 而 &lt;code>while&lt;/code> 循环则比较简单, 只要判断条件为真则一直循环, 当检测到条件为假时则终止循环. 语法为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">something_is_true&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="c1"># And something more&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="c1"># Here is not inside the while loop.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以一般而言, 使用 &lt;code>while&lt;/code> 循环时需要在循环体中让循环条件在某时不满足, 以跳出循环.&lt;/p>
&lt;p>Python 中的判断语句是较为通用的形式, 这里只介绍 &lt;code>if else&lt;/code> 循环:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">something_might_be_true&lt;/span> &lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="k">elif&lt;/span> &lt;span class="n">something_might_also_be_true&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do another thing&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="c1"># No other condition is satisfied&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">7&lt;/span>&lt;span class="cl">&lt;span class="c1"># Not in condition &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其语法也是十分的简单. Python 还支持一行式的判断, 可以对标 C/C++ 的三元表达式:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="n">do_something&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">condition_is_true&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">do_other_things&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个语法非常贴近英语语法, 且避免了难以理解的三元表达式. 但为了代码结构清晰, 请尽量使用完整的 &lt;code>if else&lt;/code> 判断语句.&lt;/p>
&lt;h4 id="函数">函数
&lt;/h4>&lt;p>函数是众多编程语言的一大组成部分. Python 由于对类型不敏感, Python 的函数定义非常地简单:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">Some_function&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">parameter_1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parameter_2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parameter_with_init_value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">init_value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do other things&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">some_value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>像这样就能成功地定义了一个函数. 其中 &lt;code>Some_function&lt;/code> 为函数名, 其本身也是一个变量, 所以在重新定义时实际上是为这个变量赋了新的值.&lt;/p>
&lt;p>&lt;code>parameter*&lt;/code> 即为函数参数, 这些参数名将用作外界参数传入函数内时使用的占位符, 并且这些参数名将用在函数体内部. 且其中最后一个参数 &lt;code>parameter_with_init_value&lt;/code> 是具有默认值的参数, 其默认值为 &lt;code>init_value&lt;/code>. 具有默认值也就意味着这个函数可以不传入这个参数以代表传入默认参数. 在向函数传参时, 可以按照函数参数的顺序传入参数, 也可以显式地指明某个参数的值是什么, 如 &lt;code>Some_function(parameter_2 = 1, parameter_1 = 3)&lt;/code> 这种写法是合法的.&lt;/p>
&lt;p>最后的 &lt;code>return&lt;/code> 代表返回的值. 所谓返回值, 可以认为是函数运算的结果. 这个结果需要手动通过 &lt;code>return&lt;/code> 关键字指定, 这里使用了变量 &lt;code>some_value&lt;/code> 作为占位符.&lt;/p>
&lt;p>函数除了便于代码复用之外, 还可以让代码结构更加清晰, 以及控制一段逻辑的&lt;em>输入-输出&lt;/em>结构. 这里不介绍 &lt;em>lambda&lt;/em> 表达式, 这是一类匿名函数, 没有函数名, 但是具有函数的功能 (参数列表, 返回值), 即便目前大部分编程语言已经支持这一特性.&lt;/p>
&lt;h3 id="python-面向对象-numpy-matplotlib">Python 面向对象, numpy, matplotlib
&lt;/h3>&lt;p>这里简单介绍一些进阶的语言特性, 以及展示两个常用包的使用.&lt;/p>
&lt;h4 id="面向对象与类">面向对象与类
&lt;/h4>&lt;p>面向对象是目前十分热门的编程范式, 其通过将数据以及对数据的操作等打包为一个&lt;em>对象&lt;/em>, 从而实现对数据的统筹管理. 而为了实现面向对象, 就需要某种方式实现这种打包, 这一方法即为所谓的&lt;em>类&lt;/em> (class). 各个语言对面向对象的实现均有其特点, 在 Python 中对类的声明与定义语法如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">some_class&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">param_1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">param_2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">param_default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">default_val&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Define class members&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">member_1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">param_1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">member_2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">param_2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">some_member&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">param_default&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something, just like in a function&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">do_something&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">do_something&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do something&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl">&lt;span class="c1"># End of definition&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl">&lt;span class="n">my_variable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">some_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">val_1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">val_2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl">&lt;span class="c1"># Use Inheritance from some_class&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">derived_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">some_class&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sub_para&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">default&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Must call parent class&amp;#39;s __init__ method to avoid overwritting __init__ of parent class.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl"> &lt;span class="n">some_class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">para_default&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sub_member&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sub_para&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sub_class_method&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">sub_class_method&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="c1"># Do sub_class things&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl">&lt;span class="n">my_sub_variable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">derived_class&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到, Python 可以通过定义 &lt;code>__init__&lt;/code> 函数来定义类里面都有什么成员变量, 并且调用一些成员函数. 定义成员函数时语法同定义普通函数别无二致, 而在调用类中的内容时需要使用关键字 &lt;code>self&lt;/code>. 并且在使用类定义变量时, 直接可以通过类的名称来作为函数名并传入 &lt;code>__init__&lt;/code> 函数中规定的参数即可调用成员函数 &lt;code>__init__&lt;/code>. 最后这里要提到的是, Python 的类成员访问控制符通过变量的名字进行控制, 如双下划线代表成员是&lt;em>私有&lt;/em> (private) 的, 单下划线代表成员是&lt;em>保护&lt;/em> (protect) 的, 而其余普通名称则为&lt;em>公开&lt;/em> (public) 的.&lt;/p>
&lt;p>所谓私有成员, 即只有该类内部可以使用的成员变量或方法. 这些变量或方法在类外是不可见的. 而所谓保护成员则是只在类内部以及&lt;em>子类&lt;/em> (派生类) 内部可以使用的成员, 公开成员即为没有访问限制的成员, 无论是外部还是内部都可以取得. 使用访问控制可以控制 &amp;ldquo;谁能取到类内的数据&amp;rdquo;, 从而保护数据不会被意外读取或者篡改. 对访问控制的理解也决定着对面向对象范式的理解.&lt;/p>
&lt;p>然而我们这里并不对面向对象做要求 (主要是我也不太懂 Python 的面向对象), 这里就仅作一个介绍, 并使用其最基础的部分而已.&lt;/p>
&lt;h4 id="包-numpy-matplotlib">包, numpy, matplotlib
&lt;/h4>&lt;p>Python 最强大的部分当属其活跃的社区所贡献的大量好用的包. 为了实现科学运算, 常用的数学库即为 &lt;code>numpy&lt;/code>, 而画图则有 &lt;code>matplotlib&lt;/code>. 这里大概介绍二者的基础使用.&lt;/p>
&lt;p>为了引入包, 需要使用关键字 &lt;code>import&lt;/code>. 通常, 为了使用 &lt;code>numpy&lt;/code> 与 &lt;code>matplotlib&lt;/code>, 有如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="c1"># from matplotlib import pyplot as plt&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>底下注释的内容和上一行内容的功能相同. 可以看到使用 &lt;code>as&lt;/code> 关键字可以为包引入别名, 而为了导入子模块可以使用 &lt;code>from&lt;/code> 关键字, 也可以直接 &lt;code>.&lt;/code> 出来并引入.&lt;/p>
&lt;p>首先介绍 &lt;code>numpy&lt;/code> 的一些使用. &lt;code>numpy&lt;/code> 主要提供了一种数据结构: &lt;code>numpy.array&lt;/code>, 这种结构可以用来存储数组, 矩阵等数学对象, 且支持对其进行遍历, 切片以及常见数学运算等操作; &lt;code>numpy.array&lt;/code> 可以通过 Python 原生的 &lt;code>List&lt;/code> 来初始化一个数组. 对于尺寸相符的数组, 可以进行加减乘除等运算, 包括数组间运算, 数组与标量运算等, 非常方便. 除此之外, &lt;code>numpy&lt;/code> 还提供了大量的数学函数以供使用, 比如 &lt;code>numpy.exp&lt;/code>, &lt;code>numpy.sin&lt;/code> 等, 以及对文件的一些操作, 将文件中的数据加载为 &lt;code>numpy.array&lt;/code>.&lt;/p>
&lt;p>然后介绍 &lt;code>matplotlib.pyplot&lt;/code>, 这是一个绘制图形的库, 通常与 &lt;code>numpy&lt;/code> 搭配使用, 可以高质量地将数据可视化. 下面举一个绘制 $y = sin(2x)+1$ 的图像的例子, 作为 &lt;code>numpy&lt;/code> 以及 &lt;code>matplotlib&lt;/code> 的应用.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">matplotlib&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">linspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;-b&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;$y = \sin(2x)+1$&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">xlabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;x&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ylabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;y&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">legend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码首先定义了一个从 $0$ 开始到 $2\pi$ 结束的, 总数据量为 10000 的一个 &lt;code>numpy.array&lt;/code> 并命名为 &lt;code>x&lt;/code>, 然后使用 &lt;code>x&lt;/code> 通过运算定义了名为 &lt;code>y&lt;/code> 的数组, 最后使用 &lt;code>matplotlib.pyplot.plot&lt;/code> 函数进行绘制并进行图像处理. 可以看到 &lt;code>matplotlib&lt;/code> 是支持 $\LaTeX$ 语法的.&lt;/p>
&lt;p>Python 还有海量的包可以调用, 大多数都拥有友好的 API 且易于上手. 这里就不再赘述.&lt;/p>
&lt;h3 id="算法实现">算法实现
&lt;/h3>&lt;p>Python 的基础语法以及进阶语法先告一段落. 接下来会演示上一章节内容所展示的算法如何使用 Python 进行实现. 要实现的算法如下:&lt;/p>
&lt;ul>
&lt;li>向前欧拉法&lt;/li>
&lt;li>数值积分方法&lt;/li>
&lt;li>有限差分法求梯度与拉普拉斯&lt;/li>
&lt;/ul>
&lt;h4 id="向前欧拉法">向前欧拉法
&lt;/h4>&lt;p>向前欧拉法的实现主要依赖于其显式公式部分. 设待求 ODE 为:
&lt;/p>
$$
\dfrac{\partial y}{\partial x} = F(x, y),
$$&lt;p>
且解满足初值 $(x_0, y_0)$, 要求求解范围为 $[x_0, x_t]$, 则根据向前欧拉法, 选择合适的步长 $\Delta x$ 后, 有:
&lt;/p>
$$
y_{n+1} = y_{n} + \Delta x \cdot F(x_n, y_n)
$$&lt;p>因此, 为了实现这一算法, 该算法实现的函数有如下几点:&lt;/p>
&lt;blockquote>
&lt;p>接收参数:&lt;/p>
&lt;ul>
&lt;li>$x$ 轴的离散信息 (初始位置, 结束位置, 步长)&lt;/li>
&lt;li>解的初始值 $y_0$&lt;/li>
&lt;li>ODE 右端的函数 $F(x,y)$ 的显式表达&lt;/li>
&lt;/ul>
&lt;p>返回值:&lt;/p>
&lt;ul>
&lt;li>一个数组, 作为解得的 $y$ 的函数值&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>则有如下 Python 实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">typing&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Callable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">forwardEuler&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="n">x_0&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="n">y_0&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">F_x_y&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">y_0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">this_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x_0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="n">this_y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y_0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">this_x&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="n">this_y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this_y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">F_x_y&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">this_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">this_y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">this_y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="n">this_x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数值积分">数值积分
&lt;/h4>&lt;p>数值积分的实现同样比较简单, 分析该算法的输入输出如下:&lt;/p>
&lt;blockquote>
&lt;p>接收参数:&lt;/p>
&lt;ul>
&lt;li>$x$ 轴的离散信息 (初始位置, 结束位置, 步长)&lt;/li>
&lt;li>被积函数&lt;/li>
&lt;/ul>
&lt;p>返回值:&lt;/p>
&lt;ul>
&lt;li>一个数, 作为积分值&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>根据不同的积分算法, 可以有多种不同的实现. 下面实现四种算法: &amp;ldquo;黎曼&amp;quot;式积分法, 梯形公式, Simpson 公式, Newton-Cotes 公式.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">typing&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Callable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">RiemannIntegral&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">x_start&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x_start&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">sum&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">QuadratureIntegral&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">x_start&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x_start&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_start&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_end&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">sum&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">SimpsonIntegral&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl"> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">x_start&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x_start&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">33&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">34&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">35&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_start&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_end&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">36&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">sum&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">37&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">38&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">39&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">N_C_Integral&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">40&lt;/span>&lt;span class="cl"> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">x_start&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">41&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">42&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">43&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x_start&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">44&lt;/span>&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">x_end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">45&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">32&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">46&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">12&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">47&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">32&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">48&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">14&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">49&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">dx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">50&lt;/span>&lt;span class="cl"> &lt;span class="nb">sum&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_start&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x_end&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">51&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">sum&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">90&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="梯度与拉普拉斯">梯度与拉普拉斯
&lt;/h4>&lt;p>这里针对二维情况进行计算. 同上, 考虑算法的输入输出:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>梯度:&lt;/p>
&lt;blockquote>
&lt;p>输入&lt;/p>
&lt;ul>
&lt;li>待计算网格(二维列表)&lt;/li>
&lt;li>网格步长&lt;/li>
&lt;li>边界条件字段 (这里固定为周期边界以便实现)&lt;/li>
&lt;/ul>
&lt;p>输出&lt;/p>
&lt;ul>
&lt;li>两个二维列表, 分别为对 $x$ 方向的梯度和对 $y$ 方向的梯度&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>拉普拉斯&lt;/p>
&lt;blockquote>
&lt;p>输入&lt;/p>
&lt;ul>
&lt;li>同上&lt;/li>
&lt;/ul>
&lt;p>输出&lt;/p>
&lt;ul>
&lt;li>一个二维列表, 存储每个网格点的拉普拉斯&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>以下是代码实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">calc_grad&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl"> &lt;span class="n">mesh&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]],&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">boundary&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Periodic&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">tuple&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]],&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]]]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl"> &lt;span class="n">Nx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mesh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">Ny&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl"> &lt;span class="n">grad_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="n">grad_y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Nx&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Ny&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">v_l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">v_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="n">v_r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="n">v_u&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">14&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">boundary&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;Periodic&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">15&lt;/span>&lt;span class="cl"> &lt;span class="n">v_l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">16&lt;/span>&lt;span class="cl"> &lt;span class="n">v_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">Ny&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">17&lt;/span>&lt;span class="cl"> &lt;span class="n">v_r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">18&lt;/span>&lt;span class="cl"> &lt;span class="n">v_u&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">19&lt;/span>&lt;span class="cl"> &lt;span class="c1"># elif (boundary == &amp;#34;Fixed&amp;#34;):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">20&lt;/span>&lt;span class="cl"> &lt;span class="c1"># XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">21&lt;/span>&lt;span class="cl"> &lt;span class="n">grad_x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v_r&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">v_l&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">22&lt;/span>&lt;span class="cl"> &lt;span class="n">grad_y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v_u&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">v_d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">23&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">grad_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">grad_y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">24&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">25&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">calc_laps&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">26&lt;/span>&lt;span class="cl"> &lt;span class="n">mesh&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]],&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">boundary&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Periodic&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">27&lt;/span>&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">28&lt;/span>&lt;span class="cl"> &lt;span class="n">Nx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mesh&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">29&lt;/span>&lt;span class="cl"> &lt;span class="n">Ny&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">30&lt;/span>&lt;span class="cl"> &lt;span class="n">laps&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">31&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Nx&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">32&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Ny&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">33&lt;/span>&lt;span class="cl"> &lt;span class="n">v_l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">34&lt;/span>&lt;span class="cl"> &lt;span class="n">v_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">35&lt;/span>&lt;span class="cl"> &lt;span class="n">v_r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">36&lt;/span>&lt;span class="cl"> &lt;span class="n">v_u&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">37&lt;/span>&lt;span class="cl"> &lt;span class="n">v_c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">38&lt;/span>&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">boundary&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;Periodic&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">39&lt;/span>&lt;span class="cl"> &lt;span class="n">v_l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">40&lt;/span>&lt;span class="cl"> &lt;span class="n">v_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">Ny&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">41&lt;/span>&lt;span class="cl"> &lt;span class="n">v_r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">42&lt;/span>&lt;span class="cl"> &lt;span class="n">v_u&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">Nx&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">mesh&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">43&lt;/span>&lt;span class="cl"> &lt;span class="c1"># elif (boundary == &amp;#34;Fixed&amp;#34;):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">44&lt;/span>&lt;span class="cl"> &lt;span class="c1"># XXX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">45&lt;/span>&lt;span class="cl"> &lt;span class="n">laps&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v_l&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">v_d&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">v_r&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">v_u&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">v_c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">dx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">46&lt;/span>&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">laps&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此, 我们使用 Python 实现了我们将在相场模拟中使用的大部分算法. 具体的模拟过程中, 我们可能不需要用函数的方式将这些算法打包起来, 只需要直接实现即可.&lt;/p>
&lt;h3 id="总结">总结
&lt;/h3>&lt;p>这部分内容希望能对上一章节中的算法内容有更进一步的补充, 并且希望能对算法如何实现为代码的过程起到促进理解的作用. 同时, 希望这里介绍的 Python 能成为您日常学习生活中的另一件有利工具, 并且能对编程这门技术有一定的入门理解, 为后续的程序编写提供基本的认识. 下一章节将会介绍如何使用 C++ 来实现这些算法, 并使用 C++ 完成一个小型的模拟, 尝试从这个小型模拟中了解模拟过程中会面临的问题, 以及数据最后的可视化方法.&lt;/p></description></item><item><title>Baby Rudin 读后感</title><link>https://a-moment096.github.io/p/baby-rudin-%E8%AF%BB%E5%90%8E%E6%84%9F/</link><pubDate>Fri, 01 Nov 2024 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/baby-rudin-%E8%AF%BB%E5%90%8E%E6%84%9F/</guid><description>&lt;img src="https://a-moment096.github.io/p/baby-rudin-%E8%AF%BB%E5%90%8E%E6%84%9F/yoyoko.jpeg" alt="Featured image of post Baby Rudin 读后感" />&lt;p>&lt;em>本文写于9月22日，因为这是我读完的第一本数学专业的书，故而感觉很有必要记下来点什么，于是就有了这么一篇流水账。作为 Mathematics 部分的
第一篇博文正是再好不过&lt;/em>&lt;/p>
&lt;p>&lt;em>Principles of Mathematical Analysis&lt;/em>, Walter Rudin (May 2, 1921 – May 20, 2010)
所写的一本“ &lt;a class="link" href="https://www.zhihu.com/question/559683007/answer/3502165974" target="_blank" rel="noopener"
>适合于高年级本科生或数学系一年级学生&lt;/a> ”
的数学分析
教材, 因其作为 Rudin 所著的三本分析学教材 (另外两本为 &lt;em>Real and ComplexAnalysis&lt;/em> 与
&lt;em>Functional Analysis&lt;/em>) 中最“小”的一本，故而得名 Baby Rudin (另外
两本也被分别称为 &lt;em>Papa/Big Rudin&lt;/em> 与 &lt;em>Grandpa Rudin&lt;/em>), 作为我在课外自己读完
(但几乎什么题都没写) 的第一本数学专业书, 在断断续续读了一年多以后终
于读完了. 说来惭愧, 本来是适合本科生的数学书, 却是拖到了研二才读完, 还
好我不是数学专业的. 本人作为一个门外汉, 抱着喜悦的心情, 简单分享下自
己读后的感想.&lt;/p>
&lt;p>即便从大三以后随着兴趣瞎读了很多数学书, 在我看来我“认真读过”的
数学书也许也只有&lt;em>微积分学教程&lt;/em> (菲赫金哥尔茨著), &lt;em>Algebra: Chapter 0&lt;/em> (Paolo
Aluffi 著) , &lt;em>An Introduction to Manifolds&lt;/em> (Loring W. Tu 著) 以及这本&lt;em>Baby Rudin&lt;/em>.
除此之外的书几乎都是简单翻阅过, 并没有细看. Thomas W. Hungerford 所写
的大名鼎鼎的 &lt;em>GTM 73&lt;/em> 我虽然想过仔细阅读, 但是还是没有坚持下来. 到头来
唯有这本 &lt;em>Baby Rudin&lt;/em> 是从头到尾几乎处处的看完了 (这里指除了至多可数个
的习题). 不过这些翻阅过的书也算是给了我一些勇气和底气, 让我去对一本
数学专业教材评头论足.&lt;/p>
&lt;p>这本书处处体现着“惜墨如金”四个字, 而且不似其他很多作者那般喜欢
使用比较形式化的语言 (比如, 用一些记号, 如$\left( X, A, \mu \right)$三元组来表示度量空
间), 反而对符号的使用相当克制. 最令我惊讶的是, 直到最后一章的第三小
节, Rudin 才引入了用代表元来表示集合的记号 $\\{ x \vert P \\}$ . 虽然分析学也许并不
会像代数学那样大量使用元素性质各异的各类集合, 但能把这么常用的符号
放到这么后面才介绍, 也许的确称得上是“惜字如金”. 不过换个角度来讲, 也
许也正是不过多借助符号, 反而更多采用文字描述的方式介绍数学概念, 这
本 &lt;em>Baby Rudin&lt;/em> 才会有其独特的魅力.&lt;/p>
&lt;p>这本书的内容编排上, 在我看来也与众不同. 这本书在构造实数的过程
中, 捎带手把复数一并处理了, 甚至还在第一章末尾专门单开了一个部分用
来从头到尾地叙述实数的构造. 随后第二章也并没有急于引入数列或者极限,
而是这时才引入函数这一概念, 再在集合和函数的基础上讲起点集拓扑, 而
且 “limit” 一词也是作为点集拓扑中的 “极限点 (limit points)” 出现的, 而非传
统的序列极限引入. 这里还要提一嘴, “Topology” 这个词全文中只在标题和
两处提到拓扑学的三角剖分的句子中出现了, 而在主讲拓扑的第二章正文中
更是一次也没有出现过. 第二章中没有拓扑一词, 但却通过引入距离 (度量)
而切实地讨论了对分析学而言更有意义的拓扑空间, 实在是很新奇的阅读体
验. 拓扑概念的引入对后续的内容有极大的影响. 提前引入拓扑语言的好处
在于能更细致地刻画拓扑与分析学之间的关系. 如后面函数的连续性一章,
就积极地引入了 “开集的原像是开集” 这个与传统连续性定义等价的描述.&lt;/p>
&lt;p>在做完数域, 拓扑等概念的铺垫后, 迎接读者的不仅是数列这一常见的
用以引入函数极限的概念, 还顺势加入了级数的介绍. 这与许多教材将级数
等内容放置于教材内容偏后位置的做法不同, 不仅更早引入收敛, 而且更好
地联系起了“序列极限”与 “无穷级数”两者, 并立刻用到上一章所介绍的拓扑
概念, 给出了完备性与序列之间的关系.&lt;/p>
&lt;p>在微积分的三大部分(微分, 积分, 函数序列/级数)中, 最具特色的地方
当属函数积分在简单引入黎曼积分后, 更广泛地讨论黎曼-斯蒂尔切斯积分
(Riemann-Stieltjes Integration), 以及由于拓扑, 完备等内容的引入而讨论的完
备函数空间等. 常见教材经常会更多地讨论黎曼积分的性质, 并在靠后的内
容中直接引入勒贝格积分. 而本书则在定义了黎曼积分后直接给出了更加广
泛的黎曼-斯蒂尔切斯积分, 并更多地讨论它的性质. 而且归功于度量, 完备性
等的引入, 函数序列/极限部分还讨论了函数空间的拓扑性质, 且这一部分最
后的 Stone-Weierstrass 定理更是提出了从多项式逼近函数, 从一些代数的角
度研究了多项式空间和函数空间, 这些特点无不令我大开眼界.&lt;/p>
&lt;p>而在讨论完这些微积分的常见内容后, Rudin终于决定讲一些常见的, 比
较特殊的函数 (不是&lt;em>特殊函数论&lt;/em>的特殊函数). 最有趣的应该是三角函数的定
义并没有采用常见的定义方式, 而是积极使用了本书中早早提到的复数/复变
函数, 采用复指数函数的方式定义了三角函数, 用意想不到的方式给出了𝜋的
定义, 然后告诉读者我们现在处在一个可以简单证明复数域代数完备性的位
置上, 并用约一页的篇幅证明了这个著名的定理.&lt;/p>
&lt;p>多变量函数部分最让我印象深刻的是解决了我一个长久以来的疑问: 多
变量函数的&lt;em>导数&lt;/em>(非偏导数)到底是什么? Rudin 在引入线性映射这一和微积
分看似联系不大的概念后, 给出了多变量函数求导的结果: 一个 $\mathbb{R}^n$ 到 $\mathbb{R}^n$ 的
线性映射! 这一结果让我对数学概念推广的认知更进了一步. 除了这点令我
如醍醐灌顶的部分外, 其余部分就显得有点晦涩难懂了. 特别是在隐函数定
理和秩定理两部分, Rudin的证法在我看来无疑是天书. 最后还是在互联网的
帮助下似懂非懂, 逃离了这部分.&lt;/p>
&lt;p>最后两章算是一般数学分析教材的 One More Thing 部分, 微分形式上的
积分以及勒贝格积分. 微分形式上的积分在没有流形工具的辅助下显得有点
苍白, 但作为对多变量函数和向量值函数积分的补充部分, Stokes’ 定理给出
的结论还是一如既往的优美. 而勒贝格积分 (Lebesgue Integration) 的内容总
算是让我知道了鼎鼎大名的勒贝格积分与黎曼积分之间的异同. 勒贝格积分
部分的最后引入的 $\mathcal{L}^2$ 空间部分也解答了我的疑问: 为什么调和分析要从 $\mathcal{L}^2$
空间讲起, 它究竟有何优越性. $\mathcal{L}^2$ 空间下的函数总是在给定一组基底(正交函
数类)后有一个平方收敛级数与之一一对应, 或者说, $\mathcal{L}^2$ 是一个无穷维的, 元
素为函数的线性空间, 并配备有 $L^2$ 范数.&lt;/p>
&lt;p>总的来讲, &lt;em>Baby Rudin&lt;/em> 是一本从各个方面都让我大开眼界的书. 毫无疑
问, 它带我从一个新的角度去审视分析, 无论是拓扑的引入, 多元函数求导, 还
是微分形式上的积分, 勒贝格积分, 这本书带给我的新概念和该年间的新联
系都丰富了我的视野. 不过, 这本书即便是正文, 有一些内容依然是比较难以
理解的, 特别是对符号使用的克制, 有时觉得有些古色古香, 有时又让我感到
有些找不着北. 而且, 据说本文最精华的是每章最后的习题, 这些部分我都是
扫了一眼, 大概看看几个可能会提出较新概念新定义的问题, 并没有深入去
做. 也许我就是所谓的名词党吧, 不怎么做题, 应该是学不到什么真材实料的.
不过作为一个爱好者, 感觉也没有什么太大的问题吧. 下一本书可能是读完
回国前正在看的 &lt;em>Intro to Manifolds&lt;/em>, 也可能是还在国外的时候看的 &lt;em>Chap 0&lt;/em>, 但
是最有可能的应该是暂时放下数学.&lt;/p>
&lt;p>最后, 我想对沃兹基德讨论组的小顾同学表达感谢, 没有他组织的倒霉
蛋抽奖环节, 我不可能有机会一览这本经典分析学教材的风采. 希望后来的
倒霉蛋抽奖能帮助到更多人, 也祝愿沃兹基德讨论组越来越好.&lt;/p></description></item><item><title>Phase Field: 相场模拟学习笔记 I</title><link>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-i/</link><pubDate>Fri, 01 Nov 2024 00:00:00 +0800</pubDate><guid>https://a-moment096.github.io/p/phase-field-%E7%9B%B8%E5%9C%BA%E6%A8%A1%E6%8B%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-i/</guid><description>&lt;img src="https://a-moment096.github.io/posts/PF_Tutorial/Skadi.png" alt="Featured image of post Phase Field: 相场模拟学习笔记 I" />&lt;p>&lt;em>这学期开了相场模拟培训, 故尝试将相场培训笔记性质的内容记录下来, 期望观感应该是目录式的笔记, 外带可有可无的说明文字.那么就开始吧&lt;/em>&lt;/p>
&lt;h2 id="phase-field-method-是什么">Phase Field Method 是什么？
&lt;/h2>&lt;p>Phase Field Method, 直译为相场法, 是一种材料模拟方法, 其通过宽界面(平滑界面)的特点, 克服了另一个模拟方法: Stefan 法的窄界面无法计算的缺点, 实现了对材料中的相的演化的模拟.&lt;/p>
&lt;h3 id="基本概念解析">基本概念解析
&lt;/h3>&lt;ul>
&lt;li>Phase Field: 所谓的相场, 可以理解为模拟域, 给每个点赋予一个值来表示不同的相以及相界面&lt;/li>
&lt;li>Order Parameter: 序参量, 即上一条中用来表示不同相的变量.一般0代表没有这个相, 1代表完全占据这个相, 介于0到1之间的即为相界面.&lt;/li>
&lt;li>Free Energy Functional: 自由能泛函, 相场背后的热力学机理, 通过系统对自由能最低构型方向的移动来演化出模拟域中每个点的值的变化.&lt;/li>
&lt;li>Governing Equations: 演化方程, 用来加工上述自由能泛函的方程.对不同特性的变量, 需要选择不同的演化方程以进行演化:
&lt;ul>
&lt;li>AC: Allen-Cahn方程, 用来演化非保守场的方程(即变量之和可以不为某一定值, 比如相序参量), 可以认为是有源CH方程；&lt;/li>
&lt;li>CH: Cahn-Hilliard方程, 用来演化保守场的方程(即变量值和为某个定值, 比如浓度).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ac-和-ch-方程">AC 和 CH 方程
&lt;/h3>&lt;p>AC方程的形式如下:
&lt;/p>
$$
\frac{\partial \eta_p}{\partial t} = -L_{pq}\frac{\delta F}{\delta\eta_q\left( r,t \right)}
$$&lt;p>CH方程形式如下:
&lt;/p>
$$
\frac{\partial c_i}{\partial t} = \nabla \cdot M_{ij} \nabla \frac{\delta F}{\delta c_j \left( r,t \right)}
$$&lt;p>解两个方程需要的工具有: 解ODE/PDE(有限差分法, FDM), 求自由能的变分导数(欧拉-拉格朗日方程, E-L方程), 向量微积分($\nabla$与$\nabla^2$)&lt;/p>
&lt;hr>
&lt;center>Nov 05 更新: &lt;/center>
&lt;h2 id="解ode-有限差分法">解ODE: 有限差分法
&lt;/h2>&lt;p>数值方法解ODE有很多种不同的方法, 比如傅里叶谱 (Fourier Spectrum) 方法, 有限元法 (Finite Element Method, FEM), 以及这里讲到的有限差分法 (Finite Difference Method, FDM).&lt;/p>
&lt;p>有限差分法应该是最方便的一种求解方法, 其基本思想便是简单地把&amp;quot;求导&amp;quot;过程中的&amp;quot;求极限&amp;quot;的步骤省略掉, 用极小的区间上的商来替代导数. 这样一来, 复杂的求导运算即可通过简单的乘法和加法完成, 而微分方程也就可以通过上一步(临近的上一个点)的值进行迭代来获得下一个点的结果, 从而实现微分方程的求解.&lt;/p>
&lt;p>有限差分法相比与其他算法, 其优势不仅在于求解逻辑简单, 还在于该解法对于求解的区域的限制较小, 对于多种边界条件下的微分方程都可以作出求解, 因此是一种比较通用的解法.&lt;/p>
&lt;p>下面给出有限差分法的基本公式以及部分代码实现:&lt;/p>
&lt;p>对于如下的常微分方程初值问题:
&lt;/p>
$$ \dfrac{\mathrm{d}\,y}{\mathrm{d}\,x} = f(x,y);$$&lt;p>
&lt;/p>
$$ y(x_0) = y(a) = y_0, $$&lt;p>
其中 $x \in \left[ a,b \right] \subseteq \mathbb{R} $, $y(x) \in \mathbb{R} \to \mathbb{R}$
由此可以选定一大整数 $ N $, 记 $h = \dfrac{b-a}{N}$, $ x_0 = a, x_i = x_0 + ih, x_N = b, y_i = y(x_i).$
则由有限差分, 该初值问题方程可以改写为:
&lt;/p>
$$ \dfrac{y_i - y_{i-1}}{h} = f(x_{i-1},y_{i-1}); \tag{显式欧拉法}$$&lt;p>
&lt;/p>
$$ \dfrac{y_i - y_{i-1}}{h} = f(x_{i},y_{i}). \tag{隐式欧拉法}$$&lt;p>
其中显式方法可以直接求得:
&lt;/p>
$$ y_i = h f(x_{i-1},y_{i-1}) + y_{i-1}. $$&lt;p>这里使用 Python 实现显式欧拉法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="s1">Explicit Euler Method
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="s1">list x and y should have an initial value.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">typing&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Callable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">explicit_euler&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl">&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">y&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于隐式欧拉法, 在给出$f(x,y)$的具体表达式的情况下, 可以显式给出非递归的算法, 否则由于等式右侧存在待求量, 无法显式逐步解出. 除了两种欧拉法, 还有梯形公式 (算术平均 $ f(x_i,y_i) $ 与 $f(x_{i-1},y_{i-1})$), 通过&lt;em>预估-校正&lt;/em>技术实现的改进欧拉公式, 以及精度较高的 Runge-Kutta 方法.
这里给出四阶 Runge-Kutta 法的 Python 实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="ln"> 1&lt;/span>&lt;span class="cl">&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 2&lt;/span>&lt;span class="cl">&lt;span class="s2">Runge-Kutta Method
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 3&lt;/span>&lt;span class="cl">&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 4&lt;/span>&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">runge_kutta&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 5&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Callable&lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nb">float&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 6&lt;/span>&lt;span class="cl">&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 7&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 8&lt;/span>&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln"> 9&lt;/span>&lt;span class="cl"> &lt;span class="n">k_1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">10&lt;/span>&lt;span class="cl"> &lt;span class="n">k_2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">k_1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">11&lt;/span>&lt;span class="cl"> &lt;span class="n">k_3&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">k_2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">12&lt;/span>&lt;span class="cl"> &lt;span class="n">k_4&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">k_3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">13&lt;/span>&lt;span class="cl"> &lt;span class="n">y&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k_1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">k_2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">k_3&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k_4&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;center>Nov 06 更新: &lt;/center>
&lt;h2 id="自由能泛函与变分导数-euler-lagrange-方程">自由能泛函与变分导数: Euler-Lagrange 方程
&lt;/h2>&lt;h3 id="自由能-引导体系演化的主趋力">自由能: 引导体系演化的主趋力
&lt;/h3>&lt;p>先谈谈自由能. 相场中使用的自由能主要是亥姆霍兹自由能. 不过无论是亥姆霍兹自由能, 还是吉布斯自由能, 其作为自由能, 都表明了一个体系的状态, 且在自由能梯度的驱使下, 体系将朝着体系自由能最低的方向发展. 而这即为相场法背后的主要热力学依据.&lt;/p>
&lt;p>相场中所用的自由能通常具有以下的形式:&lt;/p>
$$ F(c, \eta, \nabla c, \nabla \eta) = \int_{\Omega} f(c, \eta) + \kappa_c (\nabla c)^2 + \kappa_\eta (\nabla \eta)^2 + S\; \mathrm{d}\omega.$$&lt;p>其中, $c$ 为浓度, $\eta$ 为序参量 (标示某个相区域的变量), $f(c,\eta)$ 部分是体系的&lt;em>体自由能&lt;/em>, 可以认为是体系平衡时的自由能; 两个梯度项 $\kappa_c (\nabla c)^2 $, $ \kappa_\eta (\nabla \eta)^2$ 为描述并控制相界面宽度与迁移速率的项, 可以认为是&lt;em>界面能&lt;/em>对总能量的贡献. 最后的 $S$ 则是其余部分对体系自由能的贡献, 如磁场, 电场, 温度场等等. 这几个部分相互作用, 共同指明了体系的演化方向, 并标示了平衡状态.&lt;/p>
&lt;h3 id="泛函-函数的函数">泛函: 函数的函数
&lt;/h3>&lt;p>上面的自由能表达式实际上是一种泛函, 其中的浓度和序参量均为模拟域位置的函数. 除此之外, 且是一类经典泛函:
&lt;/p>
$$
J\left[ y \right]=\int_{\Omega} L(x,y(x),y'(x)) \,\mathrm{d}\omega.
$$&lt;p>
的空间形式 (即替换一般导数为梯度). 其中 $\Omega$ 是函数 $y$ 的定义域, 函数 $y$ 在泛函中充当自变量的作用. 这类泛函通常带有物理背景, 因此得到了广泛研究, 对其极限函数的研究 (即能使 $J$ 取到极值的函数 $u$)也已经有一套成熟的方法.&lt;/p>
&lt;h3 id="euler-lagrange-方程">Euler-Lagrange 方程
&lt;/h3>&lt;p>所谓 Euler-Lagrange 方程, 是指对上述类型的泛函的方程:
&lt;/p>
$$
\frac{\partial L}{\partial f}-\frac{\mathrm{d} }{\mathrm{d} x}\frac{\partial L}{\partial f'} = 0. \tag{1}
$$&lt;p>
该方程的作用与一般函数 $y = \phi(x)$的极值判断方程
&lt;/p>
$$
\phi'(\xi) = 0 \tag{2}
$$&lt;p>
类似, 都是指明了极值点出现的条件: (1) 指出极限函数 $f$ 应满足 E-L 方程, 而 (2) 则指出极值点 $\xi$ 应满足导数在该点处取值为0. 由此也不难理解泛函导数 (或者叫变分导数) 的形式应为方程(1)的左半部分:
&lt;/p>
$$
\frac{\delta J[y]}{\delta y} = \frac{\partial L}{\partial y}-\frac{\mathrm{d} }{\mathrm{d} x}\frac{\partial L}{\partial y'}.
$$&lt;p>
当然, 这里只给出了一阶导参与泛函定义的情况. 对于更一般的情况
&lt;/p>
$$
J\left[ y \right]=\int_{\Omega} L(x,y(x),y'(x),\dots,y^{(n)}(x)) \,\mathrm{d}\omega,
$$&lt;p>
有如下表达式:
&lt;/p>
$$
\frac{\delta J[y]}{\delta y} = \frac{\partial L}{\partial y}-\frac{\mathrm{d} }{\mathrm{d} x}\frac{\partial L}{\partial y'} + \dots + (-1)^n \frac{\mathrm{d}^n }{\mathrm{d} x^n}\frac{\partial L}{\partial y^{(n)}}.
$$&lt;h2 id="向量微积分-nabla">向量微积分: $\nabla$
&lt;/h2>&lt;p>这里主要讨论 $\nabla$ 算符运算法则, 以及该算符与不同函数之间的作用结果. $\nabla$ 算符定义如下:&lt;/p>
&lt;p>设一三维线性欧式空间 $\mathbb{R}^3$ 的三个基向量分别为 $\mathbf{x_1}$, $\mathbf{x_2}$, $\mathbf{x_3}$, 则其上定义的 $\nabla$ 算符为:
&lt;/p>
$$ \nabla = \frac{\partial}{\partial x_1}\mathbf{x_1}+ \frac{\partial}{\partial x_2}\mathbf{x_2}+\frac{\partial}{\partial x_3}\mathbf{x_3},$$&lt;p>
写作向量形式则为:
&lt;/p>
$$ \nabla = \left[ \frac{\partial}{\partial x_1}, \frac{\partial}{\partial x_2}, \frac{\partial}{\partial x_3}\right]^{\mathsf{T}}.$$&lt;p>
因此, $\nabla$ 算符在直接作用于标量值函数 (如 $f: \mathbb{R}^3 \to \mathbb{R}$) 时, 结果为 $\nabla f : \mathbb{R}^3 \to \mathbb{R}^3$, 得到该函数的&lt;em>梯度&lt;/em>; 当其与向量值函数 (如 $\phi:\mathbb{R}^3 \to \mathbb{R}^3 $ ) 点乘时, 结果为一标量值函数 $\nabla \cdot \phi :\mathbb{R}^3 \to \mathbb{R} $, 得到该&lt;em>向量场&lt;/em> (即为定义域每个点赋予一个向量而非标量值) 的&lt;em>散度&lt;/em>; 而当该算符与向量值函数叉乘时, 得到的结果则为一向量值函数 $\nabla \times \phi : \mathbb{R}^3 \to \mathbb{R}^3$, 是该向量场的&lt;em>旋度&lt;/em>.&lt;/p>
&lt;p>如何考虑这样的算符运算结果呢? 注意到不论如何作用, 函数的定义域都是没有变化的, 亦即: 都是把一个向量映射到了某个值. 既然如此, 可以仅考虑其作用到的函数的定义域的影响, 即: &lt;em>给每个坐标一个值, 则形成一个向量; 向量点乘给出一个标量; 向量叉乘给出一个向量&lt;/em>. 也可以把三种运算看作三种不同的&amp;quot;函数&amp;quot;: &lt;/p>
$$\nabla:\mathbb{R} \to \mathbb{R}^3 ;$$&lt;p> &lt;/p>
$$\nabla\cdot: \mathbb{R}^3 \to \mathbb{R}; $$&lt;p> &lt;/p>
$$\nabla\times :\mathbb{R}^3 \to \mathbb{R}^3$$&lt;p>与原函数相复合的结果.&lt;/p>
&lt;p>下面给出三种作用方式的具体表达式:
&lt;/p>
$$\nabla f = \mathbf{x}_1 \frac{\partial f}{\partial x_1} + \mathbf{x}_2\frac{\partial f}{\partial x_2}+\mathbf{x}_3\frac{\partial f}{\partial x_3};$$&lt;p>
&lt;/p>
$$\nabla \cdot \mathbf{f} = \frac{\partial f_1}{\partial x_1} + \frac{\partial f_2}{\partial x_2}+\frac{\partial f_3}{\partial x_3};$$&lt;p>
&lt;/p>
$$\nabla \times \mathbf{f} = \begin{vmatrix}
\mathbf{x}_1 &amp; \mathbf{x}_2 &amp; \mathbf{x}_3 \\
\frac{\partial }{\partial x_1} &amp; \frac{\partial }{\partial x_2} &amp; \frac{\partial }{\partial x_3} \\
f_1 &amp; f_2 &amp; f_3
\end{vmatrix},
$$&lt;p>
其中 $f_i$ 表示 $\mathbf{f}$ 的分量函数. 下来再考察 $\nabla$ 算符的运算性质. 设 $a,b\in\mathbb{R}$ 为标量, $f,g : \mathbb{R}^3 \to \mathbb{R}$ 为标量函数, $\phi,\psi : \mathbb{R}^3 \to \mathbb{R}^3$ 为向量值函数.&lt;/p>
&lt;p>直接作用 (梯度):&lt;/p>
&lt;ul>
&lt;li>线性性: $\nabla(a f+bg) = a\nabla{f} + b\nabla g$&lt;/li>
&lt;li>莱布尼兹律: $\nabla(fg) = f\nabla{g} + g\nabla{f}$&lt;/li>
&lt;/ul>
&lt;p>点乘 (散度):&lt;/p>
&lt;ul>
&lt;li>线性性: $\nabla\cdot(a\phi+b\psi) = a\nabla\cdot{\phi} + b\nabla\cdot{\psi}$&lt;/li>
&lt;li>乘法律: $\nabla\cdot(f\phi) = f\nabla\cdot{\phi} + \phi\cdot\nabla{f}$&lt;/li>
&lt;/ul>
&lt;p>叉乘 (旋度):&lt;/p>
&lt;ul>
&lt;li>线性性: $\nabla\times(a\phi+b\psi) = a\nabla\times{\phi} + b\nabla\times{\psi} $&lt;/li>
&lt;li>乘法律: $\nabla\times(f\phi) = f\nabla\times{\phi} + \phi\times\nabla{f}$&lt;/li>
&lt;/ul>
&lt;p>其他:&lt;/p>
&lt;ul>
&lt;li>梯度无旋: $\nabla\times(\nabla{f}) = 0$&lt;/li>
&lt;li>旋度无散: $\nabla\cdot(\nabla\times{f}) = 0$&lt;/li>
&lt;li>拉普拉斯算符 (先梯后散): $\nabla\cdot\nabla{f} = \nabla^2{f} = \Delta{f}$&lt;/li>
&lt;/ul>
&lt;p>以上是比较常用的 $\nabla$ 算符性质. 实际上三种算符的组合恒等式非常多, 而实际上常用的等式则为以上所列.&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>相场法作为一种材料模拟方法, 其内容涉及范围广, 包括材料学(热力学, 动力学), 数值方法, 计算机编程等等相关内容. 解决上述列出的若干问题是开始相场模拟所必须的数学方法基础. 下一部分计划通过 Python 代码实现本文中的若干算法, 包括数值解ODE, 向量微积分的实现, 以及数值积分方法.&lt;/p></description></item></channel></rss>